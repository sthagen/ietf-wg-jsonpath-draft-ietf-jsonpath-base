{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-11-14T01:05:38.008011+00:00",
  "repo": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "controversial",
      "description": "",
      "color": "DD912A"
    },
    {
      "name": "task",
      "description": "",
      "color": "bfd4f2"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "BCFCD9"
    },
    {
      "name": "processing-model",
      "description": "",
      "color": "bfdadc"
    },
    {
      "name": "has PR",
      "description": "",
      "color": "984AD5"
    },
    {
      "name": "ready for merging",
      "description": "",
      "color": "0e8a16"
    },
    {
      "name": "overtaken by events -- can we close this now?",
      "description": "",
      "color": "D04E17"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU2NTE0OTY3NjM=",
      "title": "github action to check the XML and ABNF",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/2",
      "state": "OPEN",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "help wanted",
        "task"
      ],
      "body": "It would be good to automate a check based on the authoring instructions in the README, so that we don't accidentally check in incorrect XML source or invalid ABNF (although it's invalid at the time of writing because the draft hasn't got any ABNF yet!).",
      "createdAt": "2020-07-06T12:25:39Z",
      "updatedAt": "2021-11-10T04:14:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "This should be done by moving to Martin Thomson's I-D template, which has active development.",
          "createdAt": "2021-03-03T17:39:10Z",
          "updatedAt": "2021-03-03T17:39:10Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "We have moved to I-D-template and have a scripts/gen.sh that does the check.\r\nA check-in check would be possible, but maybe unnecessary.\r\n",
          "createdAt": "2021-11-09T21:21:58Z",
          "updatedAt": "2021-11-09T21:21:58Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Now we have moved to kramdown source, the XML check is unnecessary.\r\n\r\nHowever, a [PR with invalid ABNF](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/133) passes all checks (see screenshot below), so a github action, e.g. to fail if `scripts/gen.sh` fails, is still be nice to have.\r\n![Screenshot from 2021-11-10 03-09-09](https://user-images.githubusercontent.com/94953/141042677-ebca4f2e-e01b-437c-9875-7290e175a512.png)\r\n\r\n\r\n",
          "createdAt": "2021-11-10T03:07:22Z",
          "updatedAt": "2021-11-10T03:10:32Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "OK, I have put on a \"task\" label -- this is not an issue with the document.",
          "createdAt": "2021-11-10T04:14:41Z",
          "updatedAt": "2021-11-10T04:14:41Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2NTE1NDU4MjQ=",
      "title": "README headings not rendering correctly due to non-breaking spaces",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/3",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was fixed by @morrme in https://github.com/jsonpath-standard/internet-draft/pull/1.\r\n\r\nIt seems that vscode introduces non-breaking spaces instead of spaces somewhat unpredictably. See [stack overflow](https://stackoverflow.com/questions/57162734/vscode-inserting-non-breaking-spaces-instead-of-regular-spaces).",
      "createdAt": "2020-07-06T13:36:53Z",
      "updatedAt": "2020-07-06T13:37:00Z",
      "closedAt": "2020-07-06T13:37:00Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2NTcyNjc4ODQ=",
      "title": "Optional root (`$`) selector",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/8",
      "state": "CLOSED",
      "author": "bettio",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "enhancement",
        "controversial"
      ],
      "body": "[A number of implementations support implicit root selector](https://cburgmer.github.io/json-path-comparison/results/dot_notation_without_root.html) (e.g. `key` instead of `$.key`).\r\n\r\n## Proposal\r\n**The standard should support optional root selector.**\r\n\r\nIt should be supported since it is widely accepted and also a handy shortform (which I expect to be frequently used).\r\n\r\nAs an example, we should take into account that this behavior is supported by JavaScript jsonpath and jsonpath-plus that counts for a total of ~800000 weekly downloads and ~900 dependents on npm. Furthermore this is supported by Goessner implementation too.\r\n\r\nFor the sake of simplicity a path starting with `$` should be defined as \"canonical form\" / \"normal form\" on the specification.\r\n\r\nTherefore, the following:\r\n\r\n> \"Syntactically, a JSONPath consists of a root selector (`$`), which selects the root node of a JSON document, followed by a possibly empty sequence of matchers.\"\r\n\r\nmight be rephrased as:\r\n\r\n> \"Syntactically, a canonical JSONPath consists of a root selector (`$`), which selects the root node of a JSON document, followed by a possibly empty sequence of matchers.\"\r\n\r\nAs a consequence of this feature (for consistency reasons) `[\"key\"]` and `[0]` should be supported as well.\r\n\r\nWe also should take a decision about `.key`, which is supported by few popular implementations.",
      "createdAt": "2020-07-15T11:12:39Z",
      "updatedAt": "2021-11-11T04:58:56Z",
      "closedAt": "2021-11-09T21:18:34Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I disagree with this proposal. The `$` is an identifier which represents the root of the JSON instance.  It can also be used in query expressions (#17).\n\nIf individual implementations wish to add support for omitting this character, they can do so without being out of compliance with the spec.",
          "createdAt": "2020-09-26T22:55:03Z",
          "updatedAt": "2020-09-26T22:55:03Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "I used to think this was a good idea, but have since changed my mind, and now share [gregsdennis](https://github.com/gregsdennis)'s view. As [gregsdennis](https://github.com/gregsdennis) noted, there are natural extensions to the expression syntax that benefit from being able to base the expression at either the root (`$`) or the current (`@`) node, and generally, to my eye, the notation is more comprehensible with these symbols explicit.",
          "createdAt": "2021-01-28T21:46:43Z",
          "updatedAt": "2021-01-28T21:46:43Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps we should discuss:\r\n> If individual implementations wish to add support for omitting this character, they can do so without being out of compliance with the spec.\r\n\r\nIt depends. For example, if the spec requires an implementation to return an error if an invalid selector is provided, then implementations wouldn't be able to add this support without becoming non-compliant.\r\n\r\nThe alternative is to make the spec somehow more permissive. For example, we could say that if an invalid selector is provided, then an implementation MAY return an error. My concern with a more permissive approach would be the difficulty of testing that for compliance.",
          "createdAt": "2021-01-29T04:25:06Z",
          "updatedAt": "2021-01-29T04:25:06Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> The alternative is to make the spec somehow more permissive.\n\nThis was my point in saying it.\n\n> we could say that if an invalid selector is provided, then an implementation MAY return an error.\n\nActually, you need to invert the inflection: say that the implementation SHOULD return an error.  Leave it at that.  This opens the door for optional support of additional syntaxes without explicitly stating it.\n\nSHOULD is strong enough that an implementor should think twice before deciding against the requirement, but allows them to still claim compliance if they choose not to.\n\nIf you want to take it further, the spec could state that the default behavior of the implementation MUST be per spec, but it could have an option or switch that enables extended support.\n\n> My concern with a more permissive approach would be the difficulty of testing that for compliance.\n\nJSON Schema is quite permissive and has a very extensive test suite.  Test what the spec requires. Maybe have optional tests for common permissive cases, or let implementations independently test their optional support.",
          "createdAt": "2021-01-29T10:28:14Z",
          "updatedAt": "2021-01-29T10:28:14Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "As an added note here, I've been looking into JMESPath, and it loos like they've opted to drop the \"start path\" `$` from their syntax (it's not even optional, they've just omitted it).  As a result, they can't do something like this:\r\n\r\n```\r\n$.foo[?(@.bar == $.baz)]\r\n```",
          "createdAt": "2021-10-05T22:41:08Z",
          "updatedAt": "2021-10-05T22:41:41Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting. Can they do something semantically equivalent by leaving out the `$`?",
          "createdAt": "2021-10-06T08:04:06Z",
          "updatedAt": "2021-10-06T08:04:06Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "hmm ... so equivalent to \r\n```\r\n.foo[?(@.bar == .baz)]\r\n```\r\nwould then be\r\n```\r\n['foo'][?(@.bar == ['baz'])]\r\n```\r\n",
          "createdAt": "2021-10-06T09:16:13Z",
          "updatedAt": "2021-10-06T09:16:13Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That looks quite confusing, in my opinion. If I omit `$` in `$.foo`, I consider root as \"current context\"; but if I write `.foo` within a filter - it seems like I had dropped `@` as it's normally considered as \"current context\" there. And allowing to drop just `$` but not `@` looks inconsistent to me.\r\n\r\nI would prefer to keep `$`/`@` explicit. I don't see any significant profit from making them optional, except for BC with some implementations. I think that consistency of syntax is more important for the standard than BC.",
          "createdAt": "2021-10-06T11:29:41Z",
          "updatedAt": "2021-10-06T11:29:41Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> As an added note here, I've been looking into JMESPath, and it loos like they've opted to drop the \"start path\" `$` from their syntax (it's not even optional, they've just omitted it). \r\n\r\nJMESPath as defined in [JMESPath Specification](https://jmespath.org/specification.html) doesn't have a symbol for the root value, there is no counterpart to '$', so it would be more accurate to say that they drop the '@.' from their syntax, where `@` represents the _current_ node (the current node being the same as the root at the start of evaluation.) In JMESPath, `@.bar` would be equivalent to just `bar`, and `@[0]` would be equivalent to just `[0]`. The current node symbol `@` is, according to the specification, \"only allowed when it's used in a bare expression\", i.e. in contexts such as \r\n```\r\n@ == `[1,2]`\r\n```     \r\nor\r\n```\r\ncount(@)\r\n```\r\n(However, I think the grammar does allow `@.bar` in addition to `bar`).\r\n\r\n> As a result, they can't do something like this:\r\n> \r\n> ```\r\n> $.foo[?(@.bar == $.baz)]\r\n> ```\r\nThere were proposals to introduce lexical scoping in JMESPath, see [James James Saryerwinnie's original proposal](https://github.com/jmespath/jmespath.site/blob/ae5ad3f590ae92c9789f3e5cacd99726ea028b74/docs/proposals/let-function.rst) and [Michael Dowling's sugestion](https://github.com/jmespath/jmespath.site/pull/6#issuecomment-91977719). These proposals would e.g. support binding the value of `baz` at the start of evaluation (equivalent to `$.baz`) to a variable named `foo`,  and thus support something like `bar == $foo`, where the variable `foo` is referenced using `$foo` notation. These proposals never made it into the JMESPath specification, though.\r\n\r\nSome implementations of JMESPath extend the syntax to support the `$` symbol to refer to the root, and allow `bar == $.baz`.\r\n\r\nSee also [\\#76](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/76), which compares the meaning of \"current node\" in JSONPath, JMESPath, and XPath 3.1.\r\n\r\n ",
          "createdAt": "2021-10-06T14:55:27Z",
          "updatedAt": "2021-10-06T17:03:28Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> hmm ... so equivalent to\r\n> \r\n> ```\r\n> .foo[?(@.bar == .baz)]\r\n> ```\r\n> \r\n> would then be\r\n> \r\n> ```\r\n> ['foo'][?(@.bar == ['baz'])]\r\n> ```\r\n\r\nThe equivalent JMESPath expression would be\r\n```\r\nfoo[?bar == baz]\r\n```\r\nor\r\n```\r\nfoo[?\"bar\" == \"baz\"]\r\n```",
          "createdAt": "2021-10-06T15:08:33Z",
          "updatedAt": "2021-10-06T15:15:55Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed in #115 ",
          "createdAt": "2021-11-09T21:18:34Z",
          "updatedAt": "2021-11-09T21:18:34Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "What was the resolution?  Did we decide to require `$` at the start of a path (and either `$` or `@` for expression paths)?",
          "createdAt": "2021-11-11T04:58:56Z",
          "updatedAt": "2021-11-11T04:58:56Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU2NTczOTEzMDY=",
      "title": "Valid identifiers",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/9",
      "state": "CLOSED",
      "author": "bettio",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "A valid identifier rule (for \"dot child\" and recursive descent) should be discussed.\r\n\r\n* All implementations agree on `[a-zA-Z_][a-zA-Z0-9_]*`\r\n* Most implementations allow a dash in the middle of a identifier (e.g. `key-dash`)\r\n* Consensus on `$.-key` and `$.key-` has not been investigated\r\n* Most implementations allow unicode identifiers such as `$.\u5c6c\u6027`\r\n* Consensus on digits as first identifier character has not been investigated\r\n\r\n## Proposal\r\n* Identifier regexp must be simple. e.g. some implementations allow any unicode codepoint except `\\s`, `\\t`, `$`, `.`, `*`, etc... This approach allows writing regexp similar to `[^'\".*()$?,>=<\\-\\:\\@\\[\\]\\s\\t\\n\\r]*`. If this approach is confirmed a list of disallowed codepoints should be identified.\r\n* `-` should not be allowed as first identifier character\r\n* `[0-9]` as first identifier character should be investigated and discussed.",
      "createdAt": "2020-07-15T14:23:02Z",
      "updatedAt": "2021-11-11T04:58:03Z",
      "closedAt": "2021-11-09T21:16:41Z",
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the context for this issue is \"dot child\" (e.g. `.somekey`) as union/bracket child should allow more esoteric possibilities (e.g. `[\" \"]`). Also, it may be relevant to (so called, currently) recursive descent (e.g. `..somekey`).\r\n\r\nFor consensus on digits as first identifier character, [dot_notation_with_number](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_number.html) and especially [dot_notation_with_number_object](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_number_on_object.html) are relevant.\r\n\r\n@remorhaz is currently investigating the use of identifier syntax as part of https://github.com/jsonpath-standard/internet-draft/pull/5 and may wish to comment.",
          "createdAt": "2020-07-15T14:34:38Z",
          "updatedAt": "2020-07-15T14:34:38Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "See also https://github.com/cburgmer/json-path-comparison/issues/42",
          "createdAt": "2020-07-16T08:29:11Z",
          "updatedAt": "2020-07-16T08:29:11Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "\u261d\ufe0f possible duplication",
          "createdAt": "2020-09-28T19:27:30Z",
          "updatedAt": "2020-09-28T19:27:30Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@bettio \r\n\r\n> A valid identifier rule (for \"dot child\" and recursive descent) should be discussed.\r\n> \r\n> * Most implementations allow a dash in the middle of a identifier (e.g. `key-dash`)\r\n\r\nIt depends whether we're looking at the main path or in filter predicates.\r\n\r\nIn the main path, as in\r\n```\r\n$.key-dash\r\n```\r\nthere is a [consensus to support a dash in identifiers](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_dash.html). However, in filter predicates, as in\r\n```\r\n$[?(@.key-dash == 'value')]\r\n```\r\nthere is [no such consensus](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_dot_notation_with_dash.html). Only 13 out of 41 implementations support a dash in identifiers in filter predicates. Most do not.\r\n\r\n",
          "createdAt": "2021-03-16T02:23:47Z",
          "updatedAt": "2021-03-16T02:53:47Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I am more in the camp of the non-dash supporters ...",
          "createdAt": "2021-03-17T14:46:41Z",
          "updatedAt": "2021-03-17T14:46:41Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed in #102 ",
          "createdAt": "2021-11-09T21:16:41Z",
          "updatedAt": "2021-11-09T21:16:41Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "What was the resolution?  Do we allow hyphens?  Was a PR needed to change anything?",
          "createdAt": "2021-11-11T04:58:02Z",
          "updatedAt": "2021-11-11T04:58:02Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU2OTQyNTY3ODM=",
      "title": "Define an algorithm",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/14",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cabo"
      ],
      "labels": [
        "processing-model",
        "overtaken by events -- can we close this now?"
      ],
      "body": "The processes between implementations may vary widely.  This is fine so long as they all have the same output for the a given input.  However it may be beneficial to outline a basic algorithm.\r\n\r\n- guidance for new implementations\r\n- reference point internally to the spec for describing how operators (selectors) work.\r\n\r\n## First thoughts\r\n\r\nDefine a selector to be a function that takes an array of values and outputs an array of values:\r\n\r\n```\r\nselector(value[]) : value[]\r\n```\r\n\r\nNext, define a path as a sequence of selectors.\r\n\r\n```\r\npath : selector[]\r\n```\r\n\r\nTo evaluate a path on a JSON instance, we just need to place the instance in an array and run through all of the selectors so that the output of each selector is the input of the next.  The final output is the output of the final selector.\r\n\r\n```\r\ncurrent = [input]\r\nfor each selector in path\r\n    current = selector(current)\r\n\r\nreturn current\r\n```\r\n\r\n---\r\n\r\nLooking at it, there's not really much to it, but it's nice to have something defined.  Now we only need to define the selectors (I'm authoring another issue).",
      "createdAt": "2020-09-06T05:26:20Z",
      "updatedAt": "2021-11-09T21:14:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "It's also possible to frame this in terms of a selector that takes a single value as input and produces an array of values as output. Then the above code needs a \"flat map\" adding to it, which might be a bit opaque in pseudocode.",
          "createdAt": "2020-09-14T08:37:22Z",
          "updatedAt": "2020-09-14T08:37:22Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, but that's merely iterating the function taking a single value and iterating over the values output by the previous selector.  I think it's simpler when the selector takes in the full output from the previous one.  Regardless, the important bit here is that we should define something for that the spec can reference.\r\n\r\n(JSON Schema does this when talking about annotations.)",
          "createdAt": "2020-09-18T06:10:35Z",
          "updatedAt": "2020-09-18T06:10:35Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think it's simpler when the selector takes in the full output from the previous one.\r\n\r\nThe code calling the selector is simpler because it no longer needs a \"flat map\", but then every selector has a more complex signature, taking an array of values as input instead of a single value. Also, I think each selector really needs to treat each value in the array independently from the rest, and that's obvious if a single value is passed to the selector instead of an array of values.",
          "createdAt": "2020-09-18T06:28:22Z",
          "updatedAt": "2020-09-18T06:28:22Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "That's fine, but we need to be sure that the results of each selector are collected separately so that there is a clear definition of when to move to the next selector.\r\n\r\nPassing full array (repeated from above):\r\n```\r\ncurrent = [input]\r\nfor each selector in path\r\n    current = selector(current)\r\n\r\nreturn current\r\n```\r\n\r\nPassing individual items:\r\n```\r\ncurrent = [input]\r\nfor each selector in path\r\n    results = []\r\n    for each item in current\r\n        results.add(selector(item))\r\n    current = results.distinct()\r\n\r\nreturn current\r\n```\r\n\r\nIt can be very easy, but wrong, to get to something like this while trying to optimize:\r\n```\r\ncurrent = [input]\r\nfor each selector in path\r\n    for each item in current\r\n        current.add(selector(item))\r\n\r\nreturn current\r\n```\r\n\r\nI think the first one is simpler from an overall perspective (\"each selector processes the results from the previous selector\").  You then say that each selector iterates over the items it's given, returning the _distinct_ aggregate reults.  It encapsulates iteration over the current result set and applying the \"distinct\" operation.\r\n\r\nAgain, so long as we have something defined, implementers can (and will) do what they like.",
          "createdAt": "2020-09-18T06:40:59Z",
          "updatedAt": "2020-09-18T07:32:38Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Don't forget that selectors have recursive nature (I mean filters). To implement `[?(@.foo.bar==1)]` selector, you'll have to walk through the whole algorithm from inside of `select()` function, which will lead to recursive calls and thus to stack overflow danger.\r\n\r\nAnd note that we have [a consensus](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subpaths.html) for this behavior.",
          "createdAt": "2020-09-23T11:34:38Z",
          "updatedAt": "2020-09-23T11:34:38Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting that Proposal A's syntax precludes filters inside filters and thus avoids the risk of stack overflow.",
          "createdAt": "2020-09-23T13:14:08Z",
          "updatedAt": "2020-09-23T13:14:08Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking at Section 2.5, paragraphs 2 & 3, the algorithm above is defined. \ud83d\udc4d \r\n\r\nHowever, if we state that the root node is placed in a list of nodes (as the only item in the list), this allows us to also state that *all* selectors, including the root selector take a list of nodes and return a list of nodes.\r\n\r\nIt's cleaner not having a special case for the root selector.",
          "createdAt": "2020-09-24T11:45:48Z",
          "updatedAt": "2020-09-24T11:46:08Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's cleaner not having a special case for the root selector.\r\n\r\nI agree. The reason I special-cased it was to avoid paths like `$.a$.b`, but that can be ruled out by the syntax without special casing the semantics. ",
          "createdAt": "2020-09-24T11:57:46Z",
          "updatedAt": "2020-09-24T11:57:46Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding \"filters inside filters\", I've begun to address this in https://github.com/jsonpath-standard/internet-draft/issues/17.  I see no problem with supporting full JSON Path syntax on the `@` selector.",
          "createdAt": "2020-09-25T06:50:37Z",
          "updatedAt": "2020-09-25T06:50:37Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "What about the risk of a CPU or stack overflow exploit from filters inside filters?",
          "createdAt": "2020-09-28T09:03:15Z",
          "updatedAt": "2020-09-28T09:03:15Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "What about the risk of a CPU or stack overflow exploit from filters inside filters?",
          "createdAt": "2020-09-28T09:04:02Z",
          "updatedAt": "2020-09-28T09:04:02Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's possible to avoid using call stack directly. In my implementation I've just introduced operations like \"split\" and \"join\" (not very good naming for sure) on entering/exiting the sub-query and kept a map of \"parent\" nodes, and I've compiled each query into a linear set of operations.",
          "createdAt": "2020-09-28T10:36:03Z",
          "updatedAt": "2020-09-28T10:36:12Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "There's may still be the risk of a CPU exploit if we allow filters inside filters. The following example runs slowly against the small document `[\"a\", \"b\", \"c\", \"d\"]`:\r\n```\r\n$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==\"b\")])])])])])])])])])]\r\n```\r\nIt would be easy to crank this 10-20 levels deeper and thereby hog the CPU.",
          "createdAt": "2020-09-28T15:02:17Z",
          "updatedAt": "2020-09-28T15:02:17Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That should not execute much slower than simple sequence of `$[?($)][?($)][?($)][?($)]...`. You mean that JSON document being queried has \"natural\" limitation of nested levels?",
          "createdAt": "2020-09-28T15:48:32Z",
          "updatedAt": "2020-09-28T15:48:32Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Since each nested filter in the above example scans the 4 elements of the document's array, then the algorithm is O(4**N) where N is the filter nesting level.\r\n\r\nOn the other hand`$[?($)][?($)][?($)][?($)]...` with N repetitions of `[?($)]` will execute in O(N).",
          "createdAt": "2020-09-28T16:08:46Z",
          "updatedAt": "2020-09-28T16:08:46Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the dependency is linear and we just have to have a sequence 4 times longer to hog the CPU for the price of nested filters power. As for me it's too cheap :)\r\n\r\nAnother possible attack is `$[?(@.a || @.b || @.c ...)]` - same O(N), but no possible \"empty-tail\" protection.\r\n\r\nI think we can just write some short text in our document about possible attacks for implementers.",
          "createdAt": "2020-09-28T16:47:01Z",
          "updatedAt": "2020-09-28T16:47:01Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, you're right, `$[?($)][?($)][?($)][?($)]...` is O(4*N) if the array is length 4.\r\n\r\nNot sure what implementers can do to mitigate such attacks, except run in some environment which can limit CPU consumption.",
          "createdAt": "2020-09-28T16:57:43Z",
          "updatedAt": "2020-09-28T16:57:43Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "We should add these exploits to the security section of the document.",
          "createdAt": "2020-09-28T16:58:17Z",
          "updatedAt": "2020-09-28T16:58:17Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we need to concern ourselves with stack overflows for this purpose.  That's an implementation detail, and not our responsibility.  Many languages and frameworks have no problem with recursion while others may not support it at all.  It's not our concern, though, as someone implementing JSON Path in a language where recursion is unsupported (or limited) should be familiar with methods for getting around it (as @remorhaz has demonstrated).\r\n\r\nOur purpose here is to define something that we can reference.  If the simplest representation uses recursion, so be it.",
          "createdAt": "2020-09-28T19:10:20Z",
          "updatedAt": "2020-09-28T19:10:20Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "If you feel we should add language detailing potential exploits that need to be mitigated against, then I suggest that goes in a separate issue here in GH and a separate, dedicated section of the spec.",
          "createdAt": "2020-09-28T19:12:51Z",
          "updatedAt": "2020-09-28T19:13:11Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Exploits should go in the security section.",
          "createdAt": "2020-09-29T05:30:30Z",
          "updatedAt": "2020-09-29T05:30:30Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU2OTQzMDE1MzM=",
      "title": "Selector definitions (basically an analysis and description of the DSL)",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/15",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "processing-model",
        "overtaken by events -- can we close this now?"
      ],
      "body": "We still don't yet have an official definition of each of the operators (\"selectors\").  This issue has been created to define all of the things that we expect JSON Path should be able to do.\r\n\r\n### **\\<NOTE>**\r\n*In the second comment, I reconsider the interpretation I post in the this first comment.  However, I'm leaving it here for posterity as it does contain some interesting ideas.*\r\n### **\\</NOTE>**\r\n\r\n## Basic Operations\r\n\r\n`$` - Selects the root of the instance.  MUST be used at the start of the path; MAY be used in expressions as a reference.\r\n`.<name>` - If the value is an object selects the value in the property indicated by `<name>`, if it exists; otherwise an empty array.\r\n`.*` - If the value is an object, selects the values of all properties; otherwise an empty array.\r\n`[<index>]` - If the value is an array, selects the values at the positions indicated by `<index>`.  (See array indices later.)\r\n`[*]` - If the value is an array, selects all of the values in it; otherwise an empty array.\r\n\r\nThis is where I start to have issues with the way that Goessner defined things.  There is an incongruity between the syntax and the operation of the \\*-syntax and the name-syntax of the property selector and the recursive selector.\r\n\r\nAs mentioned above, `.prop` would select the value under the `prop` property of a local object.  Similiarly, `..prop` would find all objects recursively and select the values under their `prop` properties.  These seem to behave the same, and this makes sense as they have similar syntaxes.\r\n\r\nBut the \\*-syntax selectors *don't* behave the same, even though they look like they should.  `.*` will select all values of all properties *if the local value is an object*.  `..*` on the other hand recursively selects *all values* including the local value (consensus says most do, some only select children) and values inside both objects and arrays.  It seems like the logical behavior for `..*` should be to recursively find values of object properties.\r\n\r\nBut this leaves a gap: how do we define the \"recursive get everything\"?  Furthermore, do we need a \"local get everything\" that would return the current item and array items (if an array) or object values (if an object)?\r\n\r\nThat confusion aside, defining `..*` this way opens the door for another syntax: `.[*]`, which would recursively select all values in arrays.  In essence, it defines the recursion operator merely as a `.` followed by another operator.  This means that if we want the \"select all\" behavior, we can define a new operator (and character) for it.\r\n\r\n## Selecting Everything\r\n\r\nFor now, suppose we use `~`.  This gives these selectors as well:\r\n\r\n- `.~` - Selects the current value (maybe) and its local decendents, whether they are property values or array items.\r\n- `..~` - Selects the current value (maybe) and its recursive decentents.\r\n\r\n### Does `~` select the current node?\r\n\r\nConsider the example currently in the spec:\r\n\r\n```json\r\n{\r\n  \"a\": [\r\n    {\"b\": 1},\r\n    {\"b\": 2},\r\n    {\"b\": 3},\r\n  ]\r\n}\r\n```\r\n\r\nIf our path is `$.~`, then we have two options.  If we return the local value (the root), then we also include the intermediate values, like the array and all of the objects in it.  If we don't return the local value and only return the children values, then we must apply the same logic at every step so that the result is only the leaf values: `[1, 2, 3]`.\r\n\r\nThe consensus report shows that most implementations return the intermediate values, therefore, they should also return the local value.\r\n\r\n## Array Indices\r\n\r\nThe array selector supports a number of index forms\r\n\r\n- direct index lists\r\n- index calculations\r\n- predicate selections\r\n\r\nThe consensus shows that not only are single selections (as in Goessner's post) generally supported, but comma-delimited lists of indices are allowed.  (Goessner does have a single example with multiple indices: `$..book[0,1]`)  And many also support mixing the various styles.\r\n\r\n### Direct index lists\r\n\r\nEach item can be a single index or a [slice-notation index range](https://stackoverflow.com/a/509295/878701) (couldn't find a spec on it, but this SO answer is pretty thorough, even if it's for python).\r\n\r\n### Index calculations\r\n\r\nThis index is an expression that evaluates to a valid index, surrounded by parentheses.\r\n\r\nIt's unclear if Goessner's intent was to have the expression only evaluate to a single value, but we *could* support it evaluating to a collection or slice-notation.\r\n\r\n### Predicate selections\r\n\r\nThis index is also an expression, except that it evaluates to a boolean result.  The expression iterates over all of the items and returns `true` for items to include and `false` for those to exclude.  Like the other expression, this is surrounded by parentheses, however in this case the parentheses are preceded by a `?`.\r\n\r\n### Expression syntax\r\n\r\nExpressions bring us to the last selector, `@`.  This selector is context sensitive: it carries a slightly different meaning depending on which type of index it's in.\r\n\r\nFor index calculation expressions, this symbol represents the array itself.  It can be used in the expression to obtain information about the array, as in Goessner's example `$..book[(@.length-1)]`.\r\n\r\nFor predecate selection expressions, this symbol represents the current item as the selection iterates over the contents of the array.\r\n\r\nThere are some other details about the expression syntax that would probably be better [discussed in another issue](https://github.com/jsonpath-standard/internet-draft/issues/17).",
      "createdAt": "2020-09-06T09:01:26Z",
      "updatedAt": "2021-11-09T22:23:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "An alternative to the above (and probably the more correct interpretation of Goessner's post) is ignoring the difference between objects and arrays except when a property name or numeric index is specified.  The following results for the selectors:\r\n\r\n- `.name` - if an object, gets the value under the `name` property, if it exists; otherwise an empty array.\r\n- `[1]` - if an array, gets the value at index 1 (0-based), if it exists; otherwise an empty array.\r\n- `.*` _and_ `[*]` - if an object, gets the values for all properties; if an array, gets all values; otherwise an empty array.  (These are the same.)\r\n- `..name` - recursively selects the `name` property from all objects.\r\n- `..*` - gets all values (including the local value), recursively selecting both object property values and array item values.\r\n\r\nI think this is probably closer to how implementations currently interpret these selectors.   The difference here is that we've defined `*` universally as \"select all children of the local value regardless of the local value's type\" rather than making a distinction between the object or array syntax.\r\n\r\nAnother benefit of this interpretation is that `[*]` covers the string-index format for property selection, e.g. `['name']`, without the need for additional clarification in the spec.\r\n\r\nNote that there isn't an array analog for `..name`.  I think a syntax like `.[1]` would work to recursively select all values at index 1 in arrays.  This reinforces the idea from above that a `.` followed immediately by another operator indicates a recursive search.\r\n\r\nLastly the expression-style selectors would also be able to select values in objects.\r\n\r\nI think this is a better definition for the selectors than what I put above.",
          "createdAt": "2020-09-11T05:39:28Z",
          "updatedAt": "2020-09-11T05:45:22Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "[@gregsdennis](https://github.com/gregsdennis) wrote:\r\n\r\n> An alternative to the above (and probably the more correct interpretation of Goessner's post) is ignoring the difference between objects and arrays except when a property name or numeric index is specified. The following results for the selectors:\r\n> \r\n> * `.name` - if an object, gets the value under the `name` property, if it exists; otherwise an empty array.\r\n> * `[1]` - if an array, gets the value at index 1 (0-based), if it exists; otherwise an empty array.\r\n> * `.*` _and_ `[*]` - if an object, gets the values for all properties; if an array, gets all values; otherwise an empty array.  (These are the same.)\r\n> * `..name` - recursively selects the `name` property from all objects.\r\n> * `..*` - gets all values (including the local value), recursively selecting both object property values and array item values.\r\n> \r\n> I think this is probably closer to how implementations currently interpret these selectors. \r\n\r\nI think it would be more accurate to write\r\n\r\n* `.name` - if an object, gets the value under the `name` property and adds it to a collection of selected items, otherwise does \r\nnothing.\r\n\r\nIn the case of no match, I don't think a selector can be said to get an empty array.\r\n\r\nIf \"paths\" are in effect, it would need to update the path corresponding to that value as well.\r\n\r\n\r\n",
          "createdAt": "2021-03-09T15:38:17Z",
          "updatedAt": "2021-03-09T15:45:26Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-09, at 16:38, Daniel Parker ***@***.***> wrote:\n> \n> In the case of no match, I don't think a selector can be said to get an empty array.\n\nAn array is a data item.  I think we are talking about an empty collection (my tentative term for what XPath calls nodeset).\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-09T15:44:44Z",
          "updatedAt": "2021-03-09T15:44:44Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "[@cabo](https://github.com/cabo) wrote:\r\n\r\n> On 2021-03-09, at 16:38, Daniel Parker ***@***.***> wrote: In the case of no match, I don't think a selector can be said to get > an empty array.\r\n> An array is a data item. I think we are talking about an empty collection (my tentative term for what XPath calls nodeset). \r\n> Gr\u00fc\u00dfe, Carsten\r\n\r\nRight, but the collection wouldn't necessarily be empty when the selector was evaluated. Selectors are chained, an individual selector adds to the collection in the case of a match, but adds nothing in the case of no match. Of course, you already know that. But taken literally, @gregsdennis wording could be taken to mean that in the case of no match, the selector added an empty array to the collection, hence my comment.  ",
          "createdAt": "2021-03-09T15:57:33Z",
          "updatedAt": "2021-03-09T16:09:48Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\n\n> On 2021-03-09, at 16:57, Daniel Parker ***@***.***> wrote:\n> \n> Right, but the collection wouldn't necessarily be empty when the selector was evaluated. Selectors are chained, an individual selector adds to the collection in the case of a match, but adds nothing in the case of no match. Of course, already you know that. But taken literally, @gregsdennis wording could have been taken to mean that the selector added an empty array to the collection, hence my comment.\n\n\nYou lost me.  Are you saying that the collection resulting from\n\n$.a.b.c\n\nis the union of those resulting from\n\n$.a\n$.a.b\n$.a.b.c\n\n?\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-09T17:01:57Z",
          "updatedAt": "2021-03-09T17:01:57Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> On 2021-03-09, at 16:57, Daniel Parker ***@***.***> wrote: Right, but the collection wouldn't necessarily be empty when the selector was evaluated. Selectors are chained, an individual selector adds to the collection in the case of a match, but adds nothing in the case of no match. Of course, already you know that. But taken literally, @gregsdennis wording could have been taken to mean that the selector added an empty array to the collection, hence my comment.\r\n> You lost me. Are you saying that the collection resulting from $.a.b.c is the union of those resulting from $.a $.a.b $.a.b.c ? Gr\u00fc\u00dfe, Carsten\r\n\r\nNo, but I can certainly see how you could have interpreted it that way! By match I meant a match for the expression \"$.a.b.c\", but worded that poorly. In this case the collection would be empty until evaluating the tail of the path \".c\", if it got that far.\r\n\r\nBut to my point, consider the [store example](https://goessner.net/articles/JsonPath/index.html#e3) with path `$..isbn`. In this case `.isbn` will be applied four times, at the tail end of four paths. In two cases with match, an isbn will be added to the collection, in the two others with no match, nothing will be added to the collection.  In the latter cases, I don't think it can be said that the selector got an empty array, rather, it did nothing.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-03-09T17:37:19Z",
          "updatedAt": "2021-03-09T17:37:19Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> @danielaparker - if an object, gets the value under the name property and adds it to a collection of selected items, otherwise does nothing.\n\nYes. This is what I meant. I was considering `.name` to be the party in its entirety here, do the final result would be empty.  In most cases, this kind of operation is one of successive many, so the value, if any, would be added to whatever result collection exists.",
          "createdAt": "2021-03-09T18:01:35Z",
          "updatedAt": "2021-03-09T18:05:28Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": " I would like to complete the list above with symmetry in mind:\r\n\r\n- `.name` _and_  `['name']` - if an object, gets the value under the `name` property, if it exists; otherwise an empty array.\r\n- `[1]` - if an array, gets the value at index 1 (0-based), if it exists; otherwise an empty array.  Not `['1']` !\r\n- `.*` _and_ `[*]` - if an object, gets the values for all properties; if an array, gets all values; otherwise an empty array.  (These are the same.)\r\n- `..name` _and_  `..['name']` - recursively selects the `name` property from all objects.\r\n- `..*` _and_ `..[*]` - gets all values (including the local value), recursively selecting both object property values and array item values. Not the same as `..['*']` !\r\n",
          "createdAt": "2021-03-09T19:06:45Z",
          "updatedAt": "2021-03-09T19:06:45Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "\u261d\ufe0f that, too, yes, combined with what @danielaparker said about the return values.",
          "createdAt": "2021-03-10T03:04:03Z",
          "updatedAt": "2021-03-10T03:04:03Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU2OTk5Nzc0MzA=",
      "title": "Non-property-name-friendly chars",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/16",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should probably define what characters are valid for property names.  JSON makes no distinction, so we should support everything.  But this becomes especially important for the dot-property syntax.\r\n\r\nThe index-property syntax `[\"name\"]` can support any string, so that's not a problem.  (I also think it's a good idea to mirror JSON's escaping requirements for strings.)\r\n\r\nBut for the dot-property syntax `.name`, I think it's probably a good idea to limit this to alphanumeric characters and underscores: `^[_a-zA-Z0-9]$`.  The following should also be considered:\r\n\r\n- Non-English characters\r\n- Starting with a number (many languages don't support starting with a number)\r\n- Emoji and other UTF16 codepoints",
      "createdAt": "2020-09-12T02:38:02Z",
      "updatedAt": "2021-06-14T09:48:27Z",
      "closedAt": "2021-06-14T09:48:27Z",
      "comments": [
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This syntax is being defined [here](https://github.com/jsonpath-standard/internet-draft/pull/13), and there were some discusions related to the problem.",
          "createdAt": "2020-09-23T08:45:48Z",
          "updatedAt": "2020-09-23T08:45:48Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the current definition of `[-_a-zA-Z0-9\\u0080-\\u10FFFF]+` is good.  (I understand that `\\u10FFFF` isn't in the proper range for Regex, but you get the idea.)",
          "createdAt": "2020-09-24T19:46:33Z",
          "updatedAt": "2020-09-24T19:46:33Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "So, I ran into a problem with trying to parse `$..book[(@.length-1)]` after I made the change to support thus character set.  Specifically, the parser extracted `length-1` as the property name.\r\n\r\nThis revealed that expressions will be quite difficult to parse if `-` is allowed in property names.\r\n\r\nI think we should remove `-` from the allowed list.",
          "createdAt": "2020-09-26T22:37:36Z",
          "updatedAt": "2020-10-16T12:56:36Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Apparently, also relates to (or completely duplicates) #9.",
          "createdAt": "2020-09-26T22:47:13Z",
          "updatedAt": "2020-09-26T22:47:13Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> This revealed that expressions will be quite difficult to parse if - is allowed in property names.\r\n\r\nAgreed, but I'd prefer to disallow expressions rather than remove `-` from property names as I suspect it's quite commonly used.",
          "createdAt": "2020-09-28T08:55:16Z",
          "updatedAt": "2020-09-28T08:55:16Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "It's still valid in the quoted-index syntax: `$[\"dashed-property\"]`.",
          "createdAt": "2020-09-28T19:31:53Z",
          "updatedAt": "2020-09-28T19:31:53Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'd prefer to disallow expressions rather than remove `-` from property names as I suspect it's quite commonly used.\r\n\r\nAnd expressions aren't commonly used?  You can't just remove expression support: it's part of Goessner's original post, and it's what gives JSON Path it's real power.\r\n\r\nAdditionally many languages forbid `-` in property names, whereas `_` is allowed.  It's even disallowed in Javascript, the language of the original implementation.",
          "createdAt": "2020-10-17T02:19:53Z",
          "updatedAt": "2020-10-17T21:06:35Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Some relevant reading:\r\n\r\n- [Python](https://stackoverflow.com/questions/2064329/why-does-python-disallow-usage-of-hyphens-within-function-and-variable-names): not supported\r\n- [C/C++](https://en.wikibooks.org/wiki/C_Programming/Variables#Naming_Variables): not supported\r\n- [Java](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html): not supported\r\n- [C#](https://stackoverflow.com/questions/12216225/how-do-i-declare-a-variable-with-hyphen-on-it): not supported\r\n- [Go](https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go#naming-variables-rules-and-style): not supported\r\n- [R](https://stackoverflow.com/a/48811387/878701): not supported\r\n- [Swift](https://stackoverflow.com/a/54510804/878701): not supported\r\n- [PHP](https://stackoverflow.com/a/9322340/878701): not supported\r\n- [Javascript](https://stackoverflow.com/q/5516106/878701): only supported with the quoted-indexer syntax, e.g. `value['some-prop']`\r\n- [Ruby](https://www.ruby-forum.com/t/hyphens-in-variable-names/97518/2): only supported with the indexer syntaxes, e.g. `value[\"some-prop\"]` or `value[:some-prop]`\r\n- [Perl](https://perl6advent.wordpress.com/2015/12/05/day-5-identifiers-have-hyphens-in-them/): supported, but variable names are prefixed with `$` to identify them separately from subtraction.  (Still, how is `$variable-5` interpreted?)\r\n",
          "createdAt": "2020-12-04T22:28:37Z",
          "updatedAt": "2020-12-04T22:32:02Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "I share [gregsdennis](https://github.com/gregsdennis)'s concerns about allowing hyphens in unquoted names. Doing so leads to issues with subtraction in filter expressions, see [Filter expression with subtraction](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subtraction.html). Given\r\n\r\n```\r\n[{\"key\": 60}, {\"key\": 50}, {\"key\": 10}, {\"key\": -50}, {\"key-50\": -100}]\r\n```\r\nand selector\r\n```\r\n$[?(@.key-50==-100)]\r\n```\r\nit seems reasonable, consistent with the other arithmetic operations, to expect a result\r\n```\r\n[ { \"key\": -50  }]\r\n```\r\n11 of the implementations give this result, which includes all of the ones that use javascript as a script engine, in particular Goessner, and the Python implementation.\r\n\r\nHowever, if the identifier were determined to be `key-50`, then the result would be\r\n```\r\n{\"key-50\": -100}\r\n```\r\n13 of the implementations give this result.\r\n\r\nMore generally, is it a good idea to allow unquoted names that would be illegal as identifiers in popular interpreters such as javascript?\r\n",
          "createdAt": "2021-01-28T03:18:24Z",
          "updatedAt": "2021-01-28T14:54:21Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "To add to  [gregsdennis](https://github.com/gregsdennis)'s list of interpreters that don't support identifiers with hyphens, but have JSONPath:\r\n\r\n [lua](https://www.lua.org/manual/5.1/)",
          "createdAt": "2021-01-28T03:57:30Z",
          "updatedAt": "2021-01-28T04:09:38Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "On the other side of the story ...\r\n\r\nFrom Christoph Burgmer's comparisons, it appears that [dashes in unquoted names](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_dash.html) is the consensus. Given\r\n```\r\n{\"key-dash\": \"value\"}\r\n```\r\nthe selector\r\n```\r\n$.key-dash\r\n```\r\nresults in\r\n```\r\n[\"value\"]\r\n```\r\nfor about half of the implementations. This includes the important Jayway and Goessner implementations. \r\n\r\nHowever, Jayway and Goessner part company when it comes to filter expressions. Given\r\n```\r\n[{\"key-dash\": \"value\"}]\r\n```\r\nthe selector\r\n```\r\n$[*][?(@.key-dash == 'value')]\r\n```\r\nin Jayway, results in\r\n```\r\n[{\"key-dash\" : \"value\"}]\r\n```\r\nand, in Goessner, in\r\n```\r\njsonPath: dash is not defined: _v.key-dash == 'value'\r\n```\r\nWhen a JavaScript interpreter is involved, the rules for identifiers _are_ the rules of JavaScript, similarly for other interpreters.  \r\n\r\nFollowing up on a point raised earlier by [gregsdennis](https://github.com/gregsdennis), implementations that follow Jayway don't support the `length` property on arrays, they don't support\r\n```\r\n$..book[(@.length-1)]\r\n```\r\nbut instead support a length function at the tail end of the path,\r\n```\r\n$..book[(@.length()-1)]\r\n```\r\n\r\nBut in any case, with unquoted names with dashes and subtraction, the user will need to know to leave a space before the minus sign.\r\n\r\nMy tentative conclusions are:\r\n\r\n- Given the popularity of names with dashes, and the broad support for unquoted names with dashes in legacy implementations, it would be difficult to exclude them in the draft.\r\n- Implementations that employ a scripting language for evaluating expressions _must_ follow the rules for that scripting language, even if inconsistent with the name requirements in the primary path.\r\n- There's a limit to how much the draft can say about expressions. Implementations diverge, depending on whether they're using a scripting language, or a custom evaluator. In the former case, users may have to live with inconsistency in naming requirements, and in the latter case, with having to include a space before a minus sign.\r\n ",
          "createdAt": "2021-01-28T17:21:08Z",
          "updatedAt": "2021-01-28T22:08:00Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Implementations that employ a scripting language for evaluating expressions must follow the rules for that scripting language.\n\nAnother issue discusses expression support that is independent of the language the implementation is written in. Only by doing this can a path string be interoperable across multiple platforms.\n\nInteroperability and language agnosticity needs to be a central tenet of this project if we want wide acceptance.\n\nEither way, the inclusion of hyphens in unquoted names needs to be well-defined.  That support also needs to be the same for path operators and within expressions.  Supporting hyphens in one and not the other is an inconsistency that will confuse the user.\n\nIt is my opinion that we should disallow them, however we _can_ make provision that if an implementation wishes to support it, they may, but paths that rely on such support cannot be guaranteed to work across platforms.",
          "createdAt": "2021-01-29T03:14:18Z",
          "updatedAt": "2021-01-29T03:27:58Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "Just as a footnote, for comparison, [JMESPath identifiers](https://jmespath.org/specification.html#identifiers) do _not_ allow hyphens in unquoted strings.  ",
          "createdAt": "2021-01-29T03:57:56Z",
          "updatedAt": "2021-01-29T03:58:13Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> > This revealed that expressions will be quite difficult to parse if - is allowed in property names.\r\n> \r\n> Agreed, but I'd prefer to disallow expressions rather than remove `-` from property names as I suspect it's quite commonly used.\r\n\r\nMost (all?) implementations that support a dash in unquoted names don't attempt anything difficult when parsing expressions.\r\nComparing [Dot notation with dash](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_dash.html) and [Filter expression with subtraction](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subtraction.html), implementations that support a dash in unquoted names generally give precedence to dash interpreted as part of identifier, and the user has to know to put a space before a minus sign, 13 implementations take that approach. The exception are implementations that allow a dash in unquoted names in the primary path, but not in filter expressions, most notably Javascript Goessner, which uses Javascript as a \"script engine\". The inattentive user may experience surprising results.\r\n\r\nThe argument in favor of allowing dashes in unquoted names is to accommodate legacy implementations, the argument against is to have a cleaner language. Now that Stefan Goessner has lent his authority to [_not_ allowing dashes](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/53), perhaps it's time to frame this as a decision point, and open it to debate on the jsonpath list?  ",
          "createdAt": "2021-01-31T20:30:48Z",
          "updatedAt": "2021-01-31T22:11:00Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> Most (all?) implementations that support a dash in unquoted names don't attempt anything difficult when parsing expressions.\r\n\r\nSo we obviously see here 'the normative power of the factual', which is usually hard to ignore.\r\n\r\n> Comparing [Dot notation with dash](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_dash.html) and [Filter expression with subtraction](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subtraction.html), implementations that support a dash in unquoted names generally give precedence to dash interpreted as part of identifier, and the user has to know to put a space before a minus sign, 13 implementations take that approach. The exception are implementations that allow a dash in unquoted names in the primary path, but not in filter expressions, most notably Javascript Goessner, which uses Javascript as a \"script engine\". The inattentive user may experience surprising results.\r\n\r\nThanks for bringing this up. In fact I never intended to allow dashes with dot notation, in the same way, as JavaScript disallows them inside of variable names. Maybe I should have tested those simple regular expressions, I used in my initial implementation, more carefully. Having access to Christoph Burgmer's tests would have been highly valuable at that time.\r\n\r\nOf course I respect and even share the idea of being careful with breaking existing implementations.\r\n\r\nBy the way:\r\n* I enjoyed Tim Bray's '[Jsonpath] JSONpath corner case' in this context. \r\n* I am carefully reading through the Mail Archive at current (from past to present) ...\r\n* ... what should have been my first activity here. \r\n* I am not aware, how to link into that archive.\r\n\r\n",
          "createdAt": "2021-02-09T19:10:50Z",
          "updatedAt": "2021-02-09T19:10:50Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not aware, how to link into that archive.\r\n\r\n1. View the archive at https://mailarchive.ietf.org/arch/browse/jsonpath/.\r\n\r\n2. Find a post.\r\n\r\n3. Click on the link symbol named \"Message detail\" shown at the top\r\nright of the screenshot below.\r\n\r\n4. Copy the URL of the item.\r\n\r\n\r\n![Screenshot from 2021-02-15 03-41-40](https://user-images.githubusercontent.com/94953/107903248-a3b3ed00-6f40-11eb-9b78-e819a5a199af.png)\r\n",
          "createdAt": "2021-02-15T03:49:36Z",
          "updatedAt": "2021-02-15T03:49:36Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> So, I ran into a problem with trying to parse `$..book[(@.length-1)]` after I made the change to support thus character set. Specifically, the parser extracted `length-1` as the property name.\r\n> \r\n> This revealed that expressions will be quite difficult to parse if `-` is allowed in property names.\r\n> \r\n> I think we should remove `-` from the allowed list.\r\n\r\nIn support of this proposal, while it has been claimed that legacy implementations support a dash in unquoted names, that's only partly true.\r\n\r\nIt is true that In the main path, [most legacy implementations support a dash](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_dash.html), as in\r\n```\r\n$.key-dash\r\n```\r\nHowever, in filter predicates, as in\r\n```\r\n$[?(@.key-dash == 'value')]\r\n```\r\nthere is [no such consensus](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_dot_notation_with_dash.html). Only 13 out of 41 implementations support a dash in unquoted names in filter predicates, most do not. \r\n\r\nI think it's unlikely that a JSONPath specification will want to accept different naming conventions in the main path and in filter predicates. Hence, even with respect for legacy behaviour as a motivating factor, a decision will need to be made. And, as noted, allowing a dash in unquoted names in filter predicates causes trouble.",
          "createdAt": "2021-03-16T02:45:29Z",
          "updatedAt": "2021-03-16T02:50:44Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU3MDQyMjgyNTc=",
      "title": "Query expression language support",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/17",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "overtaken by events -- can we close this now?"
      ],
      "body": "In his post, Goessner indicates that for `[(...)]` (\"container query\") and `[?(...)]` (\"item query\"), the contained expression should use \"the underlying script engine.\"\r\n\r\nThis presents a problem for consistency and interoperability between systems.  A JSON Path written with a Javascript expression won't work when evaluated using an implementation written in PHP or .Net.\r\n\r\nTo address this, we should either define that the scripting language is something well-known (e.g. ECMAScript 2015 or C), or we should define our own language (a domain-specific language, or DSL).\r\n\r\n## Proposal\r\n\r\nI like the idea of a simple DSL, and this proposal outlines the rules around such a language.\r\n\r\n### Exploring the data with `@`\r\n\r\nJSON elements can be explored using JSON Path within the expression, and the values that are returned can be compared using simple comparison operators.\r\n\r\nThis alone enables expressions like `?(@.price<10)` and `?(@.isbn)`.  These state \"the path `@.price` returns a value and that value is less than 10,\" and \"the path `@.isbn` returns a value,\" respectively.  And because these are just JSON Paths, implementations will already have the parsing logic for them.  Further, it means that indexer syntax for property names will work, so that `?(@['price']<10)` and `?(@['isbn'])` will also work.\r\n\r\n### Operators\r\n\r\nThe basic comparison, mathematical, and boolean operators should be sufficient, at least for the initial revision of the specification.  I expect most programmers will be familiar with the C-style operators, so I propose we use those.\r\n\r\n```\r\n==   equal\r\n!=   not equal\r\n<    less than\r\n<=   less than or equal to\r\n>    greater than\r\n>=   greater than or equal to\r\n\r\n+    addition\r\n-    subtraction\r\n*    multiplication\r\n/    division\r\n%    modulus\r\n\r\n&&   and\r\n||   or\r\n```\r\n\r\nI'm open to alternatives, but this gives us a good grounding.\r\n\r\nPerhaps we can just use single `=`, `&`, and `|` instead of the doubles?  That might open up a `^` for an XOR or a `!&` for a NAND.  (`!|` for NOR is going to be fun to read.)\r\n\r\n### Reserved words\r\n\r\nI'd also like to propose that we define a number of reserved properties, like `length`.  This enables functionality like in the container query syntax example `(@.length-1)`.  If the user wants to reference an object property named `length`, they would need to specifically use the indexer syntax `(@['length'] - 1)` which would fetch the value from the `length` property of an object, subtract one, and return the result.\r\n\r\nAdditional reserved words that we may need are open for proposal/discussion.\r\n\r\nOpen question: Does this enable these reserved keywords outside of the context of a query expression, i.e. does `$.length` give the number of child items of the root value?\r\n\r\n### Backtracking?\r\n\r\nThere aren't any examples in Goessner's post, but it might be desirable to navigate up the JSON structure to fetch a value to be used in an expression.\r\n\r\nFor example (with Goessner's example data), suppose I wanted to find the books which cost less than the bike.  There isn't a way to get from iterating over the `book` array to _outside of_ the `book` array where the `bicycle` is.\r\n\r\nAlernatively, I *could* use the root operator `$` to start from the beginning within the expression and do something like `$..book[@.price<$..bicycle.price]`, so maybe this isn't explicitly needed for now.\r\n\r\n### Restrictions\r\n\r\nFor these cases, I think it makes sense to require that these internal paths MUST only return a single value.  Returning multiple values should remain an explicitly undefined behavior (allows the implementation to decide how to handle it).  (However doing something like `?(@..price.length>4)` to get \"are there more than 4 objects that contain a `price` property?\" does make sense.  The full path still just returns a single value, even though the `@..price` portion returns multiple.)\r\n",
      "createdAt": "2020-09-18T09:23:44Z",
      "updatedAt": "2021-11-09T21:12:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "It just occurred to me that in item queries like `?(@.price<10)`, the `10` is really just a JSON literal.  That *could* imply that you could have any JSON literal here, including booleans, strings, null, arrays, and objects:\r\n\r\n```\r\n$..name[?(@.values==[1,2,3])]\r\n```\r\n\r\nThis raises a question of what JSON equality is.  The basic types are fairly straightforward, but the complex types are more... complex.  JSON.org states that arrays are ordered and objects are key/value pairs, but not necessarily ordered.",
          "createdAt": "2020-09-19T22:42:46Z",
          "updatedAt": "2020-09-19T22:42:46Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "oops.",
          "createdAt": "2020-09-19T22:43:15Z",
          "updatedAt": "2020-09-19T22:43:15Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Also probably needs term grouping, i.e. `()` support.",
          "createdAt": "2020-09-20T00:45:30Z",
          "updatedAt": "2020-09-20T00:45:30Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that `@` could support the full JSON Path syntax, there is a question of having indexers with query expressions inside an `@`-path.  I think this is fine.  The only question is around scoping for the `@`.\r\n\r\nI think it makes sense to confine the scope to the innermost context.  This raises another question around how to reference the current item of any intermediate contexts.",
          "createdAt": "2020-09-25T06:54:35Z",
          "updatedAt": "2020-09-25T06:54:35Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> To address this, we should either define that the scripting language is something well-known (e.g. ECMAScript 2015 or C), or we should define our own language (a domain-specific language, or DSL).\r\n\r\nAnother option is to omit query expressions (but keep filters). I suspect there's not much consensus around query expressions or use of them for that matter.",
          "createdAt": "2020-09-28T09:00:51Z",
          "updatedAt": "2020-09-28T09:00:51Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Query expression _are_ what you're calling \"filters.\"  What are you suggesting we remove?  Without expression support, you can't do something like `$..[(@.length-1)]` without special-casing \"@.length-1\".  What if someone wanted to do `$..[(@.length-2)]`?  The only way to do this is to support expressions in general.\r\n\r\nAlso pertains to https://github.com/jsonpath-standard/internet-draft/issues/16#issuecomment-699875079.  You can't have the above if `-` can be part of a key.  Otherwise you're saying that `length-1` is the key.\r\n\r\nFurthermore, I lead this issue with\r\n\r\n> In his post, Goessner indicates that for [(...)] (\"container query\") and [?(...)] (\"item query\"), the contained expression should use \"the underlying script engine.\"\r\n\r\nHis post explicitly calls them expressions, too:\r\n\r\n> XPath | JSONPath | Description\r\n> -- | -- | --\r\n> ... | ... | ...\r\n> [] | ?() | applies a filter (script) expression.\r\n> n/a | () | script expression, using the underlying script engine.\r\n\r\n\r\n\r\nExpression support for these kinds of query is integral to JSON Path.  You can't just not have it.  Half of your query syntax goes away if you don't.",
          "createdAt": "2020-09-28T19:01:34Z",
          "updatedAt": "2020-09-28T19:05:09Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I _think_ `$..[(@.length-1)]` is equivalent to `$..[-1]` and `$..[(@.length-2)]` is equivalent to `$..[-2]`. Maybe there are other usages of subtraction \"in the wild\" which will influence the decision - I'm just not aware of them.\r\n\r\nI've not really looked at \"container queries\" using script expressions because they were so vaguely defined by G\u00f6ssner. I think it's a good topic for the Working Group to look into.",
          "createdAt": "2020-09-29T05:56:15Z",
          "updatedAt": "2020-09-29T05:56:15Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Those equivalencies are correct, but without expression support, you can't parse the `@.length-1` version without explicitly catering for that string or providing general expression support.\n\nI think expressions provide the end user (the path author) a better tool.",
          "createdAt": "2020-09-29T19:15:31Z",
          "updatedAt": "2020-09-29T19:15:31Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm thinking of examples like\n\n```\n$[?(@.prop+3<$.alertAt)] // comparison against another value\n$[?(@.prop%2=0)]  // finds even numbers\n$[?(@.prop=\"string\")]\n```\n\nWe don't know what people will want to do with expressions, and I don't like the idea of limiting our support to the simple examples in Goessner's post.\n\nThe last example really becomes important if we specify that the location of the value can also be returned.",
          "createdAt": "2020-09-30T05:03:29Z",
          "updatedAt": "2020-09-30T05:03:29Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "For me, filters `[?()]` seem to offer far more capabilities than \"container queries\" `[()]`. I'm wondering whether JSONPath would suffer much from dropping \"container queries\", especially if there isn't much consensus around them.",
          "createdAt": "2020-09-30T09:15:39Z",
          "updatedAt": "2020-09-30T09:15:39Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I can't say much about usage in the wild, but container queries can do things like `$.values[($.index)]` which can dynamically select a value based on the value in the property `index`.  I can see value in it, but...\r\n\r\nUsage stats probably aren't something we're likely to obtain accurate numbers on, either.",
          "createdAt": "2020-10-01T05:20:14Z",
          "updatedAt": "2020-10-01T05:20:14Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I can't say much about usage in the wild, but container queries can do things like `$.values[($.index)]` which can dynamically select a value based on the value in the property `index`. I can see value in it, but...\r\n\r\nThat example is pretty compelling. Someone out there must be using it...",
          "createdAt": "2020-10-01T09:58:16Z",
          "updatedAt": "2020-10-01T09:58:16Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "A need for expression support in the wild: [Get root element using jsonpath based on sub elements condition\r\n](https://stackoverflow.com/q/63470519/878701)",
          "createdAt": "2020-10-06T03:47:31Z",
          "updatedAt": "2020-10-06T06:08:35Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "The path that I suggested in that SO question is `$[?(@.phoneNumbers[*].type==\"iPhone\")].id`, but I think it would be better served with a function syntax (will elaborate in a bit).\r\n\r\nThe reasoning behind this is the requirement that paths in expressions should only return a single value.  However `@.phoneNumbers[*].type` actually returns multiple values, and we want to ensure that one of those values is `\"iPhone\"`.\r\n\r\nTo that end, alongside `.length`, I would like to propose another reserved word: `.contains`.  The kicker here is that we want to pass a parameter (the value to check for), so we need a parameter list: `.contains(\"iPhone\")`.  This, then, returns a boolean value, just like the `==` operator.\r\n\r\n---\r\n\r\nExtending this, it may make sense to have _all_ reserved words carry a parameter list, even if that list is empty.  For example, `.length()`.  This would leave the door open for `.length` to refer to a property named \"length\" instead.\r\n\r\n(It looks like the [Java implementation](https://github.com/json-path/JsonPath) does this.)",
          "createdAt": "2020-10-08T05:05:25Z",
          "updatedAt": "2020-10-08T05:06:26Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "The Working Group will need to decide whether to extend the syntax or standardise only what's already in use.",
          "createdAt": "2020-10-08T07:48:30Z",
          "updatedAt": "2020-11-04T15:26:03Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I've been thinking about the container expression syntax `[(...)]` a bit more, and I think it may be useful as an evaluatable index.\r\n\r\nIf we take `(@.length-1)` to evaluate to a numeric index, then this opens the door for the expression to also be used in the slice syntax.  For example `$[:(@.length-2)]` would be equivalent to `$[:-2]`.  Not really sure how useful that is.  It's not really a good example, but I imagine having the feature would result in some imaginative uses.\r\n\r\nI definitely wouldn't suggest this as a feature for the first draft, but it's something to consider.",
          "createdAt": "2020-10-17T02:07:31Z",
          "updatedAt": "2020-10-17T21:09:21Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "# Survey of script expression support\r\nThe [Script expression comparison](https://cburgmer.github.io/json-path-comparison/results/script_expression.html) shows some implementations which support script expressions, or container queries, (`[()]`):\r\n\r\n* [C++ jsoncons functions](https://github.com/danielaparker/jsoncons/blob/master/doc/ref/jsonpath/jsonpath.md#functions)\r\n* [Go github.com-spyzhov-ajson script engine](https://github.com/spyzhov/ajson#script-engine)\r\n* [JavaScript Goessner](https://goessner.net/articles/JsonPath/) (*)\r\n* [JavaScript brunerd](https://github.com/brunerd/jsonpath) (*)\r\n* [JavaScript jsonpath](https://github.com/dchester/jsonpath/blob/master/lib/grammar.js) (*)\r\n* [JavaScript jsonpath-plus](https://github.com/JSONPath-Plus/JSONPath)\r\n* [PHP softcreatr-jsonpath](https://github.com/SoftCreatR/JSONPath#script-expressions)\r\n* [Python jsonpath](http://www.ultimate.com/phil/python/#jsonpath) (*)\r\n* [Ruby jsonpath](https://github.com/joshbuddy/jsonpath) (*)\r\n* [dotNet JsonPathLib](https://github.com/atifaziz/JSONPath) (*)\r\n\r\n *: script expressions are not clearly defined\r\n\r\nIn addition, JMESPath (an alternative to JSONPath) includes an interesting set of [built-in functions](https://jmespath.org/specification.html#built-in-functions) which are probably candidates for including in script expressions.",
          "createdAt": "2020-11-05T12:16:20Z",
          "updatedAt": "2020-11-05T12:16:20Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Both of my implementations in dotnet support expressions: Manatee.Json & JsonPath.Net",
          "createdAt": "2020-11-05T20:19:32Z",
          "updatedAt": "2020-11-05T20:19:32Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Just logging [another question about expressions in the wild](https://stackoverflow.com/q/65654417/878701) about testing for the absence of a property.  Their go-to attempt was to use a `!` operator.",
          "createdAt": "2021-01-10T23:18:51Z",
          "updatedAt": "2021-01-10T23:18:51Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> *: script expressions are not clearly defined - @glyn\r\n\r\nThis is why we should clearly define the expected support.  It should be worded so that implementors may augment the syntax as well (while also providing documentation that such support is non-standard and may not be compatible with other systems).",
          "createdAt": "2021-01-10T23:21:26Z",
          "updatedAt": "2021-01-10T23:21:26Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Note that JMESPath is strict, sum only sums numbers.\n\nComing from a strongly typed language, this does appeal to me, but I'm biased.  Favor language agnosticity.",
          "createdAt": "2021-03-11T22:44:12Z",
          "updatedAt": "2021-03-11T22:44:12Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> `=~` \tLeft matches regular expression [?(@.author =~ /Evelyn.*?/)]\r\n\r\nI raised https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/70 to cover the details of regular expressions in filters.",
          "createdAt": "2021-03-12T05:02:39Z",
          "updatedAt": "2021-03-12T05:02:39Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "How do we expect filter working with following JSON input:\r\n```json\r\n[{\"k\": \"1.0\"}, {\"k\": 2}]\r\n```\r\nand JSONPaths such as `$[?(@.k == 1)]`?\r\n\r\nWhen using `$[?(@.k == 1)]` jayway JSONPath outputs the following JSON:\r\n```json\r\n[ ]\r\n```\r\n\r\nWhen using `$[?(@.k == 2.0)]` jayway JSONPath outputs the following JSON:\r\n```json\r\n[\r\n   {\r\n      \"k\" : 2\r\n   }\r\n]\r\n```\r\n\r\nWhile goessner when using $[?(@.k == 1)]\r\n```json\r\n[\r\n   {\r\n      \"k\" : \"1.0\"\r\n   }\r\n]\r\n```\r\n\r\nI think that `===` should be introduced, however I'm not sure if it is widely supported or not.",
          "createdAt": "2021-03-19T00:12:05Z",
          "updatedAt": "2021-03-19T00:12:05Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> How do we expect filter working with following JSON input:\r\n> \r\n> ```json\r\n> [{\"k\": \"1.0\"}, {\"k\": 2}]\r\n> ```\r\n> \r\n> and JSONPaths such as `$[?(@.k == 1)]`?\r\n> \r\n> When using `$[?(@.k == 1)]` jayway JSONPath outputs the following JSON:\r\n> \r\n> ```json\r\n> [ ]\r\n> ```\r\n> \r\n> When using `$[?(@.k == 2.0)]` jayway JSONPath outputs the following JSON:\r\n> \r\n> ```json\r\n> [\r\n>    {\r\n>       \"k\" : 2\r\n>    }\r\n> ]\r\n> ```\r\n> \r\n> While goessner when using $[?(@.k == 1)]\r\n> \r\n> ```json\r\n> [\r\n>    {It\r\n>       \"k\" : \"1.0\"\r\n>    }\r\n> ]\r\n> ```\r\n\r\nI think Goessner is right. \r\n\r\n> I think that `===` should be introduced, however I'm not sure if it is widely supported or not.\r\n\r\nIt's supported in implementations like Goessner that use Javascript for a scripting language. But not in Jayway, which implements its own evaluator. It would look foreign to users coming from a strongly typed background. But with numbers, keep in mind that 1.0 and 1 have the same JSON type.\r\n\r\nI prefer the JMESPath approach, which only has \"==\", but defines type requirements for comparators such as [equality operators](https://jmespath.org/specification.html#equality-operators). ",
          "createdAt": "2021-03-19T00:45:50Z",
          "updatedAt": "2021-03-19T00:48:28Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I'm leaving here a further comment as a reminder that scope for @ needs to be defined, as discussed in #75.",
          "createdAt": "2021-03-21T13:53:18Z",
          "updatedAt": "2021-03-21T13:53:18Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@bettio wrote:\r\n\r\n> I'm leaving here a further comment as a reminder that scope for @ needs to be defined, as discussed in #75.\r\n\r\nSee [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-803618374) for my views.",
          "createdAt": "2021-03-21T18:21:39Z",
          "updatedAt": "2021-03-21T18:21:39Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU3MDU0NTUxMTE=",
      "title": "GitHub-Slack integration test",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/18",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is just a sample issue to test the integration between GitHub and Slack.",
      "createdAt": "2020-09-21T10:00:47Z",
      "updatedAt": "2020-09-21T10:01:02Z",
      "closedAt": "2020-09-21T10:01:02Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "It worked!",
          "createdAt": "2020-09-21T10:01:02Z",
          "updatedAt": "2020-09-21T10:01:02Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3MDc4MTg1MjQ=",
      "title": "Unify terms",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/20",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "Sometimes in the draft, as it currently is, the terms \"matcher,\" \"selector,\" and \"filter\" seem to be used interchangeably.  These terms need to be explicitly defined, and where we have synonyms, we should only use one.\r\n\r\nPersonally, I'm in favor of \"selector\" for everything since JSON Path is technically a query language.  \"Matcher\", to me, sounds redundant when talking about its action: \"A matcher may match a node and, if it matches, ...\"  (Section 2.5).  Using the word \"selector\" here reduces some of the redundancy.",
      "createdAt": "2020-09-24T03:15:24Z",
      "updatedAt": "2020-09-24T12:45:58Z",
      "closedAt": "2020-09-24T12:45:58Z",
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Are we looking at the same draft and version? https://jsonpath-standard.github.io/internet-draft/ does not use the term filter, you see.",
          "createdAt": "2020-09-24T06:24:27Z",
          "updatedAt": "2020-09-24T06:24:27Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "I think I picked up \"filter\" from [one of my issues](https://github.com/jsonpath-standard/internet-draft/issues/14#issuecomment-697305948).  Still, we should use a single term.\r\n\r\nIt looks like we've made an effort to define \"matcher,\" but \"selector\" sounds more appropriate to me.",
          "createdAt": "2020-09-24T06:46:06Z",
          "updatedAt": "2020-09-24T06:46:06Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, I'll take a crack at this.",
          "createdAt": "2020-09-24T08:56:14Z",
          "updatedAt": "2020-09-24T08:56:14Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Filter is a `?(...)` construction. In fact, it's concrete case of a `union-element`.",
          "createdAt": "2020-09-24T08:56:21Z",
          "updatedAt": "2020-09-24T08:56:21Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, let's ignore filters for this issue. I'll see if we can replace \"matcher\" with \"selector\" sensibly.",
          "createdAt": "2020-09-24T08:57:27Z",
          "updatedAt": "2020-09-24T08:57:27Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3MDc5NjM3Mzc=",
      "title": "\"Union\" could have more description, and maybe a new name",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/21",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "processing-model"
      ],
      "body": "The term \"union\" will likely be unfamiliar for readers (it is for me) and could use a bit more description than \"A union ~matcher~ selector consists of one or more union elements.\"\r\n\r\n\"Union\" isn't a common term outside of set manipulation.  I would call the `[...]` an \"indexer,\" which is a much more well-known term and is already associated with this construct in many programming languages.  The values inside are indices (as opposed to \"union children\" or \"union elements\"), of which there are multiple types:\r\n\r\n- Integer\r\n- Slice\r\n- String\r\n- Container query expression\r\n- Item query expression\r\n\r\nSee [selector query expressions](https://github.com/jsonpath-standard/internet-draft/issues/17) for more details on the query-style indexers.",
      "createdAt": "2020-09-24T08:22:23Z",
      "updatedAt": "2021-03-10T12:19:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point. We have yet to decide whether unions remove or preserve duplicates and I think the outcome of that decision should influence the naming. \"Union\" as you point out has a set theory connotation and implies removing duplicates. It's tricky though because I think the result is ordered, whereas sets aren't ordered.",
          "createdAt": "2020-09-24T08:50:34Z",
          "updatedAt": "2020-09-24T08:50:34Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Regarding duplicates specifically, please see #23.",
          "createdAt": "2020-09-28T02:01:16Z",
          "updatedAt": "2020-09-28T02:01:16Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3MDg2NjUzMDE=",
      "title": "Duplicates in selector output",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/23",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "processing-model",
        "overtaken by events -- can we close this now?"
      ],
      "body": "Each selector may each return multiple nodes, or even the same node multiple times.  This raises the question of whether (and if so, how) the resulting collection of nodes needs to be distinct, i.e. without duplicates.\r\n\r\nAn example:\r\n\r\n```\r\nJSON instance:\r\n{\r\n  \"a\": [\r\n    \"string\",\r\n    null,\r\n    true\r\n  ],\r\n  \"b\": [\r\n    false,\r\n    \"string\",\r\n    5.4\r\n  ]\r\n}\r\n\r\nPath:\r\n$.*[0,1]\r\n```\r\n\r\nThe raw result set of this selector is `[\"string\", null, false, \"string\"]`.  If we say that we expect only the distinct set of nodes, then the results would be `[\"string\", null, false]`, removing the duplicate `\"string\"`.\r\n\r\nSo the question up for discussion is, \"Should selectors return distinct sets of nodes or are duplicates preferred?\"\r\n\r\n---\r\n\r\nI had been considering a location-based distinction (based on the location of the value in the original JSON structure) as a possibility, but I don't think it makes much sense given the definition of a selector in Section 2.5, taking multiple nodes and outputing multiple nodes.  A selector knows nothing about the original JSON structure that is being evaluated.\r\n\r\nHowever for posterity, consider the following (rather contrived) path evaluated against the above instance:\r\n\r\n```\r\n$.*[0,:5]\r\n```\r\n\r\nIn this case, the `\"string\"` value which is the first element of the `a` property would be selected twice, and the `\"string\"` value in the second element of the `b` property would be selected once, resulting in three `\"string\"` values in the results.  For location-based distinction, only the value from `a` would be considered duplicate, leaving two instances of `\"string\"` in the result set.\r\n\r\nAgain, I *don't* think that this is a viable approach due to how a selector works and the information it's given.  However, if we were to also require [location as part of the output](https://github.com/cburgmer/json-path-comparison/issues/29), then this *would* be a viable solution.",
      "createdAt": "2020-09-25T05:59:57Z",
      "updatedAt": "2021-11-11T05:15:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As for me I haven't see any implementations that tries to remove duplicate _values_ from result, and I don't think it's a good idea to introduce this behavior as default one. But maybe it's useful to provide some way to filter off duplicated values explicitly, like `$.*[0,1].unique()`.\r\n\r\nBut your second case (about selecting the _same node_ twice) is more interesting, because we _have_ to provide some default behavior; I will investigate the implementations on this case.",
          "createdAt": "2020-09-25T14:14:18Z",
          "updatedAt": "2020-09-25T14:14:54Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it might be useful to throw a scenario in the consensus project to get actual results of what the various implementations do.",
          "createdAt": "2020-09-25T21:46:29Z",
          "updatedAt": "2020-09-25T21:46:29Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "A scenario has been [added](https://github.com/cburgmer/json-path-comparison/commit/8d8292ef1fdfd6c64d77ff10e8b1e32e1bf5bbbc).  Just waiting on the report to regenerate.\r\n\r\nIt looks like the majority just don't support the example query. For those that do, it seems to be an even mix of all three approaches. No concensus implies no pressure to implement any particular scenario, but we need to discuss and agree on it.",
          "createdAt": "2020-09-28T19:24:21Z",
          "updatedAt": "2020-09-28T19:24:43Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "An option is to allow some latitude in the spec and say that \"duplicates MAY be removed, either by location and value\". But I think in that case we'd also need to tie down when that applies. Should it just apply to unions? Could it also apply in other cases, e.g. when using `[*]` against an array containing duplicate values (e.g. because there are duplicate values in the input document)?\r\n\r\n\"MAY\" will considerably complicate the CTS FWIW, especially if the CTS is purely declarative (e.g. cts.json) as that would put the onus on each CTS implementation to allow duplicates to be removed if appropriate.\r\n\r\nAlso, does allowing duplicates to be removed imply anything about ordering? Can non-duplicates change order, for example?",
          "createdAt": "2020-10-01T04:11:58Z",
          "updatedAt": "2020-10-01T04:11:58Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it can apply to any case where the same value appears in the result more than once.\r\n\r\nI've opened a new issue for discussing result sequence.  I think we need to answer that before we can discuss how it affects duplicates.",
          "createdAt": "2020-10-01T05:40:16Z",
          "updatedAt": "2020-10-01T05:40:16Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "To expand on the reason for combining duplicates a little, I offer a more extensive example and a somewhat informal proof of why eliminating duplicates would be a good thing (when not including location in the output):\r\n\r\nThe instance is similar to Goessner's example, but I've added color to the books and moved the other items under a \"toy\" category so that I can search for array items and use an expression.\r\n\r\n```json\r\n{\r\n  \"store\": {\r\n    \"book\": [ \r\n      {\r\n        \"category\": \"reference\",\r\n        \"author\": \"Nigel Rees\",\r\n        \"title\": \"Sayings of the Century\",\r\n        \"price\": 8.95      },\r\n      {\r\n        \"category\": \"fiction\",\r\n        \"author\": \"Evelyn Waugh\",\r\n        \"title\": \"Sword of Honour\",\r\n        \"price\": 12.99,\r\n        \"color\": \"blue\"\r\n      },\r\n      {\r\n        \"category\": \"fiction\",\r\n        \"author\": \"Herman Melville\",\r\n        \"title\": \"Moby Dick\",\r\n        \"isbn\": \"0-553-21311-3\",\r\n        \"price\": 8.99,\r\n        \"color\": \"red\"\r\n      },\r\n      {\r\n        \"category\": \"fiction\",\r\n        \"author\": \"J. R. R. Tolkien\",\r\n        \"title\": \"The Lord of the Rings\",\r\n        \"isbn\": \"0-395-19395-8\",\r\n        \"price\": 22.99,\r\n        \"color\": \"green\"\r\n      }\r\n    ],\r\n    \"bicycle\": [\r\n      {\r\n        \"color\": \"red\",\r\n        \"price\": 19.95\r\n      },\r\n    ],\r\n    \"tricycle\": [\r\n      {\r\n        \"color\": \"blue\",\r\n        \"price\": 9.95\r\n      },\r\n      {\r\n        \"color\": \"red\",\r\n        \"price\": 19.95\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nNow if we want the prices of all the things that are red, we can use `$..[?(@.color == \"red\")].price`.  This results in `[8.99, 19.95, 19.95]` without removal and `[8.99, 19.95]` with removal.\r\n\r\nLet's ignore the `.price` for now to see what how the duplicate values are produced.\r\n\r\nThe path `$..[?(@.color == \"red\")]` returns three objects:\r\n\r\n```json\r\n// $.store.book[2]\r\n{\r\n  \"category\": \"fiction\",\r\n  \"author\": \"Herman Melville\",\r\n  \"title\": \"Moby Dick\",\r\n  \"isbn\": \"0-553-21311-3\",\r\n  \"price\": 8.99,\r\n  \"color\": \"red\"\r\n}\r\n\r\n// $.bicycle[0]\r\n{\r\n  \"color\": \"red\",\r\n  \"price\": 19.95\r\n}\r\n\r\n// $.tricycle[1]\r\n{\r\n  \"color\": \"red\",\r\n  \"price\": 19.95\r\n}\r\n```\r\n\r\nNotice that the results for `$.bicycle[0]` and `$.tricycle[1]` are the same.  Any processing on further path segments will result in the same output.  Therefore we should only need to perform further selection once on these values.\r\n\r\nDuplicate removal resolves this problem.\r\n\r\n---\r\n\r\nEven when we include locations, this can be used as an internal optimization.  An implementation could identify that these are the same object and keep track of all the locations which contain it.",
          "createdAt": "2021-01-05T00:49:08Z",
          "updatedAt": "2021-01-05T05:33:59Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm confused. Why do `$.toy[0]` and `$.toy[2]` in your last example lack the `name` property?",
          "createdAt": "2021-01-05T01:13:03Z",
          "updatedAt": "2021-01-05T01:13:03Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh... Oversight of editing while authoring.  I'll fix it.\r\n\r\nAaand now I have to rework it to get the duplicates again.",
          "createdAt": "2021-01-05T05:29:10Z",
          "updatedAt": "2021-01-05T05:30:35Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@mkmik updated.",
          "createdAt": "2021-01-05T05:34:42Z",
          "updatedAt": "2021-01-05T05:34:42Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> Even when we include locations, this can be used as an internal optimization.\r\n\r\nI think this is trading off performance, in some fairly rare cases, against simplicity of the spec. I'd prefer to keep the spec simpler.",
          "createdAt": "2021-01-05T15:09:56Z",
          "updatedAt": "2021-01-05T15:09:56Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> An option is to allow some latitude in the spec and say that \"duplicates MAY be removed, either by location and value\". \r\n\r\nAllowing latitude defeats interoperability, which I had thought was the raison d'etre for the IETF. But I note there's no mention of interoperability as a design goal in the draft.\r\n\r\nFrom previous discussions, I think it is only necessary to consider removal of duplicates by location (not value.)\r\n\r\n> Should it just apply to unions?\r\n\r\nI don't think so. I think it should apply however duplicates arise, whether unions, wildcards, recursive descent. This also simplifies removal.\r\n\r\n> \"MAY\" will considerably complicate the CTS FWIW, especially if the CTS is purely declarative (e.g. cts.json) as that would put the > onus on each CTS implementation to allow duplicates to be removed if appropriate.\r\n\r\nOr perhaps, either duplicates must be removed, or duplicates must not be removed, or implementations must default to one of these two, and provide an option for the other.\r\n\r\n> Also, does allowing duplicates to be removed imply anything about ordering? Can non-duplicates change order, for example?\r\n\r\nI don't think it affects order at all. Given the data \r\n\r\n```json\r\n{\r\n    \"books\":\r\n    [\r\n        {\r\n            \"title\" : \"A Wild Sheep Chase\",\r\n            \"author\" : \"Haruki Murakami\",\r\n            \"price\" : 22.72\r\n        },\r\n        {\r\n            \"title\" : \"The Night Watch\",\r\n            \"author\" : \"Sergei Lukyanenko\",\r\n            \"price\" : 23.58\r\n        },\r\n        {\r\n            \"title\" : \"The Comedians\",\r\n            \"author\" : \"Graham Greene\",\r\n            \"price\" : 21.99\r\n        },\r\n        {\r\n            \"title\" : \"The Night Watch\",\r\n            \"author\" : \"Phillips, David Atlee\"\r\n        }\r\n    ]\r\n}\r\n```\r\nand selector\r\n```\r\n$.books[1,1,3].title\r\n```\r\nThe results with duplicates are:\r\n\r\nValues|Paths\r\n-------|------------------\r\n \"The Night Watch\" | `$['books'][1]['title']`\r\n \"The Night Watch\" | `$['books'][1]['title']`\r\n \"The Night Watch\" | `$['books'][3]['title']`\r\n\r\nThe results without duplicates are:\r\n\r\nValues  | Paths\r\n---------|------------------\r\n\"The Night Watch\" | `$['books'][1]['title']`\r\n\"The Night Watch\" | `$['books'][3]['title']`\r\n\r\nClearly the second set can easily be obtained from the first without rearranging the items, see [How do you remove duplicates from a list whilst preserving order?](https://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-whilst-preserving-order) Note that implementations have some latitude as to when to remove duplicates. As long as both values and normalized paths are collected, the implementation could delay removal until the last step, before returning results to the user.\r\n\r\n",
          "createdAt": "2021-02-01T04:06:24Z",
          "updatedAt": "2021-02-01T18:14:48Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> To expand on the reason for combining duplicates a little, I offer a more extensive example and a somewhat informal proof of \r\n> why eliminating duplicates would be a good thing (when not including location in the output):\r\n\r\nFollowing up on [gregsdennis](https://github.com/gregsdennis)'s motivation for wanting to remove duplicates, there's a related use case that's applicable when a user wants to modify the original data based on addressing information obtained from a query. Such addressing information could be in the form of normalized paths, or it could be provided by references or pointers into the original data, in languages that support that. In either case, the issue is the same.\r\n\r\nSo suppose that a user queries for a collection of prices for all books in the store, and wishes to discount them all by twenty percent. If duplicates come back, if the same price gets marked down twice, that's going to be a problem. This is not entirely hypothetical, there are jsonpath libraries that are used in this way.\r\n\r\nMore generally, it's hard to think of use cases where duplicates would be beneficial. It's possible to think of use cases where they would be detrimental. For an implementation that collects normalized paths along with values, removal is easy. Of course, removal comes with a cost, and some users may prefer not to pay that cost, particularly as most straightforward queries don't result in duplicates anyway. \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-02-01T05:18:08Z",
          "updatedAt": "2021-02-01T06:40:24Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I know the jury is still out on whether we remove duplicate nodes, but I've prepared draft PRs for the compliance test suite (https://github.com/jsonpath-standard/jsonpath-compliance-test-suite/pull/2) and the reference implementation (https://github.com/jsonpath-standard/jsonpath-reference-implementation/pull/27) to handle removal of duplicate nodes. Any comments gratefully received.",
          "createdAt": "2021-03-26T15:43:15Z",
          "updatedAt": "2021-03-26T15:43:15Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I am preparing an issue (https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88) about unions, where removing duplicate nodes is also a point ",
          "createdAt": "2021-03-26T16:07:57Z",
          "updatedAt": "2021-03-26T16:44:18Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "I have a question about duplicates.\r\n\r\nConsider a root value\r\n```\r\n{\r\n    \"books\": [\r\n        {\"title\": \"A Wild Sheep Chase\"},\r\n        {\"title\": \"The Comedians\"}\r\n    ]\r\n}\r\n```\r\nand suppose that a query returned two values\r\n```\r\n[\r\n    [\r\n        {\"title\": \"A Wild Sheep Chase\"},\r\n        {\"title\": \"The Comedians\"}\r\n    ],\r\n    {\"title\": \"A Wild Sheep Chase\"}\r\n]\r\n```\r\ncorresponding to paths\r\n```\r\n[\r\n    \"$['books']\",\r\n    \"$['books'][0]\"\r\n]\r\n```\r\nWould the node identified by `\"$['books'][0]\"` be considered a duplicate?\r\n",
          "createdAt": "2021-03-27T19:25:32Z",
          "updatedAt": "2021-03-27T19:25:32Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would the node identified by \"$['books'][0]\" be considered a duplicate?\r\n\r\nNo, we only consider duplicates at the top level of the returned nodelist.  So the values to compare are an array and a string.  That the array also happens to _contain_ the string makes no difference.",
          "createdAt": "2021-03-27T22:52:53Z",
          "updatedAt": "2021-03-27T22:52:53Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "Consider:\r\n\r\n```json\r\n{\r\n  \"x\": {\r\n    \"a\": {\r\n      \"a\": {\r\n        \"b\": 1\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nand this jsonpath: `$..a..b`:\r\n\r\nThe first part of the jsonpath `$..a` selects nodes `{\"a\": {\"a\": { \"b\": 1}}}` and `{\"a\": { \"b\": 1}}`\r\n\r\napplying `..b` on that result set, produces the node `1` twice\r\n\r\n",
          "createdAt": "2021-05-11T10:31:59Z",
          "updatedAt": "2021-05-11T10:31:59Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Yes, and we need to agree whether:\r\n\r\n(1) the duplicate nodes are always delivered (which is what we decided today)\r\n\r\n(2) the duplicate nodes are never delivered (which is what we went into the discussion with)\r\n\r\n(3) it depends on the implementation (which IMHO would be a disaster)",
          "createdAt": "2021-05-11T10:34:27Z",
          "updatedAt": "2021-05-11T10:34:27Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "IIRC today we were wondering whether:\r\n\r\n(5) the behavior of the descendent selector may be a special case",
          "createdAt": "2021-05-11T10:59:21Z",
          "updatedAt": "2021-05-11T10:59:21Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Maybe we can record the resolution that there is no removal, neither of duplicate values nor of duplicate nodes.",
          "createdAt": "2021-11-10T10:57:52Z",
          "updatedAt": "2021-11-10T10:57:52Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe we can record the resolution that there is no removal\r\n\r\nI'd be interested in how this resolution came about because it seems like the discussion here was leaning the other way: removing duplicates to some degree.  To _what_ degree was still under discussion.",
          "createdAt": "2021-11-11T05:15:21Z",
          "updatedAt": "2021-11-11T05:15:21Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU3MDg2ODg1NTI=",
      "title": "Whitespace allowances",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/24",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do we allow spaces (outside of string literals)?  If so, where is whitespace allowed?\r\n\r\nI think whitespace in query expressions should be allowed.  This would fall in to the context of the [query expression syntax](https://github.com/jsonpath-standard/internet-draft/issues/17).\r\n\r\n```\r\n$[(@length - 1)]\r\n$[?(@.value < 10)]\r\n```\r\n\r\nMaybe inside the union/[indexer](https://github.com/jsonpath-standard/internet-draft/issues/21) selector:\r\n\r\n```\r\n$[ 1, 2, 5:7, \"prop\" ]\r\n```\r\n\r\nAre there any other places where whitespace could be considered useful?",
      "createdAt": "2020-09-25T06:45:16Z",
      "updatedAt": "2021-11-11T04:56:36Z",
      "closedAt": "2021-11-09T21:09:38Z",
      "comments": [
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may be convenient to allow spaces between matchers - to allow well-readable multi-line queries for complex cases.",
          "createdAt": "2020-09-25T07:26:39Z",
          "updatedAt": "2020-09-25T07:26:39Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like the [current definition of a slice](https://github.com/jsonpath-standard/internet-draft/pull/28) allows whitespace internally, so that ` 1 : 2 : 3 ` (with leading and trailing whitespace) is valid.",
          "createdAt": "2020-10-07T06:49:45Z",
          "updatedAt": "2020-10-07T06:50:13Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed in #131 and #132",
          "createdAt": "2021-11-09T21:09:38Z",
          "updatedAt": "2021-11-09T21:09:38Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "What was the resolution here?  Where did we end up allowing whitespace?",
          "createdAt": "2021-11-11T04:56:36Z",
          "updatedAt": "2021-11-11T04:56:36Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU3MTEyNDYxNDc=",
      "title": "Security items",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/25",
      "state": "OPEN",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Let's use this issue to capture possible items for the Security Considerations section of the spec.\r\n\r\nAs discussed in https://github.com/jsonpath-standard/internet-draft/issues/14, CPU exploits are possible using selectors such as:\r\n```\r\n$[?($)][?($)][?($)][?($)]...\r\n$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==$[?(@==\"b\")])])])])])])])])])]\r\n$[?(@.a || @.b || @.c ...)]\r\n```\r\nOne mitigation would be to run the implementation in an environment, such as a Linux cgroup, which can restrict the CPU consumed.",
      "createdAt": "2020-09-29T15:51:10Z",
      "updatedAt": "2021-03-12T20:47:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@jchesterpivotal provided the following:\r\n\r\n## Regular Expression Denial of Service Attacks (ReDOS)\r\n\r\nA malicious user can submit a JSON object intended to cause explosive backtracking by a JSONPath implementation performing regular expression matching.  This is known as a ReDOS [REDOS] attack.\r\n\r\nTo defend against this attack, regular expressions in JSONPath filters SHOULD conform to RE2 syntax [RE2SYNTAX], which does not support backtracking.  (but MAY not support \"\\C\" - move this to the filter section). Additionally, implementations SHOULD guarantee linear run time for regular expression matching, such as provided by the original RE2 library implementation [RE2IMPL] and Go's \"regexp\" library [GOREG].\r\n\r\n# Informative References\r\n\r\n   [GOREG]    The Go Authors, \"Package regexp\", January 2007,\r\n              <https://golang.org/pkg/regexp/>.\r\n\r\n   [RE2IMPL]  The RE2 Authors, \"RE2\", March 2010,\r\n              <https://github.com/google/re2>.\r\n\r\n   [RE2SYNTAX]\r\n              The RE2 Authors, \"Syntax\", November 2014,\r\n              <https://github.com/google/re2/wiki/Syntax>.\r\n\r\n   [REDOS]    Crosby, SA. and DS. Wallach, \"Denial of Service via\r\n              Algorithmic Complexity Attacks (In \"Proceedings of the\r\n              12th USENIX Security Symposium\")\", August 2003.\r\n\r\n",
          "createdAt": "2020-09-29T15:56:22Z",
          "updatedAt": "2020-09-29T15:57:40Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@jchesterpivotal suggested adding the following to the Security Considerations section:\r\n\r\n## Out of scope attacks\r\n\r\nEavesdropping, replay, message insertion, deletion, modification and man-in-the-middle attacks are considered out of scope for JSONPath. These attacks are relevant to a network protocol, but not to a query language.",
          "createdAt": "2020-09-29T15:58:05Z",
          "updatedAt": "2020-09-29T15:58:05Z"
        },
        {
          "author": "jchesterpivotal",
          "authorAssociation": "NONE",
          "body": "> One mitigation would be to run the implementation in an environment, such as a Linux cgroup, which can restrict the CPU consumed.\r\n\r\nGranted, but I'm not sure this would be in-scope for the RFC.\r\n\r\n",
          "createdAt": "2020-10-02T17:36:19Z",
          "updatedAt": "2020-10-02T17:36:19Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Agreed about specific solutions not being in scope for the RFC.  At most, I think we can identify several potential risks, but:\r\n\r\n1. It should be stated that such a list of risks cannot be comprehensive.\r\n2. Solutions will be specific and relevant according to the implementation, and so should not be included.\r\n\r\nAs an exaample of point 2, an implementation that is designed for applications that run on Windows obviously cannot run in Linux.",
          "createdAt": "2020-10-06T06:13:17Z",
          "updatedAt": "2020-10-06T07:18:41Z"
        },
        {
          "author": "ucarion",
          "authorAssociation": "NONE",
          "body": "Would it be worth giving special consideration to concerns for JavaScript in the security considerations? RFC 8259 does this, and there are similar concerns for this document too.\r\n\r\nFor instance, some na\u00efve implementations of JSONPath in JavaScript could run into trouble with paths that refer to things like `__proto__` or that try to invoke special functions like `toString` (which you can trigger by concatenating any non-string value with a string).\r\n\r\nJavaScript is special here in that it's very popular and there is a very strong conventional representation for JSON data -- whatever `JSON.parse` returns -- and that representation can, if you na\u00efvely fetch its attributes, start returning things that the programmer might not expect to be manipulating.\r\n\r\nIt may be worth talking to seasoned JavaScript security practitioners if we want to make any comment on the perils of walking arbitrary properties of `Object`. I am not such a person.",
          "createdAt": "2020-11-25T19:36:04Z",
          "updatedAt": "2020-11-25T19:36:04Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "It may be worth mentioning that the recursive descent operator is a possible security issue. Na\u00efve implementations that simply recurse down the stack may be vulnerable to attack, and would likely fail suitably designed fuzzer tests. At the least, the specification should require a limit to the depth of recursion.\r\n",
          "createdAt": "2021-03-12T14:58:41Z",
          "updatedAt": "2021-03-12T14:58:41Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "How big of JSON objects are we talking about here? It's not like GraphQL where you can actually have requests for circular data.  JSON is most definitely finite, and surely other mechanisms, such as limits on request size (an application concern), would capture JSON objects large enough to cause recursion issues.\n\nUnless your available call stack is really small, I suppose.  But environmental awareness seems like a concern of either the app or the implementation, not this spec.",
          "createdAt": "2021-03-12T19:40:56Z",
          "updatedAt": "2021-03-12T19:40:56Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> How big of JSON objects are we talking about here? It's not like GraphQL where you can actually have requests for circular data. JSON is most definitely finite, and surely other mechanisms, such as limits on request size (an application concern), would capture JSON objects large enough to cause recursion issues.\r\n> \r\n> Unless your available call stack is really small, I suppose. But environmental awareness seems like a concern of either the app or the implementation, not this spec.\r\n\r\nWe're talking about attack files that are specifically generated to exploit vulnerabilities. That's what fuzz testing is about, bombarding your function calls with simulated attack files on a continuous basis, to detect whether your API is vulnerable to malicious attackers.  Recursive algorithms are a big source of security vulnerabilities. \r\n\r\nDaniel",
          "createdAt": "2021-03-12T20:47:09Z",
          "updatedAt": "2021-03-12T20:47:09Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3MTE2NDI5NjQ=",
      "title": "Support returning the location of each value returned",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/26",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In addition to the value, it may be important to know where the value came from.  Goessner also mentions potential support for this at the end of his posts.\n\nA first guess at a candidate for the format of this location might be JSON Path itself.  After all, the logic for evaluating it is already provided in the core functionality on the implementation.  However, JSON Path is intended for querying documents and returning multiple matches, not pinpointing a single value.\n\nI think that [JSON Pointer](https://tools.ietf.org/html/rfc6901) is a better mechanism for this.  It is intended to isolate a single value within a document, which is what we want.  It also has an extremely simple syntax, so implementing it shouldn't be hard.  It's also likely there are already implementations in a given language that can be used.",
      "createdAt": "2020-09-30T05:27:57Z",
      "updatedAt": "2020-12-04T22:42:44Z",
      "closedAt": "2020-12-04T22:42:44Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "More discussion on this has occurred in #44.  Closing this as a duplicate.",
          "createdAt": "2020-12-04T22:42:44Z",
          "updatedAt": "2020-12-04T22:42:44Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU3MTI1MDI1NDQ=",
      "title": "Sequence of results",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/27",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "processing-model"
      ],
      "body": "A [comment](https://github.com/jsonpath-standard/internet-draft/issues/23#issuecomment-701871710) on the duplicates issue brought up the ordering of values in the result output.  This does relate directly to whether we remove duplicates in that if we define that sequence matters _and_ duplicates are removed, which copies of duplicated values are kept?\r\n\r\nBefore we can answer that, I think we need to define whether the sequence of the results matter.  This has implications for users of the Compliance Test Suite (CTS) as that it lists the expected results.\r\n\r\nIf we decide that output sequence is important, then an implementation using the CTS would need to ensure that the actual result (from the implementation) and the expected result (from the CTS) must be sequence-equal.  This is fairly straightforward and easy to process.\r\n\r\nHowever if we decide that output sequence does _not_ matter, implementations would need to check for contents-equal.  This is more complex to implement (but not impossible).\r\n\r\nOnce we have defined this, we can go back to #23 and address whether to remove duplicates and, if so, which duplicates to remove.",
      "createdAt": "2020-10-01T05:35:17Z",
      "updatedAt": "2021-11-10T10:47:13Z",
      "closedAt": "2021-11-10T10:47:13Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed by #134 \r\n",
          "createdAt": "2021-11-10T10:47:13Z",
          "updatedAt": "2021-11-10T10:47:13Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU3MTk0NzIxMDk=",
      "title": "Define behaviour for very large array indices and slice components",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/29",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, there is no limit to the integer values which may be specified as array indices or as components (start, end, or step) of an array slice. The spec needs to define what behaviour is acceptable when very large positive or negative values are used.\r\n\r\nFor example, suppose a value such as 2^65 or -2^65 is used. May the implementation reject that with a (syntax or \"find\") error, should it clamp the value to the range of a signed 64 bit integer (*) before proceeding, or should this be handled some other way?\r\n\r\n*: this may be too onerous for some implementations, but a signed 32 bit limit could conceivably be too draconian.\r\n\r\nAs @mkmik points out, JSON does not have sparse arrays, so such large values are unlikely to index valid elements. They simply (!) need to be handled in a consistent and helpful way.\r\n\r\nThis was prompted by a [discussion](https://github.com/jsonpath-standard/jsonpath-reference-implementation/pull/22#issuecomment-705771250) with @gregsdennis.",
      "createdAt": "2020-10-12T15:33:06Z",
      "updatedAt": "2020-11-04T15:29:20Z",
      "closedAt": "2020-11-04T15:29:20Z",
      "comments": [
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "a notable language that lacks native 64-bit integers is JavaScript:\r\n\r\n```\r\nWelcome to Node.js v14.10.1.\r\nType \".help\" for more information.\r\n> x=1024*1024*1024\r\n1073741824\r\n> x*x\r\n1152921504606847000\r\n```\r\nwhich is `24` off from the correct value which is `1152921504606846976`. This is because in JS numbers are implemented as 64-bit floats. There are ways around it, using BitNumber etc, but implementors need to deal with it and in some cases it might impact the API of the library.",
          "createdAt": "2020-10-12T16:47:48Z",
          "updatedAt": "2020-10-12T16:47:48Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "For reference, here's how [JSON Schema](http://json-schema.org/draft/2019-09/json-schema-core.html#rfc.section.6.2) puts it.\n\n> JSON Schema is programming language agnostic, and supports the full range of values described in the data model. Be aware, however, that some languages and JSON parsers may not be able to represent in memory the full range of values describable by JSON.\n\nFairly straightforward, and it relieves implementations from being _required_ to support some features due to limitations put forth by their framework. \n\nI like having this called out in this way out because it also leaves the door open for frameworks that _can_ handle these features.  If you clamp the values, then those bignum tests will need to be removed altogether rather than just marked optional.   Or worse, they'd need to remain and be marked as \"invalid path\" (or similar).",
          "createdAt": "2020-10-12T18:54:16Z",
          "updatedAt": "2020-10-13T03:27:44Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> For reference, here's how [JSON Schema](http://json-schema.org/draft/2019-09/json-schema-core.html#rfc.section.6.2) puts it.\r\n> \r\n> > JSON Schema is programming language agnostic, and supports the full range of values described in the data model. Be aware, however, that some languages and JSON parsers may not be able to represent in memory the full range of values describable by JSON.\r\n> \r\n> Fairly straightforward, and it relieves implementations from being _required_ to support some features due to limitations put forth by their framework.\r\n\r\nIt's straightforward, but it's insufficient as it doesn't define any particular behaviour. In our case, I would like to define the behaviour, e.g. to reject a selector containing an overly large index with either a syntax error or an error from \"find\". \r\n\r\n> \r\n> I like having this called out in this way out because it also leaves the door open for frameworks that _can_ handle these features. If you clamp the values, then those bignum tests will need to be removed altogether rather than just marked optional. Or worse, they'd need to remain and be marked as \"invalid path\" (or similar).\r\n\r\n",
          "createdAt": "2020-10-15T11:25:15Z",
          "updatedAt": "2020-10-15T11:25:15Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "I'm not sure what \"find\" is.\r\n\r\nI'm happy for the spec to say what the behavior is, but leave the limit up to the implementation.",
          "createdAt": "2020-10-16T12:59:04Z",
          "updatedAt": "2020-10-16T12:59:04Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure what \"find\" is.\r\n\r\nI just meant running the selector, rather than parsing it.\r\n\r\n> \r\n> I'm happy for the spec to say what the behavior is, but leave the limit up to the implementation.\r\n\r\nGreat.\r\n\r\n",
          "createdAt": "2020-10-19T10:08:22Z",
          "updatedAt": "2020-10-19T10:08:22Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this was addressed by PR 31.",
          "createdAt": "2020-11-04T15:29:20Z",
          "updatedAt": "2020-11-04T15:29:20Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU3MzA1MTE0NTE=",
      "title": "Scrap or apply RFC 2119 language",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/37",
      "state": "OPEN",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "task"
      ],
      "body": "The RFC 2119 language MUST be adopted throughout the normative text. Alternative, we should scrap the use of that language like [RFC 3986](https://tools.ietf.org/html/rfc3986) did, for example.\r\n\r\nSee this thread too: https://mailarchive.ietf.org/arch/msg/jsonpath/IG5p0laTlF_l95P7lsTpQcI3B88/.",
      "createdAt": "2020-10-27T14:37:03Z",
      "updatedAt": "2021-03-03T17:55:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Like soy sauce, BCP 14 (RFC2119+RFC8174) language is an essential addition, but only works well if applied sparingly.   I believe this is a continuing task during editing of this document.",
          "createdAt": "2021-03-03T17:55:29Z",
          "updatedAt": "2021-03-03T17:55:29Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU3NDQwMTI2Mzk=",
      "title": "Convert to markdown",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/39",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The idea is to make the source document markdown for ease of editing and PR reviewing. Then we can use kramdown (see http://rfc.space and http://slides.rfc.space) to convert the markdown to xml2rfc format and proceed as usual.\r\n\r\nThis will pave the way for merging in introductory text from G\u00f6ssner's article and the internet draft based on it.",
      "createdAt": "2020-11-16T17:13:52Z",
      "updatedAt": "2020-11-18T11:45:26Z",
      "closedAt": "2020-11-18T11:45:26Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "I like this. When the PR goes up, can you include a proof of concept for the conversation?",
          "createdAt": "2020-11-16T18:55:24Z",
          "updatedAt": "2020-11-16T18:55:24Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I like this. When the PR goes up, can you include a proof of concept for the conversation?\r\n\r\nI'm glad you like it, but I'm not sure what kind of proof of concept you would like including. I intend to update the README and scripts to use kramdown, but maybe you have something else in mind. Please could you expand.",
          "createdAt": "2020-11-17T07:53:21Z",
          "updatedAt": "2020-11-17T07:53:21Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU3NTcwMTg1NTE=",
      "title": "Including value locations in output",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/44",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There are really two questions here:\r\n\r\n### Is this something we want to support?\r\n\r\nIt was proposed by Goessner's original post and supported by his libraries.  That alone is a good argument, but additionally, it's already supported by a large number of implementations in other langauges.\r\n\r\nConversely, we may want to postpone inclusion of this for simplicity's sake.\r\n\r\n### What is the format we should use?\r\n\r\nGoessner's original post (2007) described using JSONPath itself as the format used to indicate the position.  The issue with using JSONPath is that it's a query syntax, and while it _can_ isolate a single value, it's not specifically designed to.\r\n\r\n[JSON Pointer](https://tools.ietf.org/html/rfc6901#section-7) (2013), however, _was_ designed to isolate a single value within a JSON structure.  It has other advantages as well:\r\n\r\n- It's a simple syntax.\r\n- It's already in a formal specification.\r\n- It's widely supported.\r\n\r\nFurthermore, it's non-competitive with JSONPath because of its different intended purpose: isolating single values vs JSONPath's querying for potentially multiple values.",
      "createdAt": "2020-12-04T11:11:15Z",
      "updatedAt": "2021-03-09T00:39:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Yes, we want to support this.\r\n\r\nWe probably want to be able to support both applications that need a JSON Pointer and those that need a (basic) JSONPath query.\r\n\r\nOne detail that we have to keep in mind is that it is easy to convert a (basic) JSONPath into a JSON Pointer, but not the other way around: interpreting a JSON Pointer needs to have the JSON value around so a path component can be disambiguated between a number (array index) and a string (map key).  These look the same in JSON Pointer but different in JSONPath.\r\n\r\nSo it seems to me that we want to return JSONPath queries and not JSON Pointers, as the latter can easily be created from the former.\r\n",
          "createdAt": "2020-12-04T12:35:48Z",
          "updatedAt": "2020-12-04T12:35:48Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "stating the conversion problem explicitly: the JSONPointer: `/a/0` finds `\"x\"` in both following documents:\r\n\r\n```\r\n{ \"a\": [\"x\"] }\r\n```\r\n\r\n```\r\n{ \"a\": { \"0\": \"x\" } }\r\n```\r\n\r\nand we don't want this JSONPath `$.a[0]` to also locate `\"x\"` in both documents (that is, we don't want\r\nJSONPath to _stringify_ the `0` numeric literal into a `\"0\"` string literal, if applied to an object)?",
          "createdAt": "2020-12-04T13:43:00Z",
          "updatedAt": "2020-12-04T13:43:00Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Exactly.\r\n\r\nI don't know whether there are JSONPath implementations where `$.a[\"0\"]` would return `[\"x\"]` for your document 1, or `$.a[0]` for your document 2, but I think we want to keep these clearly separated for JSONPath, even if they aren't in JavaScript.",
          "createdAt": "2020-12-04T15:14:39Z",
          "updatedAt": "2020-12-04T15:14:39Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough. I'm surprising myself about how easily I can wear the hat of somebody with no strong opinions on the semantics.\r\nThat said, I do have opinions on how should we approach the specification, including the scope.\r\n\r\nThe main reason for me to consider specifying JSONPath evaluation output in terms of pointers to values lies in its ability to clearly reason about query result duplicates.\r\n\r\nThe actual format of the results seems to me more of an implementation detail, in the same way we're not going to specify whether the result is a linked list of values or an array of values. Implementations should be free of emitting JSONPath or JSONPointer outputs. But the specification could choose JSONPointer as the clearest means to an end: showing what it means to produce a result that points to values in the input document.\r\n",
          "createdAt": "2020-12-04T17:52:02Z",
          "updatedAt": "2020-12-04T17:52:02Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> @cabo - We probably want to be able to support both...\r\n\r\n> @mkmik - Implementations should be free of emitting JSONPath or JSONPointer outputs.\r\n\r\nAs a specification, we need to be prescriptive, choosing a single format.  Our client is the consuming application, and requiring them to expect one of potentially multiple output formats is not ideal.  An implementation is free to go above and beyond the specification and support both, but we definitely shouldn't:\r\n\r\n- _require_ support of both or\r\n- give the option to support either\r\n\r\nas this adds burden to the consuming application.\r\n\r\n---\r\n\r\n> @cabo - interpreting a JSON Pointer needs to have the JSON value around...\r\n\r\nThis is true for whichever location identifier syntax we choose.  Remember, this is in the output result of a JSONPath evaluating _an instance_.  Without the instance, the location loses all context, and whether a `0` represents an integer index or a string property name becomes moot.  You _always_ need the instance to intepret the location, whether it's expressed in JSON Pointer or JSONPath.\r\n\r\n> @mkmik - and we don't want this JSONPath $.a[0] to also locate \"x\" in both documents (that is, we don't want\r\nJSONPath to stringify the 0 numeric literal into a \"0\" string literal, if applied to an object)?\r\n\r\nAs above, this location identifier is intrinsicly linked to the instance that was evaluated.\r\n\r\nWhen a JSONPath is evaluated against instance **A**, it produces a set of location identifiers that are specific to that evaluation.  If we then evaluate the same path against instance **B**, a different set of location identifiers are produced.  The location identifiers produced by the evaluation of **A** are not relevant at all to **B**.\r\n\r\nIt doesn't make sense to talk about a numeric segment being interpreted an index or a key with different instances because the location identifier that contains that segment is tied to the instance that produced it.\r\n\r\n---\r\n\r\nSo ultimately the choice comes down to the following:\r\n\r\n- Using JSONPath as the location identifier means that the logic to evaluate it is the same as the logic which produced it (which is convenient).  However evaluating the location identifier against the instance produces a single-value array, which _suggests_ that multiple values _could_ result.  (It also feels odd that this evaluation of the output path against the instance again produces the output path.)\r\n- Using JSON Pointer is more semantically appropriate since it only produces a single value.  However it does require support of another syntax (though that support will ideally be provided by a separate implementation, of which there are many in multiple languages).\r\n\r\n> @mkmik - But the specification could choose JSONPointer as the clearest means to an end: showing what it means to produce a result that points to values in the input document.\r\n\r\n\u261d\ufe0f sounds like a vote for JSON Pointer to me.  This is my vote as well. ",
          "createdAt": "2020-12-04T21:26:33Z",
          "updatedAt": "2020-12-05T05:34:41Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "Just to note, a common reason for users to want paths as an option is to perform diagnostics related to a query that returned values. For such users, JSONPath paths are needed, not something else. \r\n\r\nAlso of note, Goessner refers to these paths as \"normalized path expressions\", presumably intending them to be unique and identifying a single value. It is required that they use the bracket as opposed to the dot notation, but that is not enough, more restrictions are needed. It would be helpful if the specification preserved the term \"normalized path expression\" and formally defined it.",
          "createdAt": "2020-12-11T01:40:11Z",
          "updatedAt": "2020-12-11T01:40:11Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> It would be helpful if the specification preserved the term \"normalized path expression\" and formally defined it.\r\n\r\nAs in 71077ad?",
          "createdAt": "2020-12-11T05:15:33Z",
          "updatedAt": "2020-12-11T05:15:33Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> For such users, JSONPath paths are needed, not something else.\n\nIt'd be great if we could get an example of a case where a path would be required and a pointer would be insufficient.",
          "createdAt": "2020-12-11T10:01:50Z",
          "updatedAt": "2020-12-11T10:01:50Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Greg, any \"normalized JSONPath expression\" can be translated into a JSON pointer.  If you have the instance handy, it can even be translated back (more effort). To me it seems:\r\n\r\n* it is easy to make a JSON Pointer out of a normalized JSONPath query.\r\n* the inverse is not so easy without following along in the argument.\r\n* JSON pointers are great, but somewhat foreign in the JSONPath universe.\r\n\r\nTo me, it seems to be unnecessary to drag in a different universe.  JSONPath is sufficient, and the conversion towards JSON Pointer is a really small matter of programming (that still could be a recommended component of a JSONPath library).",
          "createdAt": "2020-12-11T10:27:56Z",
          "updatedAt": "2020-12-11T10:27:56Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "> It'd be great if we could get an example of a case where a path would be required and a pointer would be insufficient.\r\n\r\nOne random example I can think of: when all the user has is a JSONPath evaluator, and she wants to re-evaluate the output path against the input document without downloading a new library",
          "createdAt": "2020-12-11T10:47:16Z",
          "updatedAt": "2020-12-11T10:47:16Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> To me, it seems to be unnecessary to drag in a different universe. JSONPath is sufficient, and the conversion towards JSON \r\n> Pointer is a really small matter of programming (that still could be a recommended component of a JSONPath library).\r\n\r\nI agree with this comment.\r\n\r\n",
          "createdAt": "2020-12-11T15:44:59Z",
          "updatedAt": "2020-12-11T15:44:59Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> It'd be great if we could get an example of a case where a path would be required and a pointer would be insufficient.\r\n\r\nIt would be interesting to survey some users and find out what they're doing with the normalized path expressions. My impression is that some of them are performing diagnostics, and if you're trying to understand the output of a JSONPath query, I think you'd want to see JSONPath normalized path expressions rather than JSONPointer's, I don't think you'd want to start seeing slashes and tildes. But it would be better to ask users.\r\n\r\n",
          "createdAt": "2020-12-11T16:11:02Z",
          "updatedAt": "2020-12-11T16:46:07Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> > It would be helpful if the specification preserved the term \"normalized path expression\" and formally defined it.\r\n> \r\n> As in [71077ad](https://github.com/jsonpath-standard/internet-draft/commit/71077adfcb409a15ab19ceb895e8fcc7a508e0bd)?\r\n\r\nYes! But in addition to stating what a \"normalized path expression\" is _for_ (identifies exactly one Position in  an Argument), it should define what it _is_, perhaps, a JSONPath expression with the restriction that it uses the bracket notation exclusively (no dot notation, no recursive descent notation, no filters, no function), no wildcards, no slices. I think those restrictions are enough to imply uniqueness.\r\n\r\nIn addition, the specification should describe how a list of normalized path expressions can be generated given a JSONPath expression and a JSON instance.\r\n",
          "createdAt": "2020-12-11T16:38:54Z",
          "updatedAt": "2020-12-12T15:05:04Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "Just a note on the limitations of normalized path expressions as the output of a JSONPath query. Implementations that support functions, and some important ones do, cannot produce normalized path expressions as output if functions are applied to paths. \r\n\r\nFor example, take [Jayway JSONPath](https://github.com/json-path/JsonPath#functions), which supports functions that can be invoked at the tail end of a path, with input\r\n```\r\n[0,1,2]\r\n``` \r\nand path\r\n```\r\n$.avg()\r\n```\r\nWith \"matching values\" option, the result is\r\n```\r\n1.0\r\n```\r\nBut with \"normalized path expressions\" option, a diagnostic is issued\r\n```\r\nOptions AS_PATH_LIST and ALWAYS_RETURN_LIST are not allowed when using path functions!\r\n```",
          "createdAt": "2020-12-11T17:05:40Z",
          "updatedAt": "2020-12-11T17:06:39Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "On Fri, 2020-12-11 at 07:45 -0800, Daniel Parker wrote:\n> > To me, it seems to be unnecessary to drag in a different universe.\n> > JSONPath is sufficient, and the conversion towards JSON\n> > Pointer is a really small matter of programming (that still could\n> > be a recommended component of a JSONPath library).\n> I agree with this comment.\n\n+1\n\n\n\n",
          "createdAt": "2020-12-16T11:47:18Z",
          "updatedAt": "2020-12-16T11:47:18Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> On Fri, 2020-12-11 at 07:45 -0800, Daniel Parker wrote:\r\n> > To me, it seems to be unnecessary to drag in a different universe.\r\n> > JSONPath is sufficient, and the conversion towards JSON\r\n> > Pointer is a really small matter of programming (that still could\r\n> > be a recommended component of a JSONPath library).\r\n> I agree with this comment.\r\n\r\n> +1\r\n\r\n+1\r\n\r\n\r\n",
          "createdAt": "2021-03-08T18:10:11Z",
          "updatedAt": "2021-03-08T18:10:11Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "On Mon, 8 Mar 2021, 18:10 Stefan Goessner, <notifications@github.com> wrote:\n\n> On Fri, 2020-12-11 at 07:45 -0800, Daniel Parker wrote:\n>\n> To me, it seems to be unnecessary to drag in a different universe.\n> JSONPath is sufficient, and the conversion towards JSON\n> Pointer is a really small matter of programming (that still could\n> be a recommended component of a JSONPath library).\n> I agree with this comment.\n>\n> +1\n>\n> +1\n>\n+1. Let's minimise (a) the dependencies and (b) the total surface area\n(including dependencies) of the spec.\n\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/44#issuecomment-792961292>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2MKFIG6SS4ZUB57VVLTCUHJJANCNFSM4UNJN5EQ>\n> .\n>\n",
          "createdAt": "2021-03-08T19:01:30Z",
          "updatedAt": "2021-03-08T19:01:30Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Okay... So I think it's clear that JSON Pointer is not desired for this (even though it's already mentioned in the spec to declare that Path is not an alternative for it).\n\nThe main point of this issue was too determine if we want locations included in the output.  Let's keep focused on that, please.",
          "createdAt": "2021-03-09T00:39:10Z",
          "updatedAt": "2021-03-09T00:39:10Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU3NjEzODM3Nzg=",
      "title": "Filter applied to JSON object: to support, or not to support?",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/47",
      "state": "CLOSED",
      "author": "danielaparker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Should JSONPath filters apply to both JSON objects and arrays, or only to JSON arrays? \r\n\r\nIn [JSONPath Comparison](https://cburgmer.github.io/json-path-comparison/results/filter_expression_on_object.html) , where the JSONPath expression \r\n\r\n    $[?(@.key)]\r\n\r\n is applied to the JSON instance \r\n\r\n    {\"key\": 42, \"another\": {\"key\": 1}}\r\n\r\nthere is no consensus. Thirteen implementations produce\r\n\r\n    [ { \"key\": 1}]   (*)\r\n\r\nNine (including the important Jayway) produce\r\n\r\n    [ { \"another\": { \"key\":1}, \"key\": 42 }]   (**)\r\n\r\nTwo (including JavaScript Goessner) produce\r\n\r\n    [ 42, { \"key\": 1 }]   (***)\r\n\r\nThe remaining 17 (including PHP Goessner) produce variously `[]`, \"syntax error\", \"not supported\", or runtime error.\r\n\r\nResults (`*`), (`**`) and (`***`) have implications for what the symbol `@` for the \"current item\" must mean.\r\n\r\nFor (`*`),  the value part of each name-value pair is evaluated in succession, and the value part being evaluated is represented by the symbol `@`.\r\n\r\nFor (`**`) , the JSON object that the filter is applied to is evaluated, the JSON object _is_ the current item, and there is no other. There can be only one current object, and it is either selected or not.\r\n\r\nI can't make any sense of (`***`).\r\n\r\nIntuitively, if I had a huge JSON object, I might want to filter out a subset of name-value pairs, and box them in a smaller JSON object, but none of the implementations support that notion.",
      "createdAt": "2020-12-10T16:22:19Z",
      "updatedAt": "2021-04-28T18:49:34Z",
      "closedAt": "2021-04-28T18:49:34Z",
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer not to support (usefully) applying filters to JSON objects. For consistency with other cases, such as arraying indexing or slicing applied to a JSON object, I think the result should be an empty list of values rather than an error.\r\n\r\nMy reasoning is to try to keep JSONPath intuitive. The above variation in behaviour between the various implementations seems to be evidence that there isn't an intuitively obvious specification for this behaviour.",
          "createdAt": "2020-12-16T11:14:33Z",
          "updatedAt": "2020-12-16T11:14:33Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wouldn't mind including objects, but I'd definitely prefer option 1 (`*`).  I can see value in having it.\n\nI think the wording I'd use for this in the specification would be \"SHOULD NOT evaluate objects\" so that is obvious the specification recommends against it, but still leaves it open for implementations to support it.\n\nI'd probably go so far as to include something like \"such functionality MUST be behind an option that defaults to 'not supported.'\"  (See similar wording for JSON Schema's [`format` keyword in draft 2020-12](https://datatracker.ietf.org/doc/draft-bhutton-json-schema-validation/?include_text=1), section 7.2.1, paragraph 2.)",
          "createdAt": "2020-12-17T02:35:19Z",
          "updatedAt": "2020-12-17T02:35:46Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU3Nzg0ODYzODQ=",
      "title": "Proposal - Selecting a subset of an object's properties",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/49",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "There's no syntax for selecting multiple individual properties from a single object.  You either have to select a single property or the entire object.\r\n\r\nI would like to propose a \"union\" or \"subselection\" syntax `(x,y,...)` where `x`, etc. are the properties to be returned.  The return value will be an object omitting all properties that are not included in the union declaration.\r\n\r\nUsing Goessner's example, I could use the path `$.store.book[*].(title,price)` to select only the title and price of all of the books.  It would return\r\n\r\n```json\r\n[\r\n  { \"title\": \"Sayings of the Century\", \"price\": 8.95 },\r\n  { \"title\": \"Sword of Honour\", \"price\": 12.99 },\r\n  { \"title\": \"Moby Dick\", \"price\": 8.99 },\r\n  { \"title\": \"The Lord of the Rings\", \"price\": 22.99 },\r\n]\r\n```\r\n\r\n***NOTE** I understand the name conflicts with current usage of \"union\", but that be resolved by [changing that usage](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/21).  I'm struggling to come up with another name.",
      "createdAt": "2021-01-05T01:02:02Z",
      "updatedAt": "2021-03-28T02:57:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cburgmer",
          "authorAssociation": "NONE",
          "body": "I like to thing of there being at least two different problems many people try solving in this space: That of selecting values, and that of transforming the original JSON structure. I understand JSONPath to solve the former, but to be really bad at the latter (by choice).\r\nSelecting a subset for me is clearly a transformation problem, as I can already use `$[\"a\", \"b\"]` to select the necessary values.\r\nSo my personal stance is to not get into that.",
          "createdAt": "2021-01-05T10:17:23Z",
          "updatedAt": "2021-01-05T10:17:23Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cburgmer what's the support for something like `$[\"a\",\"b\"]`?  I'm not sure I've seen that anywhere.",
          "createdAt": "2021-01-05T12:34:15Z",
          "updatedAt": "2021-01-05T12:34:15Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "fwiw I'm also in the camp of \"jsonpath selects and doesn't transform\"",
          "createdAt": "2021-01-05T14:23:42Z",
          "updatedAt": "2021-01-05T14:42:46Z"
        },
        {
          "author": "cburgmer",
          "authorAssociation": "NONE",
          "body": "> @cburgmer what's the support for something like `$[\"a\",\"b\"]`? I'm not sure I've seen that anywhere.\r\n\r\nI'm talking about the union operator with two keys: https://cburgmer.github.io/json-path-comparison/results/union_with_keys.html. You will get the values, but not the keys. \r\n\r\nJava's com.jayway.jsonpath interestingly enough decides to return the object with the keys, contrary to the rest of the implementations (and Objective-C's SMJJSONPath which according to it's goal just follows com.jayway.jsonpath verbatim).",
          "createdAt": "2021-01-05T18:21:33Z",
          "updatedAt": "2021-01-05T18:21:33Z"
        },
        {
          "author": "cburgmer",
          "authorAssociation": "NONE",
          "body": "For further reference, Ruby's jsonpath has a \"parens notation\" (https://cburgmer.github.io/json-path-comparison/results/parens_notation.html) to select a subset: `$(key,more)`. Other implementations might have found their own syntax for supporting something like that, this is the only one I came across though.",
          "createdAt": "2021-01-05T20:04:29Z",
          "updatedAt": "2021-01-05T20:04:29Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting proposal regarding the syntax. \r\n\r\nI am also in the camp of \"jsonpath selects and doesn't transform\" (I've even been the first one :)\r\n\r\nThe example above could be rewritten to `$.store.book[?(@.title && @.price)]`, which returns a list of output pathes\r\n```js\r\n[ \"$['store']['book'][0]\",\r\n  \"$['store']['book'][1]\",\r\n  \"$['store']['book'][2]\",\r\n  \"$['store']['book'][3]\"\r\n]\r\n```\r\nthat can be used then to do any post-processing ... here transform to property-reduced books.\r\n\r\nNo violation of the minimalism priciple this way!\r\n\r\nProposed syntax `(<expr1>,<expr2>,...)` might be used to separate a brackets child selector from that, what is still called 'union' at current.",
          "createdAt": "2021-03-08T17:35:20Z",
          "updatedAt": "2021-03-08T17:35:20Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU3Nzg3MTEzNTk=",
      "title": "Test issue to check slack integration - please ignore",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/50",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-05T08:08:37Z",
      "updatedAt": "2021-01-05T08:08:56Z",
      "closedAt": "2021-01-05T08:08:55Z",
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Works ok.",
          "createdAt": "2021-01-05T08:08:55Z",
          "updatedAt": "2021-01-05T08:08:55Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU3OTU2MDc4MjA=",
      "title": "Should hyphens be allowed in unquoted names?",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/52",
      "state": "CLOSED",
      "author": "danielaparker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Duplicate #16",
      "createdAt": "2021-01-28T02:20:30Z",
      "updatedAt": "2021-01-28T03:20:30Z",
      "closedAt": "2021-01-28T03:02:59Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "This is a duplicate of #16.  I make the same argument and list language support for hyphens in identifiers.",
          "createdAt": "2021-01-28T02:55:58Z",
          "updatedAt": "2021-01-28T02:58:11Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> This is a duplicate of #16. I make the same argument and list language support for hyphens in identifiers.\r\n\r\nMy apologies! I overlooked that. I'll close this one, and make any further comments under that one. ",
          "createdAt": "2021-01-28T03:02:59Z",
          "updatedAt": "2021-01-28T03:02:59Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU3OTcxOTU2MTA=",
      "title": "Hello Issue",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/53",
      "state": "OPEN",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cabo"
      ],
      "labels": [],
      "body": "After a longer abstinence from JSONPath, I decided to jump in again and contribute to the design of the internet draft. First, I am much impressed by the work already done here, at Christoph Burgmer's great test suite and elsewhere.\r\n\r\nOver all the years I liked and still do like JSON's redundancy free minimalistic approach. Let's try to design JSONPath in a similar way.\r\n\r\nThis first input is more an overview of things that catch my eye, while reading through the draft. Points to discuss should go into already existing or new separate issues then ... \r\n\r\n### Normative vs. Informative\r\n\r\nI consider chapters 1.1 - 1.2 and 3. as normative (possibly with some informative parts) and important. The rest is informative or currently not written. Maybe that should better be mixed in or go to an example section as in JSON RFC 7159.\r\n\r\n### Terminology\r\n\r\nTerminology is essential. I started a table comparing terms used in  JSONPath, XPath, CSS Selectors and JSON Pointer.\r\n\r\n#### Table 1: Terminology compared\r\n\r\n|  | JSONPath | XPath | CSS Selectors| JSON Pointer  |\r\n| --- | --- | --- | --- |--- |\r\n| What is it? | string syntax for identifying values within a JSON document | a language for addressing parts of an XML document | patterns that match against elements in a tree  | string syntax for identifying a specific value within a JSON document \r\n| primary purpose |  `selection`,<br>`addressing`  | `selection`,<br>`addressing`,<br>`matching`,<br>`manipulating` | `matching` |`identifying` |\r\n| document root |  `JSON value`,<br>`JSON structure`,<br>`input document`,<br>`root node`  | `context node` | `document root` | `root value` |\r\n| models root as ... |  tree of nodes  | tree of nodes | tree of elements | JSON document? |\r\n| primary syntactic construct | `JSONPath`,<br>`expression`,<br>`selector`,<br>`query` | `expression`,<br>`location path` | `selector` | `JSON Pointer` |\r\n| minimal selector unit | `selector` | `location step` | `simple selector` | `reference token` |\r\n| minimal target | `node`,<br>`value` | `node`,<br>`value` | `element` |  `referenced value` |\r\n| expression evaluates to | `list of nodes` | `node-set` | `elements` | `JSON value` |\r\n| what to do on errors | return empty node list ? | errors specified ... but no according behavior  | rule using selector is dropped | not defined by specification |\r\n\r\nI see this as a living table, which is editable and able to grow over time. I think, we should try to agree on few essential terms.\r\n\r\nChapters 1.1 and 3.2 deal with Terminology. Maybe we could merge them.\r\n\r\n### Review\r\n\r\nWhen reading through issues and mailing list here, sometimes something came to my mind, which I want to add here as a remark.\r\n\r\n* JSONPath was originally meant for pure selection, with \"the right tool for the right job\" in mind. Transformation or analysis of the resulting node list should be done by corresponding other tools taking as input the node-list as normalized path expressions. So no functions on the final node-set are necessary.\r\n\r\n* I like the formal concept, where each selection step gets a node-list as input and produces a possibly empty node-list as output.\r\n\r\n* Simple JSONPath expressions ideally could be evaluated by pure Javascript `eval` function (letting security aside) originally. So the dot child selector would expect names according to syntax rules for JavaScript variables only, so allowing `'_'` but no `'-'` characters. We can relax this rule here, but I think, that *variable syntax rule* is easy to learn and remember. Otherwise we can always use the bracket-notation.\r\n\r\n* I was adding the union selector simply because XPath had one.\r\n\r\n* Script expressions `?(...)` and `(...)` were meant as a hack in my original implementation and documentation. And thus a security nightmare of course. But leaving the term `script` aside, similar subexpression are supported by XPath and CSS selectors &ndash; kind of salt in the soup. By the way, I like [David Chester's approach](https://github.com/dchester/jsonpath#differences-from-original-implementation) of evaluating script expressions. Discussion is needed here for sure.\r\n\r\n* A minor thing is: Duplicates are removed by XPath. JSONPath won't by its original philosophy, as it simply doesn't analyse and modify results.\r\n\r\nI will raise more individual issues in future and/or contribute to existing ones.\r\n\r\nIf there are already solutions / agreements, which I am not aware of, I apologize.\r\n\r\n---\r\nthanks\r\n",
      "createdAt": "2021-01-29T20:52:11Z",
      "updatedAt": "2021-03-11T19:03:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "It may be helpful to add [JMESPath](https://jmespath.org/) to the table. JMESPath is a query language for JSON that's supported in both the AWS and Azure CLI and has libraries available in a number of languages. It has a [formal specification](https://jmespath.org/specification.html) with [compliance tests](https://github.com/jmespath/jmespath.test/tree/master/tests). I would suggest\r\n\r\n&nbsp;|JMESPath\r\n----|-----------\r\nWhat is it?|A query language for JSON\r\nprimary purpose|selection,matching,manipulating\r\ndocument root|JSON value\r\nmodels root as ...|JSON value\r\nprimary syntactic construct|expression\r\nminimal selector unit|index-expression,identifier,sub-expression\r\nminimal target|JSON value\r\nexpression evaluates to|JSON value\r\nwhat to do on errors|Raise syntax, wrong type, and arity errors detected during evaluation",
          "createdAt": "2021-01-31T22:59:12Z",
          "updatedAt": "2021-02-01T05:31:15Z"
        },
        {
          "author": "fiestajetsam",
          "authorAssociation": "MEMBER",
          "body": "As discussed at 110, @cabo is assigned to create a PR but if anyone else wants to jump in first that is okay too.",
          "createdAt": "2021-03-10T13:09:18Z",
          "updatedAt": "2021-03-10T13:09:18Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "What exactly should the PR do here?",
          "createdAt": "2021-03-11T11:35:12Z",
          "updatedAt": "2021-03-11T11:35:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Check consistency of terminology, I'd say",
          "createdAt": "2021-03-11T11:35:54Z",
          "updatedAt": "2021-03-11T11:35:54Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "We could even add a form of this table, possibly in an appendix like the XPath comparison\r\n",
          "createdAt": "2021-03-11T11:36:19Z",
          "updatedAt": "2021-03-11T11:36:19Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this was my issue initially, I can do that. But wouldn't terminology fit better in new issue #66 ? ",
          "createdAt": "2021-03-11T11:46:11Z",
          "updatedAt": "2021-03-11T11:46:11Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Probably one PR should cover #53 and #66\r\n(Actually, there is little to be done, except maybe adding that appendix.\r\nThe important part is checking for consistency.)\r\n",
          "createdAt": "2021-03-11T11:47:56Z",
          "updatedAt": "2021-03-11T11:47:56Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "We had a pretty good discussion at the meeting about node and item and why it's good to have both terms even if they actually mean the same\r\n",
          "createdAt": "2021-03-11T11:48:36Z",
          "updatedAt": "2021-03-11T11:48:36Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "ok, I can melt the tables and put it into some appendix.\r\n\r\nMaybe we should wait with terms until having intensively discussed union stuff.",
          "createdAt": "2021-03-11T11:59:52Z",
          "updatedAt": "2021-03-11T11:59:52Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> We had a pretty good discussion at the meeting about node and item and why it's good to have both terms even if they actually mean the same - @cabo\n\nCan we get a written summary of the reasoning discussed, please? ",
          "createdAt": "2021-03-11T19:03:01Z",
          "updatedAt": "2021-03-11T19:03:01Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU4MTc4Njg4NDE=",
      "title": "IETF Fwd: Some Comments ...",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/54",
      "state": "CLOSED",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "documentation",
        "duplicate"
      ],
      "body": "Hello List,\r\n\r\nIt has been important to go through this list threads carefully. In fact I should have done that at first. Now I can understand the current draft and appreciate the work already done much better.\r\n\r\nI collected some citations (important from my point of view) with comments already in Markdown.\r\n\r\n\r\n## Title of the specification\r\n\r\n> JSONPath: A query language for JSON data.\r\n*(Carsten Bormann)*\r\n\r\n> I think I\u2019d slightly prefer the term \u201csyntax\u201d to \u201clanguage\u201d because \u201cquery language\u201d has a smell of various things that end with the letters \u201cQ\u201d and \u201cL\u201d.  But not passionate about that.\r\n*(Tim Bray)*\r\n\r\n> JSONPath: A query syntax for JSON.\r\n> Another wild-card idea: JSONPath: Query expressions for jSON\r\n*(Tim Bray)*\r\n\r\n> The beauty of this is that the plural form \u201cquery expressions\u201d implies a set of expressions, so it implies \u201clanguage\u201d.  It\u2019s indeed more than the grammar/syntax of those, so why not talk about the expressions as a whole.  This also makes it possible to just use \u201cfor JSON\u201d, without going into detail what these query expressions operate on.\r\n*(Carsten Bormann)*\r\n\r\nThere seems to be an agreement for \"*JSONPath: Query expressions for JSON*\". I like that also.\r\n\r\n## Terminology\r\n\r\n> My own view is that the terminology should stay consistent with RFC\r\n8259, and that the word \"object\" should not be used for items that are\r\nnot JSON objects in the sense of RFC 8259.\r\n*(Daniel P)*\r\n\r\n> To Carsten's point about what we call things, the number of distinguished\r\nterms per RFC8259 is pretty small: JSON text, value, object, array, number,\r\nstring.  Having spent quite a bit of time specifying JSON DSLs, I find that\r\nusing just those terms doesn't seem to get in the way or cause problems, so\r\nI'd argue that we should stick to them (and build up to higher-level\r\nconstructs as required for JSONPath).\r\n>\r\n> \u2026 oh, and I forgot the very useful \"member\".\r\n*(Tim Bray)*\r\n\r\n> \u2026 and \u201celement\u201d (the things in arrays). *(Carsten Bormann)*\r\n\r\n> The problem with JSON value is that it also can be quite confusing due to the usual use of that term.  Pointing to a tree and saying \u201cthe values inside that tree\u201d is not going to be felt as equivalent to \u201cthe set of all subtrees of that tree, including the tree itself\u201d.  But if JSON value is the only term we have, it has to be.  Hence my preference to talk about data items when I mean the items themselves and not their \u201cvalue\u201d.\r\n*(Carsten Bormann)*\r\n\r\n> I think the key difficulty is whether each (key, value) pair in an object is \"a thing\" that can be identified and manipulated and potentially returned. (If we're talking analogies, then it's analogous to an attribute node in the XDM model).\r\n*(Michael Kay)*\r\n\r\n> ECMA-404 uses \"name/value pair\", which is what I understand the term\r\n\"member\" to mean (Douglas Crockford uses \"member\").\r\n*(Daniel P)*\r\n\r\n> I think the term \u201cunion\u201d is poor. If we think of it as concatenation of results, then the result is as expected.\r\n*(Glyn Normington)*\r\n\r\nI understand, that within RFC8259 we have JSON values of different types. They are structured somehow, which is not so much of interest here.\r\n\r\nBut while querying that structure with JSONPath it is vitally important to identify that hierarchical structure as a tree. So in fact we build up a higher-level construct here. We also need to call \"the things\" in the tree somehow. I was able to identify\r\n\r\n* \"node\" or \"item\" of a tree\r\n* \"member\" of an object\r\n* \"name/value\" or \"key/value\" pair alias \"member\"\r\n* \"element\" of an array\r\n\r\nbut could not see an agreement here.\r\n\r\nI agree to Glyn calling the term \"union\" poor (s. below).\r\n\r\n\r\n## Differentiation from JSON Pointer (JSONPath draft charter)\r\n\r\n> I anticipate being asked \"Why is JSON Pointer not sufficient?\" Indeed its abstract says:\r\n>\r\n>   JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.\r\n>\r\n>... which sounds awfully similar.  If we could include a sentence about\r\nthat, or a link to an answer, that might be helpful.\r\n*(Murray S. Kucherawy)*\r\n\r\n> No - it's not similar in concept, they're separate things. If you really wanted to mention JSON Pointer, you could say something like \"Note that while JSON Pointer (RFC xxxx) is already standardised, it is designed to provide a reference to a single, specific part of a JSON document, whereas JSONPath provides the ability to query a document and potentially return multiple values.\"\r\n*(Mark Nottingham)*\r\n\r\n>The short answer is that JSON pointer is good if you already know the structure of the JSON data item you want to point into, and you want to point to exactly one position in there.  If you need to do something that is closer to a \u201csearch\u201d (which might also result in multiple positions), JSONPath gives you more rope.\r\n*(Carsten Bormann)*\r\n\r\n+1\r\n\r\n## References to XPath\r\n\r\n> I wonder if the analogies between XPath and JSONPath are going to be helpful, or whether they're actually dangerous by implying equivalences between constructs that are in fact somewhat different?\r\n*(Michael Kay)*\r\n\r\n> I tend to agree. Although JSONPath was inspired by XPath, I wouldn't\r\nwant to confuse the JSONPath spec by going into detailed comparisons at\r\nthe risk of contradicting the normative text.\r\n*(Glyn Normington)*\r\n\r\n> Someone on StackOverflow today asked a question about JSONPath; they called it (and tagged it) XPath, we really don't want that kind of confusion.\r\n>\r\n> In addition, the reference to the XPath specification in 6.2 is out of date, and the comparison with XPath in Table 2 is very approximate and the terminology inaccurate: for example there is a mention of \"node sets\", which exist in XPath 1.0 but not in XPath 2.0, yet the citation is to XPath 2.0. For someone who knows the semantics of XPath the comparison raises all sorts of questions about sorting of results into document order, elimination of duplicates etc, which are complications this spec can well do without. (Though some answers are needed, for example if ..store..price matches the same price in more than one way, do you get more than one result? And if not, what does \"the same price\" actually mean?)\r\n*(Michael Kay)*\r\n\r\nIt seemed to be important in 2007, while argumenting to have something like XPath for JSON. If nowadays the terminology used has changed significantly with XPath 2.0 and 3.0, we better leave that comparison table 2 out. I am quite passionless here.\r\n\r\n## Array Slice Operator\r\n\r\n> Thanks! The ABNF for an array slice in that reference\r\n> ```\r\n> integer = [%x2D] (%x30 / (%x31-39 *%x30-39))\r\n>\r\n> array-slice = [ integer ] ws %x3A ws [ integer ]\r\n>                     [ ws %x3A ws [ integer ] ]\r\n>                              ; start:end or start:end:step\r\n> ```\r\n> is consistent with JMESPath, Python, and my understanding of\r\nECMASCRIPT 4.\r\n> *(Daniel P)*\r\n\r\n> Did anyone else have an opinion on the behaviour of slices such as [::0]?\r\nThe current draft allows this and says it returns an empty array, but there\r\nis good reason to say it should error so that the slice operation is then\r\nconsistent with Python slicing. See below for more context.\r\n*(Glyn Normington)*\r\n\r\nIt's good having read this thread and thus understand the current draft much better. I like the decision to be consistent with Python and also getting an empty selection set with `step=0`.\r\n\r\nFYI: there is a recent proposal for adding slice notation syntax to JavaScript, currently at stage 1 of the TC39 process.\r\n\r\nhttps://github.com/tc39/proposal-slice-notation\r\n\r\nInterestingly it won't have a step argument ...\r\n\r\nhttps://github.com/tc39/proposal-slice-notation#why-doesnt-this-include-a-step-argument-like-python-does\r\n\r\n... because of syntax collision with the new `this-binding` syntax proposal `::`\r\n\r\nhttps://github.com/tc39/proposal-bind-operator\r\n\r\nHowever, we should not let us influence by this.\r\n\r\n## Unions\r\n\r\n> I don't think any implementation would remove duplicates from a path\r\nsuch as `\"$.store.book\"`. I believe this is only somewhat controversial\r\nin the context of unions [,]. The name \"union\" suggests that distinct\r\nvalues be returned, compare with SQL unions. But Stefan Goessner's\r\nimplementation doesn't do that, it concatenates all results that meet\r\neach criteria. There are a few JSONPath implementations that produce\r\nreal unions with no duplicates instead of concatenated results, but I\r\ndon't think that's the consensus.\r\n*(Daniel P)*\r\n\r\n> I think the term \u201cunion\u201d is poor. If we think of it as concatenation of results, then the result is as expected.\r\n*(Glyn Normington)*\r\n\r\n> I agree with that comment, but it's partly because I'm used to SQL UNION,\r\nwhich is different. I prefer the JMESPath term for an analogous construct,\r\nMultiSelect List, https://jmespath.org/specification.html#multiselect-list.\r\n*(Daniel P)*\r\n\r\nIntroducing the union operator `[,]` simply was meant an analogon to XPath's operator `'|'`. I cannot tell, if it was a simple combination of node sets in Xpath 1.0 or a true union without duplicates. I obviously was not aware of that subtle (essential ?) union characteristic.\r\n\r\nSo I fully agree to Glyn Normington's '... the term \u201cunion\u201d is poor' statement. Are there some better alternative terms, perhaps 'multi-index operator', 'index list', 'subscript list', etc.?\r\n\r\n## Duplicates and Ordering\r\n\r\n> It was my impression that we were talking about duplicated nodes not\r\nduplicated values:\r\n>\r\n> Given th array [10,20,30]\r\n>\r\n> $..[0,1,0]\r\n>\r\n> Would yield only two results [10, 20]\r\n>\r\n> (Not that I'm advocating for removing duplicates, personally I think we\r\nshouldn't)\r\n*(Marko Mikulicic)*\r\n\r\n> You\u2019re framing this as \u201cremoving duplicates\u201d.\r\nAnother view is that [10, 20, 10] would be \u201cadding duplicates\u201d (copies of the same node). Related are ordering issues:\r\n>\r\n> `$..[1,0] \u2794 [20, 10] Or [10, 20]`\r\n>\r\n> I would expect the spec will leaves implementations some leeway here, but that should be based on an examination of existing implementations.\r\n*(Carsten Bormann)*\r\n\r\n> The mental model that leads to omitting duplicate nodes in the output is\r\n\"selection\": if you take an input array and select nodes with index 0,1 or\r\n0, you get only 2 results (since selecting an index twice has no effect).\r\n>\r\n>OTOH, if you opt for a \"collect\" model, whenever you encounter a node that\r\nmatches that query you add it to the result stream, thus the same nodes can\r\nbe present multiple times in the result.\r\n>\r\n>I have a slight preference for the \"collect\" model, because the general\r\ncase in jsonpath is to collect things that appear at various points in the\r\njson tree. For example:\r\n>\r\n>`{\"a\": {\"b\": 1, \"c\": 2}, \"d\": 3},  $.a.b yields [1] and not {\"a\":{\"b\":1}}`\r\n>\r\n>(i.e. jsonpath is not a filter and view operation but a pick and gather\r\noperation)\r\n*(Marko Mikulicic)*\r\n\r\n> In implementations that support paths (the majority don't), the query\r\nfunction takes a parameter that indicates values or paths. In both\r\ncases the query returns a JSON array of JSON values, in the latter\r\ncase, a JSON array of normalized paths.\r\n*(Daniel P)*\r\n\r\nI must confess to never having thought about duplicates, let alone wanting to eliminate them. So I do like Marko's comparison of 'selection-model' vs. 'collection-model' a lot. I would opt for the latter. In this sense the result of a 'JSONPath query expression' should be termed a 'collection'.\r\n\r\nRegarding ordering I see something like a 'natural ordering', according to which\r\n\r\n`$..[0,1] \u2794 [10, 20]`\r\n`$..[1,0] \u2794 [20, 10]`\r\n\r\nwould result with the example above.\r\n\r\nI do understand the use cases for reordering, duplicates removal, filtering, etc.. But this can always be seen as a postprocessing step on the resulting collection by handing it over to accompanying tools (think of pipe operator).\r\n\r\nOf course this cannot work on the result collection of values alone (s. duplicate nodes vs. duplicate values above), it rather requires a collection of (normalized) pathes. In this sense, I like this view:\r\n\r\n> In my opinion the right balance between powerfulness and enabling\r\nsimple implementations has been so far one of the key factors that\r\nmade JSONPath popular over other alternatives, even if it lacks\r\nsupport for aggregation functions.\r\n*(Davide Bettio)*\r\n\r\n## Filter Expressions\r\n\r\n> Related to that, it would be helpful to determine if JSONPath filters\r\napply to both JSON objects and arrays, or only to JSON arrays.\r\n*(Daniel P)*\r\n\r\n> I would support restricting filters to arrays, if others agree.\r\n*(Glyn Normington)*\r\n\r\nI tend to let implementations and their \"normative force of the factual\" decide here or in doubt agree to Glyn's restriction to arrays.\r\n\r\nI am very unhappy with confusing `$..book[(@.length-1)]`, where `'@'` addresses the array itself and implies that array has a `length` property. In filter expression examples `'@'` more consistently addresses the current array element.\r\n\r\nThe invocation of 'the underlying scripting engine' wasn't meant a serious normative aspect, but rather a quick and dirty solution for JavaScript and PHP implementations at that time.\r\n\r\n\r\n### Corner Case\r\n\r\n> Consider this perfectly legal JSON object\r\n>\r\n> ```{ \"ab\": 0,  \"'a.b\": 1,  \"a-b\": 2, \"a\": { \"b\": 3 } }```\r\n>\r\n>So `$.ab` is 0, `$.a.b` is 3, `$['a.b']` is 1, `$['a-b']` is 2. You'd like to say `$.a-b` but lots of libraries will refuse it because `\"a-b\"` is not a legal JavaScript \"name\" construct, that's why you have to say `$['a-b']`.\r\n>\r\n> But suppose your library would accept `$.a-b`.  Then `$.a-b` and `$['a-b']` would be synonyms, but `$.a.b` and `$['a.b']` wouldn't.\r\n*(Tim Bray)*\r\n\r\nHmm ... this seems to be a hint to better exclude `'-'` from dot-child-selector syntax. I think I have read more discussion about that, currently don't know where.\r\n\r\n## Respect Implementations\r\n\r\n> As I mentioned in the session, I think there's a non-trivial amount of risk here that some implementations won't be willing or able to move away from their current behaviours, even if interoperability would improve if they did so. However, there are ways to mitigate that (e.g., a separate 'rfcxxxx compliant' mode). Even so, it will be important to get good participation from as many current implementers as possible.\r\n*(Mark Nottingham)*\r\n\r\n> The WG will develop a standards-track JSONPath specification that\r\nis technically sound and complete, based on the common semantics\r\nand other aspects of existing implementations.  Where there are\r\ndifferences, the working group will analyze those differences and\r\nmake choices that rough consensus considers technically best, with\r\nan aim toward minimizing disruption among the different JSONPath\r\nimplementations.\r\n*(Barry Leiba)*\r\n\r\n> I'm OK with this, but for context: I've been a pretty intense JSONPath user\r\nin recent years, and AFAIK the spec, and the implementations, are mostly\r\nOK, so the choice between \"make JSONPath good\" and \"don't invalidate\r\nimplementations\" is unlikely to come up. If it did, my predisposition would\r\nbe to err on the side of not breaking implementations, but I don't think\r\nthat's inconsistent with Barry's text.\r\n*(Tim Bray)*\r\n\r\n+1 to all.\r\n\r\n## Error Handling\r\n\r\n> My mental model at the moment is that a JSONPath expression can be valid or erroneous; application of a valid expression yields a result (which may be empty), but does not raise errors.  That may not be the right model for all applications.\r\n*(Carsten Bormann)*\r\n\r\n> The  general approach that I've seen several times (including my\r\nElixir implementation) is that an error is raised when there is a\r\nsyntax error, therefore an invalid expression (e.g. $.foo[[5]) raises\r\nan error. Conversely a valid expression applied to a bogus input never\r\nraises an error (e.g. `$.foo.bar on \"test\" evals as []`).\r\n*(Davide Bettio)*\r\n\r\n> On the whole I think JSONPath is designed to be \"forgiving\", i.e. such things aren't errors, e.g. I think I read in the spec that filtering a non-array isn't an error, it's some kind of no-op. That approach isn't always best for everyone, but it's important to be consistent.\r\n*(Michael Kay)*\r\n\r\n> I would expect one component of this policy to be:\r\n>\r\n> Whether a JSONPath query is valid or not does not depend on the arguments it is applied to.\r\n>\r\n> I.e., you can look at the query and find out independently, without knowing any data, whether it is valid or not.\r\n*(Carsten Bormann)*\r\n\r\nI like and totally agree with the *forgiving mental model*, so having  only syntax errors, which do not dependent on data.\r\n\r\nThanks\r\n\r\n-- \r\nsg ",
      "createdAt": "2021-02-27T08:39:06Z",
      "updatedAt": "2021-03-10T18:26:47Z",
      "closedAt": "2021-03-10T18:26:47Z",
      "comments": [
        {
          "author": "fiestajetsam",
          "authorAssociation": "MEMBER",
          "body": "I have created new issues based on the agreed actions during the IETF 110 meeting - just to clarify those which are not already new issues:\r\n\r\n* **Unions** - This should be taken to the mailing new as a new subject to get consensus, as a replacement term might be more appropriate\r\n* **Duplicates and Ordering** - This has overlap with the work around the processing model and can largely be covered there.\r\n\r\nThis issue can be closed now, however please comment if there is any issue.",
          "createdAt": "2021-03-10T18:26:44Z",
          "updatedAt": "2021-03-10T18:26:44Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU4MjEzMzkyNzM=",
      "title": "WoT discovery, geolocation, and JSON pointers",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/55",
      "state": "OPEN",
      "author": "mmccool",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the [W3C Web of Things](https://www.w3.org/WoT/), we have been working on a new standard for Discovery (which looks up metadata about IoT devices encoded in JSON-LD files) that includes JSON Path as one query mechanism.  We are therefore very happy to see this effort to standardize JSON Path, as it will make it much much easier to reference (and keep consistent) in a W3C Recommendation (our alternative would be to make up our own JSON Path spec, which we obviously want to avoid at all costs).   For general information on WoT Discovery, please see the [w3c/wot-discovery repo](https://github.com/w3c/wot-discovery) and in particular the [Editor's Draft](https://w3c.github.io/wot-discovery) of our spec.  I should mention we also plan to support XPath and SPARQL as optional alternative query languages but would like to make JSON Path the basic requirement for all implementations.\r\n\r\nWe will likely follow up with other issues later related to the use of JSON Path WoT Discovery more generally later; however lately we have also been discussing geolocation and the use of JSON Pointers to define the location of this information in order to deal with various use cases like devices installed in a static location, devices using other devices for their location, devices with dynamic updates of location (vehicles, etc).  Ultimately we would like to have a set of \"geolocation filters\" in WoT Discovery that lets us filter query results by location.  These can be independent of JSON Path; however, we first have to collect the geolocation information together with a JSON Path query, and that (at least) requires the following:\r\n\r\n* The ability to follow \"relative\" JSON pointers (i.e. URLS with just the fragment part) within a document and collect the information.\r\n\r\nSee my [geolocation proposal](https://github.com/mmccool/wot-discovery/blob/geolocation-proposal/proposals/geolocation.md) for a writeup and some examples.   Note there are ALSO examples of JSON pointers referring to data schemas and to external files in that proposal, both of which would require an additional dereferencing step, and it would be OK to NOT support these in JSON Path (or rather, leave it up to the consumer to follow these external references themselves, so unresolved JSON Pointers could be included in the result in these cases).\r\n\r\nIf the above is confusing, I apologize, but let's discuss and hopefully I can clarify.",
      "createdAt": "2021-03-03T17:46:04Z",
      "updatedAt": "2021-03-05T10:56:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> The ability to follow \"relative\" JSON pointers (i.e. URLS with just the fragment part)\n\nI think some clarification needs to be made here.\n\n**All** JSON Pointers are fully contained within the fragment of a URL.  Generally, it's the entire fragment.\n\nHowever, there is a thing called a [Relative JSON Pointer](https://tools.ietf.org/id/draft-handrews-relative-json-pointer-00.html), which builds upon the base spec.  It prefixes the standard Pointer with a positive integer. This number is the number of parent levels to move up from the current location before dereferencing the rest of the pointer.\n\nThis spec doesn't intend to use the relative ones, only the base pointer definition, if anything.",
          "createdAt": "2021-03-05T06:30:46Z",
          "updatedAt": "2021-03-05T10:56:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I think Michael was talking about using JSON pointers in relative URIs.\r\n(We used handrews style \"relative JSON pointers\" in an early version of SDF and got rid of them as they were way too confusing.)",
          "createdAt": "2021-03-05T06:41:12Z",
          "updatedAt": "2021-03-05T06:41:12Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "MDU6SXNzdWU4MjM2NDAyNjI=",
      "title": "Some observations on the 3 March 2021 draft",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/56",
      "state": "CLOSED",
      "author": "danielaparker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "### \"dot-child-name\" and \"child\"\r\n\r\nThe grammar defines a \"dot-child-name\" as an unquoted string in the dot notation, and a \"child\" as a quoted string in the bracket notation.\r\n\r\nTo my tastes, I find \"dot-child-name\" and \"child\" awkward when they appear in the body of the text, and would prefer \"unquoted-string\" (or \"identifier\", see below) and \"quoted-string\". Particularly as section 3.6.2.3 begins with \"A child is a quoted string.\" If it's a quoted string, why not call it a \"quoted-string\"? Generally I find that in other grammars, authors take care to use token names that are intuitive, and natural to use in the body of the text. I'd like to see that more in the JSONPath specification as well.\r\n\r\nOn a related point, the grammar _defines_ a \"dot-child-name\" as an unquoted string. However, thanks to Burgmer's excellent comparisons, we know that a majority of implementations support [dot notation with single quotes](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_single_quotes.html), and a significant minority also support [dot notation with double quotes](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_double_quotes.html). It seems to me that it would therefore be natural to define\r\n```\r\nidentifier = unquoted-string / quoted-string \r\n\r\nquoted-string = single-quoted-string / double-quoted-string\r\n\r\nunion-element = quoted-string\r\n\r\nselector = dot-child      \r\n    \r\ndot-child = \".\" identifier\r\n```\r\n\r\nIn section 3.6.1, when discussing the dot notation, the term \"Union Child\" is used, referring to section 3.6.2.3, but this section does not define \"Union Child\", it defines \"child\". In my opinion, terms used in the body of the text should always be consistent with the tokens in the grammar, including with respect to case.\r\n\r\n### Normalized path expressions\r\n\r\nThe draft states, in section 1.3,\r\n\r\n\"Where a JSONPath processor uses JSONPath expressions as output paths, these will always be converted to normalized JSONPath expressions which employ the more general bracket-notation. [2] Bracket notation is more general than dot notation and can serve as a canonical form when a JSONPath processor uses JSONPath expressions as output paths.\"\r\n\r\n### Remarks:\r\n\r\n- Is the notation \"[2]\" intended to be a reference? If so, to what does it refer? \r\n- This paragraph uses the term \"normalized JSONPath expressions\", and is the only place in the draft where this exact expression occurs. \"Normalized Path Expression\" is used in Section 1.1.\r\n- The draft refers to this section in Section 1.1 when introducing the term \"Normalized Path Expression\", but the above text cannot be considered a definition. Intuitively what is required is a path in the bracket notation with only non-negative indices and single quoted names allowed, both those restrictions are required for canonical form.\r\n\r\n### Wildcard with bracket notation\r\n\r\nThe draft gives examples of using a wildcard with the bracket notation, e.g. `$.store.book[*].author`, but it's not covered in the grammar.\r\n\r\nOne approach would be to treat it symmetrically as a union element, i.e.\r\n\r\n    union-element =/ \"[\" \"*\" \"]\"\r\n\r\nNote that a query like\r\n\r\n    $.store.book[*,*]\r\n\r\ndoesn't make much sense, but it does no harm, and some implementations support that, e.g. Goessner. \r\n\r\n### Filters\r\n\r\nFilters are largely unmentioned in the current draft, apart from examples. \r\n\r\nIs it intended to also support filters and expressions as \"union elements\"?\r\n\r\nReferring to https://cburgmer.github.io/json-path-comparison/results/union_with_filter.html,\r\nsix out of 41 implementations support union with filter elements. \r\n\r\n### node\r\n\r\nIt's unclear what the draft means by \"node\", which occurs 60 times in the text. In section 3.2, it says \"Each node holds a JSON value\", but it doesn't say what else the node holds (a position or path to that point?) And then we have \"root node which is the input document\", which suggests the root node is a value. My own understanding of a node is a path/value pair, and I think the draft needs to be more clear about this term, and to distinguish between root and current nodes, and the corresponding root and current values.\r\n\r\n### Data Item\r\n\r\nSection 1.1 defines the term \"Data Item\" as follows:\r\n\r\n\"A structure complying to the generic data model of JSON, i.e., composed of containers, namely JSON objects and arrays, and of atomic data, namely null, true, false, numbers, and text strings. Also called a JSON value.\"\r\n\r\nBut if \"Data Item\" means the same as \"JSON value\", why introduce it at all? I note that the term \"JSON value\" occurs 13 times in the draft; \"Data Item\" occurs 15 times. I think there is some risk, in a document with multiple authors and multiple critics, that people have different preferred terms, and that as a compromise, all terms get used. But this is not helpful to implementers, for implementers, one term is best. \r\n\r\n### Position\r\n\r\nIn section 1.1, which introduces terminology, the draft defines Position as follows:\r\n\r\n\"A JSON data item identical to or nested within the JSON data item to which the query is applied to, expressed either by the value of that data item or by providing a Normalized Path Expression as a JSONPath Output Path.\"\r\n\r\n#### Remarks\r\n\r\n- The expression \"the JSON data item to which the query is applied to\" is awkward, and could be substituted with \"root\", which is a term used 11 times in the draft from Section 1.3 on. I would suggest introducing \"root\" in the terminology section, and using it.\r\n- I don't understand what this sentence means. What does it mean to say that \"Position\" _is_ the root or a nested data item and _can_ be expressed by the value of that data item (as well as by a Normalized Path Expression)? Intuitively, my understanding of \"Position\" is that it is the location of an item within the root, and can be represented by a Normalized Path Expression.\r\n\r\n### General observation\r\n\r\nIf I compare the draft to the [JMESPath specification](https://jmespath.org/specification.html), one thing that stands out is that in the JMESPath specification, every definition is expressed in terms of tokens that are defined in the grammar, and the names in the grammar correspond to intuition. This makes the JMESPath specification very clear. But that's not always the case in the draft. For example, the text about Normalized Path Expression uses terms such as \"bracket notation\" that are not found in the grammar, and the grammar uses names like \"child\" that cannot be easily understood if used bare without more context.\r\n\r\nI think it would be helpful if the draft consistently described things in terms of tokens that are defined in the grammar, and that the names in the grammar are natural ones to use in the text. On that note, I would suggest that \"child\" is not a natural way to refer to a quoted string in brackets.\r\n\r\nMy own view is that describing Normalized Path Expression in terms of \"union\", \"union element\" and \"child\" would be awkward, which suggests to me that additional tokens might be introduced into the grammar to represent bracketed expressions with a single item.\r\n\r\n\r\n\r\n",
      "createdAt": "2021-03-06T12:47:40Z",
      "updatedAt": "2021-03-27T22:04:59Z",
      "closedAt": "2021-03-27T22:04:59Z",
      "comments": []
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU4MjM2OTc0ODM=",
      "title": "JSONPath expression and bracket-notation",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/57",
      "state": "OPEN",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I was thinking a while about `[(...)]` expressions (we may need another term here: 'evaluatable' or something) and filter expressions `[?(...)]` (or simply 'filters'?).\r\n\r\nIn order to discuss bracket-notation inside of JSONPath expressions &ndash; leaving out unions for now, we can address implicitly either JSON objects by using a string indicating a member name ...\r\n\r\n```js\r\n$..['name']  // (1) ... array elements can't be selected this way ...\r\n             //     Prefer using single quotes, so allow JSONPath \r\n             //     expressions being JSON text strings, defined \r\n             //     in [RFC8259]. \r\n```\r\nor JSON arrays by using an integer as array index.\r\n\r\n```js\r\n$..[42]  // (2) ... object members can't be selected this way ...\r\n```\r\nI'm not sure, how strict or forgiving implementations handle `$..['42']` here ... I assume the latter.\r\n\r\n\r\n### `$..[(#)]`\r\n\r\nNow, when applying `$..[(#)]`, then abstract `'#'` should evaluate to a string in case of (1) and to an integer in case of (2), if it wants to have a chance to select anything.\r\n\r\nNow consider the root selector `'$'` being part of the evaluatable in question ...\r\n\r\n```js\r\n{ \"key\":\"name\", \"o\": {\"name\":\"x\"} }\r\n\r\n$..[($.key)]  // ... \"x\"\r\n```\r\nand ...\r\n```js\r\n{ \"idx\": 2, \"a\": [\"v\",\"w\",\"x\"] }\r\n\r\n$..[($.idx)]  // ... \"x\"\r\n```\r\nJSON documents containing such a level of indirection may be treated well by JSONPath this way. It's hard for me to imagine other use cases, since both expression must resolve to string and integer, in order to make sense.\r\n\r\nThis time consider the current element/node indicator `'@'` being used ...\r\n\r\n```js\r\n{ \"o\": {\"key\":\"name\", \"name\":\"x\"} }\r\n\r\n$..[(@.key)]  // ... \"x\"\r\n```\r\nand ...\r\n```js\r\n{ \"a\": [2,\"v\",\"w\",\"x\"] }\r\n\r\n$..[(@[0])]  // ... \"x\"\r\n```\r\nAgain both expression must resolve to string and integer respectively. So current item `'@'` needs to reference its container, i.e. object `'o'` and array `'a'` in the examples above. The benefit is significantly less here in contrast to the use of the root selector `'$'`. Again we can perform some kind of 'pointing' from one location to another in a single JSON document. But this time an object member is addressed more restrictively from its direct descendant or from its sibling or thats descendant. \r\n\r\nMy former example `$..book[(@.length-1)]` addresses via `'@'` the array `book`\r\nand implies that it has a member with name `length`. This is true for JavaScript, but does not apply generally and thus makes it a bad example.\r\n\r\nDaniel largely agrees with the uselessness of this case in his post \"@ and the current element\" on the list https://mailarchive.ietf.org/arch/browse/jsonpath/, but he and others may have some other practical uses in mind ... ?\r\n\r\n### `$..[#]`\r\n\r\nDaniel is pointing to another variant of expression evaluating `$..[@.address.city]` on [stackoverflow](https://stackoverflow.com/questions/55497833/jsonpath-union-of-multiple-different-paths/55505099#55505099). Basically\r\n\r\n```js\r\n{ \"a\":{\"b\":{\"c\":\"x\"} } }\r\n\r\n$..[@.b.c]  // ... \"x\", which yields identical results to\r\n$..b.c \r\n```\r\nthat use is questionable, as there exists another more intuitive JSONPath query delivering the same result, as shown in the example. Interesting is the idea, that the expression inside the brackets is evaluated, as if it were outside. Current item `'@'` here references its container as in `$..[(#)]` expressions above. A benefit (?) of that might come in combination with unions, which we won't discuss here (but possibly in another later issue).\r\n\r\n### `$..[?(#)]`\r\n\r\nJSONPath filters seem to be of most practical use. It allows to perform tests while iterating over a JSON container (object or array). If the boolean test results in `true`, the object member or array element is selected, thus filtering data items out. In tests the symbols `'$'` and `'@'` may be used, meaning the *root node* and *current node* (is *node* a valid term in the draft?), as in ...\r\n\r\n```js\r\n{ \"find\":\"red\",\r\n   \"a\": [\"yellow\",\"green\",\"red\"],\r\n   \"o\": { \"size\":12, \"color\":\"red\"}\r\n}\r\n\r\n$.a[?(@ == $.find)]      // ... \"red\"\r\n$.o[?(@ == 'red')]       // ... no match, '@' holds a 'name/value' pair.\r\n$.o[?(@.color == 'red')] // ... member \"color\":\"red\".\r\n```\r\nIt's important to note, that symbol `'@'` herein does not reference the JSON container as before with `[(...)]` expressions, but the members or elements contained, while iterating.\r\n\r\nInterestingly there is good agreement with arrays, but obviously confusion regarding objects among the implementations. See enlightening issue [#47](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/47) for discussion.\r\n\r\n### Conclusion\r\n\r\nWorkgroup members seem to be very reluctant regarding those evaluatable expressions (see [Glyn's comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/47#issuecomment-746125759)). One reason might be security considerations [#25](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/25). I find [Greg's comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/47#issuecomment-747165396) remarkable, where he proposes two of the following options:\r\n\r\n1. not supporting evaluatable expressions at all.\r\n2. only support filters (for now?).\r\n3. only support filters on arrays (for now?).\r\n4. ... \"SHOULD NOT evaluate objects\" and leave it to implementations.\r\n5. ... \"MUST be behind an option that defaults to 'not supported.'\"\r\n\r\nI think, whatever option we will choose &ndash; my favorite would be 2. possibly combined with 4. and/or 5. &ndash; there should be a clear definition, how `'@'` symbol is to be interpreted, when used by implementations. I'm not sure, if this requires an explicit grammar and if so, how detailed it has to be then.\r\n\r\nI'm also not sure, if it's possible, to announce addition of those stuff to later versions of the draft (like [TC39](https://github.com/tc39/proposals) handles proposals).\r\n",
      "createdAt": "2021-03-06T17:10:15Z",
      "updatedAt": "2021-03-09T18:09:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner wrote\r\n\r\n> I'm not sure, how strict or forgiving implementations handle `$..['42']` here ... I assume the latter.\r\n> \r\nThere is no need to guess, [the answer](https://cburgmer.github.io/json-path-comparison/results/bracket_notation_with_quoted_number_on_object.html) is in Christoph Burgmer's comparisons. The answer is \"forgiving\".\r\n\r\nDaniel",
          "createdAt": "2021-03-06T18:44:49Z",
          "updatedAt": "2021-03-08T19:31:41Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner wrote\r\n\r\n> ### Conclusion\r\n\r\n>I find [Greg's comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/47#issuecomment-747165396) remarkable, where he proposes two of the following options:\r\n> \r\n> 1. not supporting evaluatable expressions at all.\r\n> 2. only support filters (for now?).\r\n> 3. only support filters on arrays (for now?).\r\n> 4. ... \"SHOULD NOT evaluate objects\" and leave it to implementations.\r\n> 5. ... \"MUST be behind an option that defaults to 'not supported.'\"\r\n> \r\n> I think, whatever option we will choose \u2013 my favorite would be 2. possibly combined with 4. and/or 5. \u2013 there should be a clear > definition, how `'@'` symbol is to be interpreted, when used by implementations. I'm not sure, if this requires an explicit \r\n> grammar and if so, how detailed it has to be then.\r\n> \r\nThe only example of a `\"[()]\"` expression that I've ever seen is the one in the original JSONPath article, \r\n```\r\n$.store.book[(@.length-1)].title\r\n```\r\nand I believe it was Glyn that noted it can be rewritten without using expressions. My sense is that this construct wouldn't be missed. But expressions are also used within filters.\r\n\r\nWhether 3 or 4, I don't have a good enough understanding of the use cases for applying a filter to objects. When applied to an array, it is reasonable to expect a certain amount of homogeneity in the elements, so it makes sense to apply common criteria to them. But that isn't generally the case for object values. And when we select object values, we lose the association with their keys, which makes the results less helpful. But I'd be interested in hearing about use cases.\r\n\r\nDaniel\r\n\r\n \r\n\r\n\r\n\r\n  ",
          "createdAt": "2021-03-06T20:02:29Z",
          "updatedAt": "2021-03-08T19:32:07Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> The only example of a \"[()]\" expression that I've ever seen is the one in the original JSONPath article,\n> ```\n> $.store.book[(@.length-1)].title\n> ```\n\nIn issue #17 I highlight ~two specific StackOverflow questions where people want to use these expressions as index selection~ (was wrong about the SO questions, but...) a [similar use case](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/17#issuecomment-701892056) for this type of expression.  I also support this in my library to some extent.\n\n---\n\nThere is a lot of overlap between these two issues. Maybe we should consider consolidating them.",
          "createdAt": "2021-03-08T03:23:50Z",
          "updatedAt": "2021-03-08T04:29:20Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Personally, I like having both forms:\n\n### `[(<expr>)]`\n\n`<expr>` returns\n\n- an integer (or perhaps a list of integers, or even a slice) that represents the index to select from an array.\n- a string (or list of strings) as key names for objects.  This \"object\" case I hadn't considered before, but it seems a natural extension and provides symmetry.\n\nThe expression is evaluated without iterating over the current value: it would take the array/object as an argument instead of iterating over their children.\n\nIt may be used less, but it definitely has it's place, and I think it caters to more advanced scenarios such as when the data itself contains the indices/keys to select.\n\n### `[?(<expr>)]`\n\nThis one we seem more familiar with.  The expression is evaluated on each child in turn.\n\n`<expr>` returns a boolean indicating whether that item should be selected.\n\nAgain, I see usefulness in allowing iteration over objects, but whether the key is included as part of the accessible data is to be defined.  Perhaps it only makes sense to allow access to the object's value collection.  Defining a mechanism that also grants access to the key while still providing symmetry with the array filter expression syntax could prove difficult.",
          "createdAt": "2021-03-08T03:47:01Z",
          "updatedAt": "2021-03-08T03:49:31Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote\r\n\r\n> Personally, I like having both forms:\r\n\r\nGiven that both were in the original article, and if filters with expressions are implemented, there is little extra implementation effort, it seems reasonable.\r\n> \r\n> ### `[(<expr>)]`\r\n> `<expr>` returns\r\n> \r\n> * an integer (or perhaps a list of integers, or even a slice) that represents the index to select from an array.\r\n> * a string (or list of strings) as key names for objects.  This \"object\" case I hadn't considered before, but it seems a natural \r\n> extension and provides symmetry.\r\n>\r\nMore generally, `<expr>` would either evaluate to an arbitrary JSON value, say `result`, or raise an error. If a value, rules need to be applied to determine whether `@[result]` makes sense, if yes, `@[result]` (if it exists) would be added to the select list, if no, nothing would be added. If an error were raised, nothing would be added to the select list. \r\n\r\nIf the current node `@` is an array, presumably `@[result]` makes sense if `result` is an integer, and maybe if `result` is an array of integers (whether generated by a slice or otherwise), and possibly if `result` is a string that contains only digits. That needs to be decided.\r\n\r\nIf the current node `@` is an object, presumably `@[result]` makes sense if `result` is a string.\r\n\r\n> ### `[?(<expr>)]`\r\n> This one we seem more familiar with. The expression is evaluated on each child in turn.\r\n> \r\n> `<expr>` returns a boolean indicating whether that item should be selected.\r\n> \r\nMore generally, `<expr>` would either evaluate to an arbitrary JSON value, say `result`, or raise an error, in exactly the same way as above. If a value, rules need to be applied to determine whether `result` could be considered `false`, and if yes, nothing would be added to the select list, otherwise, the current node would be added. If an error were raised, nothing would be added to the select list. \r\n\r\nTypical conditions to determine whether an arbitrary JSON value can be considered `false` are: \r\n\r\n* empty array: `[]`, \r\n* empty object: `{}`, \r\n* empty string: `\"\"`, \r\n* false boolean, \r\n* `null`, \r\n* zero integer. \r\n\r\nFor comparison, JMESPath requires [all of these conditions except zero integer](https://jmespath.org/specification.html#or-expressions), in JMESPath, an expression that evaluates to zero is not regarded as `false`.  But in the JSONPath Goessner javascript implementation, `$[?(0)]` returns nothing, while `$[?(1)]` returns everything in the store. \r\n\r\nA similar requirement, to find the effective boolean value of a (more complicated!) value, is present in XPath, and is described [here](https://www.w3.org/TR/xpath-31/#id-ebv). \r\n\r\n> Again, I see usefulness in allowing iteration over objects, but whether the key is included as part of the accessible data is to be > defined. \r\n\r\nAre you thinking about something like\r\n```\r\n$[?(@.key == 'foo' && @.value == 'bar')]\r\n```\r\nor perhaps\r\n```\r\n$[?(key(@) == 'foo' && @ == 'bar')]\r\n```\r\nor \r\n```\r\n$[?(stem(@) == 'foo' && @ == 'bar')]\r\n```\r\n?\r\n> Perhaps it only makes sense to allow access to the object's value collection. Defining a mechanism that also grants access to \r\n> the key while still providing symmetry with the array filter expression syntax could prove difficult.\r\n\r\nPerhaps. Although something like `key(@)` or `stem(@)` could be regarded as either an index of an array or a key of an object.   \r\n\r\n(The rationale for the name `stem` would be for the stem of the position of the current node, `position(@)` could also be supported.)\r\n\r\n",
          "createdAt": "2021-03-08T16:02:27Z",
          "updatedAt": "2021-03-08T21:09:29Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "@danielaparker yes, I think you restated what I said.  I'm not so worried about writing \"spec-y\" language in an issue, though, so much as the concept.  If we can state it in plain language and get people to agree on the idea, we can develop a more precise language to describe it later.\r\n\r\n> Typical conditions to determine whether an arbitrary JSON value can be considered false are:\r\n>\r\n> - empty array: [],\r\n> - empty object: {},\r\n> - empty string: \"\",\r\n> - false boolean,\r\n> - null,\r\n> - zero integer.\r\n\r\nI had a heck of a time implementing [\"falsiness\" and other loose equality things](https://github.com/gregsdennis/json-everything/blob/master/JsonLogic/JsonElementExtensions.cs) in .Net when I was building my [JsonLogic](https://jsonlogic.com/) library.  In a strongly-typed language/framework (where I spend most of my time), this idea is counterintuitive and just feels wrong.  But I understand the roots.  If we proceed with this kind of thing, then I suggest we approach it as I describe in #15 where I propose a DSL (I also give reasons there, so I won't repeat them here).\r\n\r\n> Although something like key(@) or stem(@) could be regarded as either an index of an array or a key of an object.\r\n\r\nI like this, but (and?) it opens the door for other functions (possibly an extension point).  Perhaps things like array/object length for the `[(<expr>)]` expression could use this instead of the widely accepted dot-key syntax: `[(length(@))]`.\r\n\r\n---\r\n\r\nAlso related (and probably another candidate for consolidation): #47.  It sounds like we like the idea of supporting it.",
          "createdAt": "2021-03-09T05:29:20Z",
          "updatedAt": "2021-03-09T18:09:25Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU4MjU0MTYwOTY=",
      "title": "A \"General Considerations\" section",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/58",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[JSON Schema 2020-12, Section 6](https://json-schema.org/draft/2020-12/json-schema-core.html#rfc.section.6), specifies a set of general considerations that I think we can \"borrow\" from.  I'll copy it here for reference and add comments.\r\n\r\n> ### 6. General Considerations\r\n> #### 6.1. Range of JSON Values\r\n> An instance may be any valid JSON value as defined by JSON. JSON Schema imposes no restrictions on type: JSON Schema can describe any JSON value, including, for example, null.\r\n\r\nJSON Schema uses the word \"instance\" to describe the JSON data that's being validated.  We seem to have landed on the word \"data.\"  Regardless, I think the gist of this also holds true for JSON Path: input values can be of any JSON type (although only certain types may return results depending on the Path).\r\n\r\n> #### 6.2. Programming Language Independence\r\n> JSON Schema is programming language agnostic, and supports the full range of values described in the data model. Be aware, however, that some languages and JSON parsers may not be able to represent in memory the full range of values describable by JSON.\r\n\r\nThis, I think, is of utmost importance.  We definitely **should not** favor a specific language.  Doing so would inhibit inclusivity and shun people who work in incompatible frameworks.\r\n\r\nThis statement also makes it clear that it's understood that some frameworks inherently have limitations that may prevent them from being able to implement the full expression of JSON Schema.  Declaring this outright allows such frameworks to have partial \"best effort\" implementations and still be compliant with the specification.\r\n\r\n> #### 6.3. Mathematical Integers\r\n> Some programming languages and parsers use different internal representations for floating point numbers than they do for integers.\r\n> \r\n> For consistency, integer JSON numbers SHOULD NOT be encoded with a fractional part.\r\n\r\nI'm not sure whether this would apply for us, except maybe for array indices.\r\n\r\n> #### 6.4. Regular Expressions\r\n> Keywords MAY use regular expressions to express constraints, or constrain the instance value to be a regular expression. These regular expressions SHOULD be valid according to the regular expression dialect described in ECMA-262, section 21.2.1.\r\n> \r\n> Regular expressions SHOULD be built with the \"u\" flag (or equivalent) to provide Unicode support, or processed in such a way which provides Unicode support as defined by ECMA-262.\r\n> \r\n> Furthermore, given the high disparity in regular expression constructs support, schema authors SHOULD limit themselves to the following regular expression tokens:\r\n> \r\n> - individual Unicode characters, as defined by the JSON specification;\r\n> - simple character classes ([abc]), range character classes ([a-z]);\r\n> - complemented character classes ([^abc], [^a-z]);\r\n> - simple quantifiers: \"+\" (one or more), \"*\" (zero or more), \"?\" (zero or one), and their lazy versions (\"+?\", \"*?\", \"??\");\r\n> - range quantifiers: \"{x}\" (exactly x occurrences), \"{x,y}\" (at least x, at most y, occurrences), {x,} (x occurrences or more), and their lazy versions;\r\n> - the beginning-of-input (\"^\") and end-of-input (\"$\") anchors;\r\n> - simple grouping (\"(...)\") and alternation (\"|\").\r\n> - Finally, implementations MUST NOT take regular expressions to be anchored, neither at the beginning nor at the end. This means, for instance, the pattern \"es\" matches \"expression\".\r\n\r\nNot sure if we're planning on supporting regular expressions.  It appears that some implementations do have some support, but it's all extension on the original syntax at this point.  Still, this is a good declaration of support.\r\n\r\nIt also ties in closely to section 6.2 regarding framework limitations as not all frameworks support the same flavor of regular expression syntax.\r\n\r\n> #### 6.5. Extending JSON Schema\r\n> Additional schema keywords and schema vocabularies MAY be defined by any entity. Save for explicit agreement, schema authors SHALL NOT expect these additional keywords and vocabularies to be supported by implementations that do not explicitly document such support. Implementations SHOULD treat keywords they do not support as annotations, where the value of the keyword is the value of the annotation.\r\n> \r\n> Implementations MAY provide the ability to register or load handlers for vocabularies that they do not support directly. The exact mechanism for registering and implementing such handlers is implementation-dependent.\r\n\r\nThis is good to have because invariably, implementations will want to extend functionality beyond what's in the spec.  It basically covers other implementations from also having to provide the same extensions, requiring only what is stated in the spec.\r\n\r\nIt also mentions \"vocabularies,\" which are a spec-defined mechanism by which implementation _can_ extend functionality via new keywords in such a way that they can optionally be supported in other implementations.  Furthermore, this mechanism allows the other implementations to refuse to process a schema that _requires_ a given vocabulary if the implementation doesn't understand it.  This bit I think is good for later when we eventually get to spec-defined extension mechanisms, but I don't expect that'll be in the first draft.\r\n\r\n---\r\n\r\nThat's it.  Just some declarations that I think would be good to have.  This is neither an exclusive nor \"all or nothing\" list.  I think we should pick and choose as we see fit.  If you think of something that's not in this list, let us know.\r\n\r\n",
      "createdAt": "2021-03-09T06:39:22Z",
      "updatedAt": "2021-03-10T20:04:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> JSON Schema uses the word \"instance\" to describe the JSON data that's being validated. We seem to have landed on the word \"data.\" \r\n\r\n[Goessner](https://goessner.net/articles/JsonPath/) uses \"root object\", which I've always thought of as a JSON value (not restricted to be an object), and somewhat analogous to the JSON Schema \"instance\". In online JSONPath articles, \"root\" is often described as the \"root object or array\", which I understand, or \"root member of a JSON structure\", which I don't understand. The draft uses \"root item\" (once) and \"root node\" (five times),  and talks about the \"root node which is the input document.\" I'm not sure if it's trying to make a distinction between \"root node\" and the JSON value passed to a JSONPath evaluator,  but from the quoted sentence, it doesn't sound like it.\r\n\r\nI also note that it's unclear what the draft means by \"node\", which occurs 60 times in the draft. In section 3.2, it says \"Each node holds a JSON value\", but it doesn't say what else the node holds (a position or path to that point?) And then we have  \"root node which is the input document\", which suggests the root node _is_ a value. My own understanding of a node is a path/value pair, and I think the draft needs to be more clear about this term, and to distinguish between root and current nodes, and the corresponding root and current values. \r\n\r\nI do think it would help to have a consistently used term to represent the thing that we pass to the evaluator. And avoid having text like \"the JSON data item to which the query is applied to\" embedded in a sentence. \r\n\r\nDaniel",
          "createdAt": "2021-03-09T20:29:32Z",
          "updatedAt": "2021-03-09T22:18:22Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Not sure this is the right issue to discuss this, but the issues are currently all over the place.\n\nIndeed, consistent terminology is needed.\n\nI wonder whether the dichotomy between item and node is a useful editorial distinction.\nThey certainly mean the same, but the term item focuses on the whole subtree while the term node focuses on the root of the subtree.\nSo \u201croot item\u201d is a bit weird (although perfectly meaningful), while root node emphasises that we are talking about a position in a common tree.\n\nAt the time JSONpath was written, JSON only allowed maps (\u201cJSON objects\u201d) and arrays as root items.  That has since changed; any data item can serve as a root item.\nBut at the time talking about \u201croot object\u201d was almost sensible, because in JavaScript arrays are almost \u201cobjects\u201d.\n\nGr\u00fc\u00dfe, Carsten\n\n\n> On 9. Mar 2021, at 21:29, Daniel Parker ***@***.***> wrote:\n> \n> \n> @gregsdennis <https://github.com/gregsdennis> wrote:\n> \n> JSON Schema uses the word \"instance\" to describe the JSON data that's being validated. We seem to have landed on the word \"data.\"\n> \n> Goessner <https://goessner.net/articles/JsonPath/> uses \"root object\", which I've always thought of as a JSON value (not restricted to be an object), and somewhat analogous to the JSON Schema \"instance\". In online JSONPath articles, \"root\" is often described as the \"root object or array\", which I understand, or \"root member of a JSON structure\", which I don't understand. The draft uses \"root item\" (once) and \"root node\" (five times), and talks about the \"root node which is the input document.\" I'm not sure if it's trying to make a distinction between \"root node\" and the JSON value passed to a JSONPath evaluator, but from the quoted sentence, it doesn't sound like it.\n> \n> I do think it would help to have a consistently used term to represent the thing that we pass to the evaluator. And avoid having text like \"the JSON data item to which the query is applied to\" embedded in a sentence.\n> \n> Daniel\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/58#issuecomment-794413895>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFUTRCXDJUTZU6PEQDGXLTCZZKXANCNFSM4Y24OPBQ>.\n> \n\n",
          "createdAt": "2021-03-10T06:55:20Z",
          "updatedAt": "2021-03-10T06:55:20Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> Not sure this is the right issue to discuss this, but the issues are currently all over the place.\n\nTo be sure, this issue was to cover the necessity of this sort of section moreso than the specific declarations.  If we agree that such a section is ideal or even required, I'm fine with that consensus for this issue and we can split out the specific topics to other issues.",
          "createdAt": "2021-03-10T07:27:36Z",
          "updatedAt": "2021-03-10T12:40:46Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "It looks like the terminology discussion is now happening over in #66.  That's one topic split out.",
          "createdAt": "2021-03-10T19:08:20Z",
          "updatedAt": "2021-03-10T19:08:20Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU4MjYwNDYzMTA=",
      "title": "Relative paths support",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/59",
      "state": "OPEN",
      "author": "bettio",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "overtaken by events -- can we close this now?"
      ],
      "body": "**Proposal**: JSONPath should have support to relative paths (to a current context), so it can be used as a building block for more advanced usages. \r\n\r\nXPath makes a clear distinction between relative and absolute paths, e.g.:\r\n\r\ngiven the following XML input:\r\n```xml\r\n<root>\r\n    <e>foo</e>\r\n    <a>\r\n        <b>\r\n            <c><d>1</d><e>bar1</e></c>\r\n            <c><d>2</d><e>bar2</e></c>\r\n            <c><d>3</d><e>bar3</e></c>\r\n        </b>\r\n    </a>\r\n</root>\r\n```\r\n\r\nand the following template, which uses the relative XPath `d` and the absolute XPath `/root/e`:\r\n\r\n```xml\r\n<?xml version=\"1.0\"?>\r\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\r\n    <xsl:template match=\"/\">\r\n        <x>\r\n            <xsl:for-each select=\"root/a/b/c\">\r\n                <item>\r\n                    <y><xsl:value-of select=\"d\"/></y>\r\n                    <z><xsl:value-of select=\"/root/e\"/></z>\r\n                </item>\r\n            </xsl:for-each>\r\n        </x>\r\n    </xsl:template>\r\n</xsl:stylesheet>\r\n```\r\n\r\nthe following XML can be produced:\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<x>\r\n    <item>\r\n        <y>1</y>\r\n        <z>foo</z>\r\n    </item>\r\n    <item>\r\n        <y>2</y>\r\n        <z>foo</z>\r\n    </item>\r\n    <item>\r\n        <y>3</y>\r\n        <z>foo</z>\r\n    </item>\r\n</x>\r\n```\r\n\r\nI think that in a similar fashion JSONPath should allow relative paths as a building feature for more advanced usages.\r\n\r\n*Remark: I acknowledge that templating/transforms are out of scope here, however I believe that we must consider enabling more advanced usages.* \r\n\r\n**Suggested implementation**: JSONPath spec should mention that `$` is always the document root, while any JSONPath which doesn't start with '$' is relative to the current context.\r\nThis wouldn't change the behavior for several existing implementations since they can assume that current context == document root.\r\n**Additional note**: There is also a number of implementations for which a JSONPath without starting `$` always evaluates to `[]`, given the previous definition we can state that their current context is always set to `null`, therefore this change would allow both as valid JSONPath spec implementations.",
      "createdAt": "2021-03-09T14:48:45Z",
      "updatedAt": "2021-11-09T21:25:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> **Proposal**: JSONPath should have support to relative paths (to a current context), so it can be used as a building block for \r\n> more advanced usages.\r\n\r\nI think it already does, with paths starting with `@`, where `@` represents the current node. \r\n> \r\n> **Suggested implementation**: JSONPath spec should mention that `$` is always the document root, while any JSONPath \r\n> which doesn't start with '$' is relative to the current context.\r\n\r\nBut consider\r\n```\r\n[{\"true\" : true}, {\"false\" : false}]\r\n```\r\nThe expression, `$[?(@.true == true)]`, which has a filter that evaluates a JSONPath expression relative to the current node `@`, and compares it to the JSON literal value `true`, gives\r\n```\r\n[{\"true\" : true}}]\r\n```\r\nIf we allowed the current node symbol `@` to be omitted, the expression would be ambiguous.\r\n\r\nFor comparison, [JMESPath also uses the @ symbol to denote the current node](https://jmespath.org/specification.html#current-node), but requires that it be omitted except as a bare expression (by itself), otherwise understood. The comparable expression in JMESPath would be\r\n```\r\n[?true == `true`]\r\n```\r\nbut JMESPath delimits JSON literals with \"`\", so the ambiguity does not arise.\r\n\r\n> **Additional note**: There is also a number of implementations for which a JSONPath without starting `$` always evaluates to \r\n> `[]`\r\n\r\nThere are some implementations that allow the [dot notation without root](https://cburgmer.github.io/json-path-comparison/results/dot_notation_without_root.html), e.g. \".foo\", and more that allow the [dot notation without root and dot](https://cburgmer.github.io/json-path-comparison/results/dot_notation_without_root_and_dot.html), e.g. \"foo\". But in most cases, they are evaluating against the passed JSON value, and produce that same result as when starting with `$`. \r\n\r\nPersonally, I'm not enthusiastic about a JSONPath starting without a `$` or `@`. My own view is that path syntax should follow common conventions, and should not vary depending on whether they appear in the main path or in expressions.\r\n",
          "createdAt": "2021-03-09T16:35:09Z",
          "updatedAt": "2021-03-09T17:04:09Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> I think it already does, with paths starting with @, where @ represents the current node.\r\n\r\nActually it doesn't: the draft spec on this repo doesn't allow it at all, @goessner's spec doesn't mention it and [the comparison](https://cburgmer.github.io/json-path-comparison/) doesn't test it.\r\n\r\nSo right now it is not obvious and a decision should be taken.\r\n\r\n> The expression, `$[?(@.true == true)]`, which has a filter that evaluates a JSONPath expression relative to the current node `@`, and compares it to the JSON literal value true, gives\r\n>\r\n> ```\r\n> [{\"true\" : true}}]\r\n> ```\r\n>\r\n> If we allowed the current node symbol `@` to be omitted, the expression would be ambiguous.\r\n\r\nI agree this might be a problem, but it can be fixed by always requiring `@` in filter expressions.\r\nMy point was mostly about relative paths in the outer expression (such as `relative.foo.bar`, where I didn't see yet an expression starting with `@`), not the filter expression.\r\n\r\nI don't know if make any sense to distinguish between filter expression context (`@`) and the outer context, I think XPath doesn't so, we can be in feature parity quite easily from that point of view. \r\n\r\nI remark that the outcome that I would expect from this discussion is reaching consensus about whether we want to support relative paths (to the current context) at first, then I would be glad to discuss how to support it (e.g. writing `@.relative.foo.bar` or `relative.foo.bar` or even `.relative.foo.bar`).",
          "createdAt": "2021-03-10T09:49:59Z",
          "updatedAt": "2021-03-10T10:04:58Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> My point was mostly about relative paths in the outer expression (such as `relative.foo.bar`, where I didn't see yet an expression starting with `@`), not the filter expression.\r\n> \r\n> I don't know if make any sense to distinguish between filter expression context (`@`) and the outer context, I think XPath doesn't so, we can be in feature parity quite easily from that point of view.\r\n> \r\nI still don't understand the requirement. The \"outer context\" is the root value at which JSONPath evaluation starts. Relative paths only have meaning inside the context of JSONPath evaluation. Within a filter expression, the current node changes as evaluation iterates over its parent. Relative paths starting with \"@\" can be evaluated against the current node.\r\n\r\nIn your original example, it seemed to me that you had a JSONPath expression, and in one case, you wanted to evaluate it against one value, and in another case, you wanted to evaluate it against another. In both cases you're going to evaluate a JSONPath expression against a value that you provide. \r\n\r\n",
          "createdAt": "2021-03-10T18:18:34Z",
          "updatedAt": "2021-03-10T18:18:34Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to shelve this concept until after we have a first version out.  As @bettio mentions, this is an advanced usage, but we can't even start to consider such things until we've defined basic usage.",
          "createdAt": "2021-03-10T18:52:11Z",
          "updatedAt": "2021-03-10T18:52:11Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> I still don't understand the requirement. The \"outer context\" is the root value at which JSONPath evaluation starts. \r\n\r\nJSONPath at the moment doesn't provide a mechanism for allowing users to choose whether their expression is relative to the JSON document root (absolute path) or to a any node inside that document.\r\n\r\nThis feature is crucial when JSONPath will be used inside of other software solutions / future specifications.\r\n\r\nLet's think about how XPath is used inside of XSLT again:\r\n```xml\r\n<xsl:for-each select=\"root/a/b/c\">\r\n  <item>\r\n    <y><xsl:value-of select=\"d\"/></y>\r\n    <z><xsl:value-of select=\"/root/e\"/></z>\r\n  </item>\r\n</xsl:for-each>\r\n```\r\n`xsl:for-each` iterates over a collection of `c` tags, at each iteration the XPath current context is set to the `xsl:for-each` current item, however the document root is still accessible by using `/` prefix.\r\n\r\n```xml\r\n<z><xsl:value-of select=\"/root/e\"/></z>\r\n<y><xsl:value-of select=\"d\"/></y>\r\n```\r\nhere `/root/e` is always the same element because the `/` prefix tells the XPath evaluator that the path is relative to the document root, on the other hand the path `d` has no `/` prefix, therefore it is relative to the current context which is changed by the XSTL engine at each `xsl:for-each` iteration.\r\n\r\nJSONPath right now doesn't allow this kind of flexibility using JSONPath language constructs (but it is required to workaround this limitation and it feels quite unnatural), I would expect absolute and relative paths concepts to be part of the specification, in a similar way to XPath.\r\n\r\n> this is an advanced usage\r\n\r\nI don't agree here, when using XPath it is really a basic feature.\r\n\r\nQuoting [XPath](https://www.w3.org/TR/1999/REC-xpath-19991116/#location-paths) doc:\r\n> There are two kinds of location path: relative location paths and absolute location paths.\r\n>\r\n> A relative location path consists of a sequence of one or more location steps separated by /. The steps in a relative location path are composed together from left to right. Each step in turn selects a set of nodes relative to a context node. An initial sequence of steps is composed together with a following step as follows. The initial sequence of steps selects a set of nodes relative to a context node. Each node in that set is used as a context node for the following step. The sets of nodes identified by that step are unioned together. The set of nodes identified by the composition of the steps is this union. For example, child::div/child::para selects the para element children of the div element children of the context node, or, in other words, the para element grandchildren that have div parents.\r\n>\r\n> An absolute location path consists of / optionally followed by a relative location path. A / by itself selects the root node of the document containing the context node. If it is followed by a relative location path, then the location path selects the set of nodes that would be selected by the relative location path relative to the root node of the document containing the context node.that would be selected by the relative location path relative to the root node of the document containing the context node.\r\n\r\nConcerning my opinion I think that it would be a quite annoying limitation not having support for relative paths. I'm ok about postponing discussion on implementation details (such as which syntax would be better) to a future discussion, but I think that discussing at least if we want this feature or not is quite important.\r\n\r\nSo honestly I would expect reaching a consensus about whether we want somehow add this kind of feature to the spec, or leave it completely out as soon as possible.",
          "createdAt": "2021-03-11T11:04:53Z",
          "updatedAt": "2021-03-11T11:04:53Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay I think I'm starting to understand what you want, @bettio.  But please know that I'm coming at this with no knowledge on XPath except what you've described, so please bear with me.\n\nBased on your example, XPath appears to be hierarchical in its declaration.  Each level declares its own set of selectors. Because of this, yes, it's important that XPath support relative (acts on the currently-processed location) and absolute (acts on the root of the initial data argument) selection patterns.\n\nJSON Path distinguishes between these using the `@` (current location) and `$` (root) operators.\n\nIt also appears that it's building a new XML object in the form in line with the structure of the XPath query.  This is describing transformation, which is where JSON Path and XPath deviate.\n\nJSON Path does not build a new JSON value.  It is only intended for finding data, not constructing new values from that data.  XPath is doing both of these things at the same time.\n\nI think this is where the \"XPath for JSON\" slogan breaks down, as has been discussed in #65.",
          "createdAt": "2021-03-11T18:57:28Z",
          "updatedAt": "2021-03-11T19:00:14Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> Okay I think I'm starting to understand what you want, @bettio. But please know that I'm coming at this with no knowledge on XPath except what you've described, so please bear with me.\r\n\r\nSorry, my fault, I'll try to be clearer here. \r\n\r\nI'll introduce XPath and XSLT and their relationship here (by quoting w3c):\r\n\r\n> XSLT, which is a language for transforming XML documents into other XML documents.\r\n\r\n> A transformation in the XSLT language is expressed as a well-formed XML document [XML] \r\n\r\n> XSLT makes use of the expression language defined by [XPath] for selecting elements for processing\r\n\r\nGoing back to [my example](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issue-826046310): `\"/\"`, `\"root/a/b/c\"`, `\"d\"` and `\"/root/e\"` are the XPath espressions embedded into the [XSLT document](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issue-826046310).\r\n\r\nSo my point is about enabling embedding of JSONPath expressions into different technologies.\r\n\r\n> JSON Path does not build a new JSON value. It is only intended for finding data, not constructing new values from that data.\r\n\r\nBasically I'm not asking/meaning this.\r\n\r\nMy point is about enabling users writing both paths relative to a context (which is defined outside JSONPath) and absolute paths (which refer to the document root by using $).\r\n\r\nAt the moment I'm not strongly opinionated about how we are going to do this, but let's suppose just for a moment we are going enabling it by using `@'.\r\n\r\nTherefore given:\r\n\r\n```json\r\n{\r\n  \"d\": \"bar\",\r\n  \"e\": \"foo\",\r\n  \"arr\": [{\"d\": 1, \"e\": \"test1\"}, {\"d\": 2, \"e\": \"test2\"}, {\"d\": 2, \"e\": \"test2\"}]\r\n}\r\n```\r\n\r\nIf we choose `$.arr[0]` as context (which is `{\"d\": 1, \"e\": \"test1\"}`) I would expect following JSONPaths evaluating to:\r\n\r\n* `$.e` -> `[\"foo\"]`\r\n* `$.arr[0].e` -> `[\"test1\"]`\r\n* `@.e` -> `[\"test1\"]`\r\n* `$.d` -> `\"bar\"`\r\n* `@.d` -> `[1]`\r\n\r\nRemark: I don't care if we are going to use `@` or `\u20ac` for this purpose, I just care about allowing writing two different kind of paths (as XPaths does) that allow writing expressions equivalent to the ones I wrote before.",
          "createdAt": "2021-03-11T23:23:13Z",
          "updatedAt": "2021-03-11T23:23:13Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the detailed summary and explanation.\n\nLooking at your example of what you expect to happen at the end of your comment, this is precisely what the current syntax does _within the context of evaluation_.\n\nHowever, `@` is not valid at the beginning of a standalone path.  It seems this is what you're asking for.\n\n_As an aside, I think there's a further deviation between [proper JSON](https://www.json.org/) ([spec](https://tools.ietf.org/html/rfc7159)) and XML in that JSON doesn't have the idea of a top-level document.  Because of this, tooling can just pass whatever current JSON value it has to a proper path evaluator to get the required output.  This is the current state of things, which is what we're actively trying to define at this time._\n\nHowever, I can see the benefit of allowing a path to start with `@` to indicate to such tooling which JSON value.  I believe some implementations support this as well (to be verified).  Basically your XML example from earlier in a hypothetical JSONT could be\n\n```\n\u200b{\n  \"for-each\u200b\": {\n   \u00a0\u200b\"select\": \"\u200b$.a.b.c\u200b\"\u200b,\n    \"item\u200b\": {\n\u00a0\u00a0\u00a0\u00a0  \"y\u200b\": \"@.\u200bd\u200b\",\n\u00a0\u00a0\u00a0\u00a0  \"z\u200b\": \"$.e\u200b\"\u200b\n    }\n  }\n}\n```\n\nThe difference between `@.d` and `$.e` becomes immediately apparent and is more of a cue to the JSONT implementation (which knows the difference between the JSON value it was given and the current JSON value) than the JSON Path evaluator.\n\nBut this only works if the JSON Path evaluator allows starting a path with `@`.  So that's your proposal.\n\n---\n\nProposal: allow paths to start with `@`.  It operates no differently than `$`, but can serve as an important indicator to tooling and other systems that consume JSON Path.\n\nMoreover, I believe it would help define such paths when defined within filter expressions. (See #17 & #64.)",
          "createdAt": "2021-03-12T03:39:05Z",
          "updatedAt": "2021-03-13T09:59:21Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> Okay I think I'm starting to understand what you want, @bettio. \r\n\r\nMe too :-)\r\n\r\nIn JSON equivalent, you want to transform\r\n\r\n```\r\n[\r\n    \"foo\",\r\n    {\"a\" : {\r\n        \"b\" : [\r\n            [{\"d\" : 1}, {\"e\" : \"bar1\"}],\r\n            [{\"d\" : 2}, {\"e\" : \"bar2\"}],\r\n            [{\"d\" : 3}, {\"e\" : \"bar3\"}]\r\n        ]\r\n    }\r\n    }\r\n]\r\n```\r\ninto\r\n```\r\n[\r\n    {\r\n        \"y\" : 1,\r\n        \"z\" : \"foo\"\r\n    },\r\n    {\r\n        \"y\" : 2,\r\n        \"z\" : \"foo\"\r\n    },\r\n    {\r\n        \"y\" : 3,\r\n        \"z\" : \"foo\"\r\n    }\r\n]\r\n```\r\n\r\nAs @gregsdennis mentioned, JSONPath doesn't support that and never will, JSONPath will only select items that already exist in the original JSON document, it will not create new items.\r\n\r\nYou might want to look at [JMESPath](https://jmespath.org/) instead. JMESPath is a query language for transforming JSON documents into other JSON documents. It's supported in both the AWS and Azure CLI and has libraries available in a number of languages. \r\n\r\nDaniel",
          "createdAt": "2021-03-12T14:43:19Z",
          "updatedAt": "2021-03-12T14:43:19Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> As @gregsdennis mentioned, JSONPath doesn't support that and never will, JSONPath will only select items that already exist in the original JSON document, it will not create new items.\r\n\r\nI think you are missing my point, I think I stated that already a few times, but I'm going to remark it: **I'm not looking for a solution for transforming nodes.**\r\n\r\nPlease, take a look to the example (the example about expressions such as `@.e`) that I reported [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-797116919), which is not about transforming.\r\n\r\nPlease, let me know if this reply was helpful, or if you need any further clarification on this topic.",
          "createdAt": "2021-03-12T19:25:04Z",
          "updatedAt": "2021-03-12T19:25:04Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielaparker, @bettio isn't asking for JSON Path to provide transformations.  He's asking for JSON Path to allow `@` at the beginning of a path so that, separately, other tooling can _use_ JSON Path.  Transformations are just an example of such tooling that could take advantage of this.\n\nIt's opening a door for others, that's all.\n\nPlease see my proposal rephrase at the end of [my comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-797212814).",
          "createdAt": "2021-03-12T19:46:41Z",
          "updatedAt": "2021-03-12T19:48:16Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> Proposal: allow paths to start with `@`. It operates no differently that `$`, but can serve as an important indicator to tooling an other systems that consume JSON Path.\r\n> \r\nOkay, I agree with that, so we may now be up to a minority of two :-)\r\n",
          "createdAt": "2021-03-12T22:28:54Z",
          "updatedAt": "2021-03-12T22:28:54Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think this is compatible with our charter?",
          "createdAt": "2021-03-16T19:20:13Z",
          "updatedAt": "2021-03-16T19:20:13Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "How so? It's not removing any functionality of existing implementations, and it actually helps define some things in expression evaluation.",
          "createdAt": "2021-03-16T19:23:18Z",
          "updatedAt": "2021-03-16T19:23:18Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> How so? It's not removing any functionality of existing implementations, and it actually helps define some things in expression evaluation.\r\n\r\nJust to note, while not documented as a feature, the influential Jayway implementation accepts paths that start with '@', most likely for the reason that @gregsdennis mentioned, to help with expression evaluation in filter predicates. You can check it out [here](https://jsonpath.herokuapp.com/).\r\n\r\n",
          "createdAt": "2021-03-16T22:03:32Z",
          "updatedAt": "2021-03-16T22:03:32Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> Just to note, while not documented as a feature, the influential Jayway implementation accepts paths that start with '@\r\n\r\nJayway implementation is indeed influential, just some numbers for the records: [here on GH](https://github.com/json-path/JsonPath) they have 5.7k stars, 1.1k forks, 50 contributors and it used by 1236 artifacts on [maven](https://mvnrepository.com/artifact/com.jayway.jsonpath/json-path).\r\nThere is clearly a huge ecosystem that builds on it and we cannot ignore it.\r\n\r\nThere is another good point about starting with `@`: it would simplify grammar for my implementation (I would love to remove that special case TBH) and more importantly I think that would be beneficial for other implementations too.\r\n\r\nIMHO that might simplify the specification as well because we would remove any special case for `@`.",
          "createdAt": "2021-03-17T18:31:11Z",
          "updatedAt": "2021-03-17T18:33:01Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "So, which are the next steps to make this part of the draft?",
          "createdAt": "2021-03-18T23:38:08Z",
          "updatedAt": "2021-03-18T23:38:08Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Write up a PR?\r\n\r\nOnce that is in place and has had some discussion (and fixes), take the PR to the mailing list.\r\nIdeally, this will result in a short discussion (because most discussion has been on the issue and the PR already), and either the editors pick it up right away or the chairs state consensus (possibly aided by an explicit consensus call).",
          "createdAt": "2021-03-18T23:44:03Z",
          "updatedAt": "2021-03-19T06:03:56Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> Write up a PR?\r\n\r\nOk, tomorrow I'll start working on it.\r\n\r\nThanks for all your feedbacks, it has been helpful discussion.",
          "createdAt": "2021-03-19T00:33:51Z",
          "updatedAt": "2021-03-19T00:33:51Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see a compelling need for this feature.\r\n\r\nFurthermore, it seems to increase the surface area of the spec in a way which, as mentioned [above](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-800538898), isn't compatible with our charter:\r\n> The WG will develop a standards-track JSONPath specification that\r\nis technically sound and complete, based on the common semantics\r\nand other aspects of existing implementations. Where there are\r\ndifferences, the working group will analyze those differences and\r\nmake choices that rough consensus considers technically best, with\r\nan aim toward minimizing disruption among the different JSONPath\r\nimplementations.\r\n\r\nIf only a small number of implementations, however influential, have a particular semantics, then standardising those semantics will fail to minimise disruption among the other implementations.",
          "createdAt": "2021-03-20T07:07:04Z",
          "updatedAt": "2021-03-20T07:07:04Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> I don't see a compelling need for this feature.\r\n> \r\nI'm interested in this issue, partly because I'm on the yay side (with reasons), but more importantly I'm interested to observe how the WG resolves matters that have some participants on the yay side , some on the nay, and presumably others that don't care. As far as I can tell, for all the issues that have arisen that find participants on one side or the other, none have been resolved with a considered decision. Of course, it's hard to tell where consensus lies, since so few people take part in discussions.\r\n\r\n> Furthermore, it seems to increase the surface area of the spec in a way which, as mentioned [above](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-800538898), isn't compatible with our charter:\r\n> \r\n> > The WG will develop a standards-track JSONPath specification that\r\n> > is technically sound and complete, based on the common semantics\r\n> > and other aspects of existing implementations. Where there are\r\n> > differences, the working group will analyze those differences and\r\n> > make choices that rough consensus considers technically best, with\r\n> > an aim toward minimizing disruption among the different JSONPath\r\n> > implementations.\r\n> \r\n> If only a small number of implementations, however influential, have a particular semantics, then standardizing those semantics will fail to minimize disruption among the other implementations.\r\n\r\nAs a principle, I think that requires interpretation. Taken literally, it would make problematic some of what's in the draft, such as requiring that slices can appear as elements in union expressions, see [Union with slice and number](https://cburgmer.github.io/json-path-comparison/results/union_with_slice_and_number.html), less than half of implementations (17 out of 41) support that, in particular, the important Jayway implementation doesn't have that, so a vast part of the JSONPath ecosystem doesn't have that.\r\n\r\nRealistically, legacy implementations are unlikely to introduce breaking changes regardless of what's in the draft. For example, the legacy Java ecosystem is not going to change the meaning of a filter applied to a JSON object, even though it's an outlier. But generalizations of the notation, such as allowing a path to begin with `@`, or allowing slices to appear as union elements, are not breaking changes. It is conceivable, although far from a certainty, that a legacy implementation could adopt some of these. But it's the new implementations, or existing ones with a comparatively small userbase, that we can expect to follow the specification. Perhaps in ten years we might find widespread adherence to the specification.  In any case, I trust nobody believes that it is possible to have an _interoperable_ specification that does not fail to comply with some feature of _every_ existing JSONPath implementation. It's apparent already in the few lines of grammar in the draft, it will become even more apparent when the WG tackles filter predicates.\r\n\r\n \r\n\r\n",
          "createdAt": "2021-03-20T15:15:38Z",
          "updatedAt": "2021-03-20T15:18:50Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> As far as I can tell, for all the issues that have arisen that find participants on one side or the other, none have been resolved with a considered decision. Of course, it's hard to tell where consensus lies, since so few people take part in discussions.\r\n\r\nMost of the issues raised aren't ready for a decision.  I do expect the chairs to pick up some issues and issue consensus calls (or declare consensus).  But, really, deciding on nested queries or on the regexp flavor is way too early.  We need to work on basics like the processing model first.  But we can continue to collect data on issues like the present one.",
          "createdAt": "2021-03-20T15:25:02Z",
          "updatedAt": "2021-03-20T15:25:02Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What cabo said.  There are high-quality arguments being offered. I would\nspecifically recommend that everyone have a glance at our charter and keep\nthat goal in the back of your mind.\n\nOn Sat., Mar. 20, 2021, 8:25 a.m. cabo, ***@***.***> wrote:\n\n> As far as I can tell, for all the issues that have arisen that find\n> participants on one side or the other, none have been resolved with a\n> considered decision. Of course, it's hard to tell where consensus lies,\n> since so few people take part in discussions.\n>\n> Most of the issues raised aren't ready for a decision. I do expect the\n> chairs to pick up some issues and issue consensus calls (or declare\n> consensus). But, really, deciding on nested queries or on the regexp flavor\n> is way too early. We need to work on basics like the processing model\n> first. But we can continue to collect data on issues like the present one.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-803378656>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJEZM5BGJHAGWG7AH6H3TES45VANCNFSM4Y3YOOQA>\n> .\n>\n",
          "createdAt": "2021-03-20T15:44:24Z",
          "updatedAt": "2021-03-20T15:44:24Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I don't think it is just a Java Jayway implemention peculiarity, and I did a quick investigation, `@.a` returns a valid result (`[1]`) for `{\"a\": 1}` at least with following implementations [1] (which I took from cburgmer's list with the precious help of his tool).\r\n\r\n@glyn\r\n> If only a small number of implementations, however influential, have a particular semantics\r\n\r\nWhich is the same number of implementations supporting regex, if they are not enough, I'm worried that the same argument/rule would stop us from adding support to regex. Honestly I think they are enough to discard this stopper.\r\n\r\n@glyn\r\n> then standardising those semantics will fail to minimise disruption among the other implementations.\r\n\r\nStandardising `@.foo` doesn't disrupt existing JSONPath expressions, this is not a breaking change.\r\nFurthermore support for `@.foo` can be added by simplifying existing code (at least this hold true for ExJSONPath), that can be added by removing the special case for supporting `@` only inside filter expressions.\r\n\r\n@glyn\r\n> Furthermore, it seems to increase the surface area of the spec in a way which, as mentioned above, isn't compatible with our charter:\r\n\r\nActually my PR formalize what those [1] implementations already support by adding just few lines of text, and it can be sumarized with:\r\n\r\n-json-path = root-selector *selector\r\n+json-path = start-selector *selector\r\n+start-selector = root-selector / current-item-selector\r\n root-selector = \"$\"               ; $ selects document root node\r\n+current-item-selector = \"@\"       ; @ selects current node\r\n\r\nMoreover if we continue the comparison with the JSONPath regex standardization (`=~`), I belive that the spec-surface-area / number-of-implementations is much more worse on the regex side. So there is a lot of effort for supporting a feature that is implemeted by 11 implementations.\r\n\r\nHonestly I don't belive that blindly applying struct rules is good for us.\r\n\r\n> The WG will develop a standards-track JSONPath specification that\r\n> is technically sound and complete, based on the common semantics\r\n> and other aspects of existing implementations. Where there are\r\n> differences, the working group will analyze those differences and\r\n> make choices that rough consensus considers technically best, with\r\n> an aim toward minimizing disruption among the different JSONPath\r\n> implementations.\r\n\r\nI believe that we can agree that standardising `@.foo` is compatible with it, and there are no preconditions against standardising it for the reasons I explained and I'll further explain.\r\n\r\nFurthermore:\r\n- Supporting `@.foo` will make filters specification simpler, since we can just use `json-path` grammar definition instead of a custom one for filters.\r\n- As @gregsdennis said, we need to introduce and define scopes for `@` anyway (which are required for nested filters among all)\r\n- This feature didn't came out of the blue, it has a simple XPath equivalent\r\n\r\nFurthermore about XPath:\r\nthe spec:\r\n> \"The JSONPath tool in question should\" ... \"cover only essential parts of XPath 1.0\".\r\n\r\nRelative paths (such as `foo`) are an essential part of XPath, and I think that XPath cannot be used as foundational technology for a number of specs that embeds it (such as XSLT).\r\n\r\n> I don't see a compelling need for this feature.\r\n\r\nI'll quote @gregsdennis (he described it better than me):\r\n>  He's asking for JSON Path to allow @ at the beginning of a path so that, separately, other tooling can use JSON Path. Transformations are just an example of such tooling that could take advantage of this.\r\n> It's opening a door for others, that's all.\r\n\r\n@gregsdennis:\r\n> Proposal: allow paths to start with @. It operates no differently than $, but can serve as an important indicator to tooling and other systems that consume JSON Path.\r\n\r\nI wish to use JSONPath as a foundational standard to build more advanced tools and specs in the future, rather than trying to find a \"feature poor\" minimum subset. If we fail doing so we should rather stick to JSON pointers.\r\n\r\n@cabo I don't think it is too early to discuss this specific issue, furthermore it might be helpful when describing filters.\r\nThe change I proposed it is quite self contained in few lines of diff, and in my opinion doesn't involve complex decisions such as regex or the filtering language.\r\n\r\n@glyn,  @timbray please, let's move forward and discuss any potential issue with `@.foo` rather further discussing if this is perfectly compatible with a littleral interpration of our charter.\r\n\r\n[1]:\r\nRuby (1/1 implementation):\r\n- jsonpath\r\n\r\nPerl (1/1 implementation):\r\n- JSON-Path\r\n\r\nDart (1/1 implementation):\r\n- json_path\r\n\r\nObjective-C (1/1 implementation):\r\n- SMJJSONPath\r\n\r\nJava (1/2 implementations):\r\n- com.jayway.jsonpath\r\n\r\ndotNET (2/4 implementations):\r\n- Manatee.Json\r\n- JsonPath.Net\r\n\r\nGo (3/6 implementations):\r\n- github.com-oliveagle-jsonpath\r\n- github.com-ohler55-ojg\r\n- github.com-spyzhov-ajson\r\n\r\nAs Elixir implementation maintainer I'm willing to implement it aswell ;)\r\n",
          "createdAt": "2021-03-20T15:50:53Z",
          "updatedAt": "2021-03-21T09:44:08Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm interested in this issue, partly because I'm on the yay side (with reasons), but more importantly I'm interested to observe how the WG resolves matters that have some participants on the yay side , some on the nay, and presumably others that don't care. As far as I can tell, for all the issues that have arisen that find participants on one side or the other, none have been resolved with a considered decision. Of course, it's hard to tell where consensus lies, since so few people take part in discussions.\r\n\r\nMe too. I haven't yet internalised https://tools.ietf.org/html/rfc7282.",
          "createdAt": "2021-03-20T16:33:22Z",
          "updatedAt": "2021-03-20T16:33:22Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "Note: As it seems this issue is about to be closed, I've moved some content from this comment to #76. \r\n\r\nJust to summarize my earlier comments on the meaning of \"current node\", and reasons why JSONPath expressions starting with \"@\" are justifiable.\r\n\r\nFirst, consider the analogous notions of \"current object\", \"current node\", and \"context item\" in [Goessner JSONPath](https://goessner.net/articles/JsonPath/), [JMESPath](https://jmespath.org/specification.html#current-node), and [XPath 3.1](https://www.w3.org/TR/xpath-31/#eval_context). \r\n\r\n&nbsp;|Goessner JSONPath|JMESPath|XPath 3.1\r\n----|-----------|-----------|-----------\r\nWhat is it called?|\"current object\"<sup>[1](#footnote1)|\"current node\"<sup>[2](#footnote2)</sup>|\"context item\" (or \"context node\" if the context item is a node)<sup>[3](#footnote3)</sup>\r\nWhere is it defined?|[Goessner](https://goessner.net/articles/JsonPath/)|[JMESPath Specification](https://jmespath.org/specification.html#current-node)|[XPath 3.1 W3C Recommendation](https://www.w3.org/TR/xpath-31/#eval_context)\r\nHow is it represented?|`@`|`@`|`.`\r\nHow is it defined?|\"using the symbol '@' for the current object\"|\"The current-node token can be used to represent the current node being evaluated...At the start of an expression, the value of the current node is the data being evaluated by the JMESPath expression. As an expression is evaluated, the value the the current node represents MUST change to reflect the node currently being evaluated. \"|\"The context item is the item currently being processed. When the context item is a node, it can also be referred to as the context node. The context item is returned by an expression consisting of a single dot (.).\"\r\nHow does it appear in the grammar?|&nbsp;|current-node  = \"@\"|ContextItemExpr &verbar; ::= &verbar; \".\"\r\nExplicit or understood?|Always explicit|Usually understood - \"JMESPath assumes that all function arguments operate on the current node unless the argument is a literal or number token. Because of this, an expression such as @.bar would be equivalent to just bar, so the current node is only allowed as a bare expression.\"|Sometimes explicit - `.//para` selects the para element descendants of the context node. Sometimes understood - `para` selects all para children of the context node\r\nHow is it used?|`$.store.book[(@.length-1)].title` `$.store.book[?(@.price < 10)].title`|`foo[].[count(@), bar]`<sup>[4](#footnote4)</sup>|`.//para` `/books/book[fn:count(./author)>1])`\r\n\r\n<a id=\"footnote1\">1</a>.  In Goessner JSONPath, the term \"object\" used here seems to refer to any JSON value. The term \"node\" is only used when referring to XPATH 1.\r\n<a id=\"footnote2\">2</a>.  In JMESPath, the term \"node\" is undefined, but can be considered synonymous with \"JSON value\". In JMESPath, paths (locations) don't figure, and results may be elements in the original JSON document, or newly created elements that don't exist in the JSON document.\r\n<a id=\"footnote3\">3</a>. For XPath 3.1, \"node\" is defined in the [XQuery and XPath Data Model 3.1 W3C Recommendation](https://www.w3.org/TR/xpath-datamodel-31/#Node)\r\n<a id=\"footnote4\">4</a>. In this JMESPath expression, `foo` is understood to mean `@.foo`, and `bar` is understood to mean `@.bar`. The only place where the symbol `@` is used explicitly is as a \"bare expression\", as shown in the argument to the `count` function.\r\n\r\n\"current object\" in Goessner JSONPath as represented by `@` is clearly underspecified, but can easily be understood in the more general sense in JMESPath, as \"the node currently being evaluated\", or in XPath 3.1, as \" the item currently being processed\".\r\n\r\nThe Goessner examples:\r\n```\r\n$.store.book[(@.length-1)].title                   (1)\r\n\r\n$.store.book[?(@.price < 10)].title               (2)\r\n```\r\nare fully consistent with the more general sense. In (1), the \"current node\" @ represents the array `$.store.book`, in (2), the `?` connotes iteration over the array, and `@` represents an array element.\r\n\r\nIt's easy to generalize that at `$`, the current node `@` represents '$'; at `$.store`, it represents `$.store`, and so on.\r\n",
          "createdAt": "2021-03-21T16:39:20Z",
          "updatedAt": "2021-03-22T18:58:34Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Has someone done a survey of which implementations support leading @? I\nthought I saw one in the email/github trail but now I can't find it.\nObviously relevant given our charter.\n\nOn Sun, Mar 21, 2021 at 9:39 AM Daniel Parker ***@***.***>\nwrote:\n\n> Just to summarize my earlier comments on the meaning of \"current node\",\n> and reasons why JSONPath expressions starting with \"@\" are justifiable.\n>\n> First, consider the analogous notions of \"current object\", \"current node\",\n> and \"context item\" in Goessner JSONPath\n> <https://goessner.net/articles/JsonPath/>, JMESPath\n> <https://jmespath.org/specification.html#current-node>, and XPath 3.1\n> <https://www.w3.org/TR/xpath-31/#eval_context>.\n>   Goessner JSONPath JMESPath XPath 3.1\n> What is it called? \"current object\" \"current node\" \"context item\" (or\n> \"context node\" if the context item is a node )\n> Where is it defined? Goessner <https://goessner.net/articles/JsonPath/> JMESPath\n> Specification <https://jmespath.org/specification.html#current-node> XPath\n> 3.1 Specification <https://www.w3.org/TR/xpath-31/#eval_context>\n> How is it represented? @ @ .\n> How is it defined? \"using the symbol '@' for the current object\" \"The\n> current-node token can be used to represent the current node being\n> evaluated...At the start of an expression, the value of the current node is\n> the data being evaluated by the JMESPath expression. As an expression is\n> evaluated, the value the the current node represents MUST change to reflect\n> the node currently being evaluated. \" \"The context item is the item\n> currently being processed. When the context item is a node, it can also be\n> referred to as the context node. The context item is returned by an\n> expression consisting of a single dot (.).\"\n> How does it appear in the grammar?   current-node = \"@\" ContextItemExpr |\n> ::= | \".\"\n> Explicit or understood? Always explicit Usually understood - \"JMESPath\n> assumes that all function arguments operate on the current node unless the\n> argument is a literal or number token. Because of this, an expression such\n> as @.bar would be equivalent to just bar, so the current node is only\n> allowed as a bare expression.\" Sometimes explicit - .//para selects the\n> para element descendants of the context node. Sometimes understood - para\n> selects all para children of the context node\n> How is it used? ***@***.***)].title ***@***.*** <\n> 10)].title foo[].[count(@), bar] .//para\n>\n> \"current object\" in Goessner JSONPath as represented by @ is clearly\n> underspecified, but can easily be understood in the more general sense in\n> JMESPath, as \"the node currently being evaluated\", or in \" the item\n> currently being processed\".\n>\n> The Goessner examples:\n>\n> ***@***.***)].title                   (1)\n>\n>\n>\n> ***@***.*** < 10)].title               (2)\n>\n>\n> are fully consistent with the more general sense. In (1), the \"current\n> node\" @ represents the array $.store.book, in (2), the ? connotes\n> iteration over the array, and @ represents the array element.\n>\n> It's easy to generalize that at $, the current node @ represents '$', at\n> $.store, it represents $.store, and so on.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-803618374>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJE6K6YGIL545TLZ5OIDTEYOMPANCNFSM4Y3YOOQA>\n> .\n>\n",
          "createdAt": "2021-03-21T16:45:41Z",
          "updatedAt": "2021-03-21T16:45:41Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@timbray wrote:\r\n\r\n> Has someone done a survey of which implementations support leading @? I thought I saw one in the email/github trail but now I can't find it. Obviously relevant given our charter.\r\n\r\nSee [@bettio's post](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-803385123) above. He's determined that 10 of the 41 implementations in Christoph Burgmer's JSONPath Comparisons support leading `@`, including the important Jayway implementation. \r\n\r\nI would suggest that he submit his test case as a pull request to JSONPath Comparisons, so that it can be properly referenced. ",
          "createdAt": "2021-03-21T17:58:09Z",
          "updatedAt": "2021-03-21T21:33:23Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I think, the `json_path_eval(root, root.foo, \"@.bar\")` example makes the usefulness of relative pathes for tools cristal clear. So `current-item-selector` requires either \r\n* an explicit absolute path as start node (here ` root.foo`) or\r\n* an implicite current node given during processing the JSON tree\r\n* else the fallback to root-selector `$`.\r\n\r\nThe obvious problem we are having here, is above tooling being completely out of scope of the draft. At best we can demand, that a starting relative path always needs as compagnon an explicit absolute path (wherever it comes from) or an implicite one defaulting to `$`. \r\n\r\nWe then have by combining both an overall absolute start path again, as @bettio showed in his starting post as XPath analogon:\r\n\r\n> which uses the relative XPath d and the absolute XPath /root/e:\r\n\r\nSo once formulated with care &ndash; in work at https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/pull/75 &ndash; it does not cost much.\r\n\r\nBut ...\r\n\r\n```\r\n... current item selector `@` when used outside a filter ...\r\n```\r\n\r\nneeds to be discussed more urgently before. So I would like to wait with merging pull request https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/pull/75 until all uses of `@` are readily discussed.\r\n",
          "createdAt": "2021-03-22T14:21:35Z",
          "updatedAt": "2021-03-22T14:21:35Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@goessner the one you quoted is the older #75 wording, I updated it in the meantime to:\r\n```\r\nThe current item selector `@` can be used to represent the current item being\r\nevaluated. The initial current item defaults to the root node unless a\r\ndescendant node is given to the evaluator as initial current item.\r\n```\r\nI did that so we can merge it before going deep into the filters formalization that I think it will require a lot of work and time.\r\n\r\nI agree with you that we need to discuss in depth the meaning of `@` and investigate it more.\r\n\r\nIf we all agree I propose following action points:\r\n1. agreeing that relative paths are a wanted feature that should be part of the standard \r\n2. closing this issue (I feel like that this issue is to long to read, and we should start with a new issue/discussion)\r\n3. starting a new issue for discussing `@` and investigating it in depth\r\n\r\nI don't know if @glyn , @cabo  or @timbray have any further argument or point on the feature itself, otherwise if we have no further points we can move forward :)\r\n\r\n@timbray I feel like that the charter point is not an issue anymore and we can all agree that it is compatible.\r\n\r\nBy the way, thank you to all of you for involvement in this discussion, it has been an interesting discussion. ",
          "createdAt": "2021-03-22T16:55:37Z",
          "updatedAt": "2021-03-22T16:55:52Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I would say that filters are the main motivation for `@` and we should  keep this issue open, but defer further work on it until filters have been added to our draft. The interim position can be that `@` is meaningless outside a filter - then we are free to extend to usages outside filters if we decide that's something we want to pursue.",
          "createdAt": "2021-03-22T17:50:18Z",
          "updatedAt": "2021-03-22T17:50:18Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@glyn sorry, I feel a bit like we are indefinitely deferring any decision rather than discussing actual arguments against this use case.\r\nIf you have any argument I wish to discuss it, if there aren't I think we can agree all and move forward.\r\n\r\nAlso as I commented before, I think that actually allowing `@` outside filters enable us into writing a simpler grammar for filters, so I believe we should discuss `@` usage before of them.",
          "createdAt": "2021-03-22T18:08:42Z",
          "updatedAt": "2021-03-22T18:08:42Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "My reasons for not favouring the above use of `@` outside filters are:\r\n* Our charter. How many implementations allow a \"current value\" to be passed in rather than merely supporting \"leading @\"?\r\n* This would increase the surface area of the spec (i.e. allowing a \"current value\" to be passed in) without a compelling use case. In other words, this feels like a solution looking for a problem. ;-)\r\n\r\nAlso, I think arguments about simplifying the grammar of filters are moot until we have such a grammar.",
          "createdAt": "2021-03-22T18:56:20Z",
          "updatedAt": "2021-03-22T18:56:20Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I'm \"reopening\" this discussion after the discussion we had in other issues, I think we are ready to further discuss this one.\r\n\r\n@glyn:\r\n> Our charter. How many implementations allow a \"current value\" to be passed in rather than merely supporting \"leading @\"?\r\n\r\nAs I mentioned, I think we all clarified now, in other discussions, that this is not an issue and it is 100% compatible with our charter.\r\n\r\nBy the way [ExJSONPath](https://github.com/ispirata/exjsonpath/) implements it ;) I also did a quick check (only) on [Jayway Java](https://github.com/json-path/JsonPath) and it has the following function:\r\n\r\n```java\r\npublic EvaluationContext evaluate(Object document, Object rootDocument, Configuration configuration, boolean forUpdate)\r\n```\r\n\r\nHowever I'm not a Java developer so I'm not sure how this is exposed through the API.\r\n\r\nHonestly I don't plan to check all ther other implementations, since it is not required/useful for our discussion (again it is not a WG charter requirement and also it is a time consuming activity).\r\n\r\n@glyn:\r\n> This would increase the surface area of the spec (i.e. allowing a \"current value\" to be passed in)\r\n\r\nIt is completely optional, implementations will not be required to follow this part of the spec and they can stick to the document root as default initial current value.\r\nThe surface increase is merely telling implementers that current item can be (if they want / if they need it) set to a descendant node as initial node (instead of the root node).\r\nI also think that defining an API is out-of-scope, but mentioning that a different (than the document root) initial current item can be chosen is fine.  \r\n\r\n@glyn:\r\n> without a compelling use case.\r\n\r\nI got following feedbacks:\r\n\r\n@gregsdennis\r\n> However, I can see the benefit of allowing a path to start with @ to indicate to such tooling which JSON value. I believe some implementations support this as well (to be verified).\r\n\r\n@gregsdennis:\r\n> It's opening a door for others, that's all.\r\n\r\n@danielaparker:\r\n> Okay, I agree with that, so we may now be up to a minority of two :-)\r\n\r\n@goessner:\r\n> I think, the json_path_eval(root, root.foo, \"@.bar\") example makes the usefulness of relative pathes for tools cristal clear.\r\n\r\nIt looks to me that there is some agreement about its usefulness.\r\n\r\n@glyn:\r\n> In other words, this feels like a solution looking for a problem. ;-)\r\n\r\n@gregsdennis made [an example](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/59#issuecomment-797212814) (similar to my usecase) that vastly benefit from a similar feature.\r\n\r\nAlso again this is about \"opening a door\" we don't need to know all the possibilities in advance.\r\n\r\nAs a \"philosophical\" point of view I also believe that the relative path concept is a widely known concept tight to the path concept. Nearly every time some kind of path is defined, a relative path concept is defined as a consequence as well.\r\n\r\nLast but not least, this feature has a XPath 1.0 counterpart so we are not introducing a new feature out of the blue, and we already know that it is a widely used feature in XPath.\r\n\r\n> Also, I think arguments about simplifying the grammar of filters are moot until we have such a grammar.\r\n\r\nWe already know that it will (I know it because I had the same kind of issue when I was working to my implementation), `json-path` rule with my changes can be used as-is for a (likely) filter grammar definition, since it provides a uniform definition for both `@.foo` and `$.bar` cases, which doesn't require additional filter specific path definitions.",
          "createdAt": "2021-03-29T11:35:28Z",
          "updatedAt": "2021-03-29T11:48:56Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I still think the complexity/benefit ratio of this proposal is quite high, so I'm not keen to adopt it. Let's see what the consensus is.",
          "createdAt": "2021-03-29T15:10:55Z",
          "updatedAt": "2021-03-29T15:10:55Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I still firmly support this.",
          "createdAt": "2021-03-29T18:44:13Z",
          "updatedAt": "2021-03-29T18:44:13Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "No new activity in last month.\r\n@glyn are you willing to compute consensus based on the whole discussion?",
          "createdAt": "2021-04-29T09:21:02Z",
          "updatedAt": "2021-04-29T09:22:25Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> No new activity in last month.\r\n> @glyn are you willing to compute consensus based on the whole discussion?\r\n\r\nNo, I'll leave that to the Chairs, thanks.",
          "createdAt": "2021-05-04T17:37:49Z",
          "updatedAt": "2021-05-04T17:37:49Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "Any news?",
          "createdAt": "2021-05-13T08:04:14Z",
          "updatedAt": "2021-05-13T08:04:14Z"
        },
        {
          "author": "fiestajetsam",
          "authorAssociation": "MEMBER",
          "body": "@bettio the consensus that was made during the meeting on Tuesday ([minutes here](https://datatracker.ietf.org/doc/minutes-interim-2021-jsonpath-01-202105110900/)) was that at this stage we won't include relative path support as it's been described in this PR. Several points already mentioned in this issue were re-iterated in the meeting such as charter scope, and percentage of existing deployments.\r\n\r\nIf you continue to feel strongly for it the two options are either providing a further case for its inclusion into the base specification, or consider this work as an extension - a key action that was set at the meeting was for JSONPath to have an extension model in place, and this seems like an obvious candidate.",
          "createdAt": "2021-05-14T22:57:10Z",
          "updatedAt": "2021-05-14T22:57:10Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "https://stackoverflow.com/q/68926463/878701\n\nThis is a question that would benefit from another concept of relative paths, more akin to the [Relative JSON Pointer](https://tools.ietf.org/id/draft-handrews-relative-json-pointer-00.html).  This pointer allows travel _up_ the data structure so that parent, sibling, and cousin data can be selected.",
          "createdAt": "2021-08-25T22:48:03Z",
          "updatedAt": "2021-08-25T22:48:03Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis, access to the parent node is one of the most requested features of JSONPath on Stack Overflow and elsewhere. [JSONPath Plus](https://www.npmjs.com/package/jsonpath-plus) was first to introduce the notation '^' for parent operator. Currently this feature is supported by three implementations in the JSONPath Comparisons, see [Filter expression with parent axis operator](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_parent_axis_operator.html). See [Support for path axis navigation](https://github.com/cburgmer/json-path-comparison/issues/88) for discussion pertaining to this query, and why the implementations give different results for values. (They do give the same results for output paths, it appears that JSONPath Plus gives inconsistent results for returning output paths and values when applying the parent operator.)\r\n\r\nSupport for a JSONPath parent operator doesn't actually require keeping a parent pointer along with the JSON value. Rather, all it requires is path tracking (which is required anyway for implementations that support output paths), the ability to back up one level in the path, and access to the root node. In other words, it can be implemented trivially in all implementations that support output of normalized paths as an option.   \r\n\r\n",
          "createdAt": "2021-09-03T15:25:42Z",
          "updatedAt": "2021-09-03T15:35:59Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "IIRC we decided for filter expressions containing filter expressions ... can't locate that discussion though.\r\n\r\nSo with a former example of mine\r\n\r\n>Consider a school,\r\n> ```json\r\n> {\r\n>    \"students\": [...],\r\n>    \"staff\": [...],\r\n>    \"teachers\": [...]\r\n> }\r\n> ```\r\n> while looking for the array(s) containing persons named 'M\u00fcller' ...\r\n\r\nwe can now write `$[?@[?@.name=='M\u00fcller']]`.\r\n\r\nObviously the corresponding filter syntax  in the latest draft \r\n\r\nhttps://ietf-wg-jsonpath.github.io/draft-ietf-jsonpath-base/draft-ietf-jsonpath-base.html#name-filter-selector\r\n\r\nshould be corrected from\r\n\r\n` rel-path     = \"@\" *(dot-selector / index-selector)`\r\n\r\nto\r\n\r\n`rel-path     = \"@\" *(dot-selector / index-selector / filter-selector)`\r\n\r\nthen.\r\n\r\nGiven this, an explicit parent operator `^` would be redundant. But ...\r\n\r\n@danielaparker\r\n>Support for a JSONPath parent operator doesn't actually require keeping a parent pointer along with the JSON value. Rather, all it requires is path tracking (which is required anyway for implementations that support output paths), the ability to back up one level in the path, and access to the root node. In other words, it can be implemented trivially in all implementations that support output of normalized paths as an option.\r\n\r\n... regarding the obvious low hurdle for implementating that operator, we might discuss it under the aspect of user-friendliness.\r\n\r\n\r\n",
          "createdAt": "2021-09-08T11:07:51Z",
          "updatedAt": "2021-09-08T11:07:51Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "sorry ... wrong button ...",
          "createdAt": "2021-09-08T11:08:29Z",
          "updatedAt": "2021-09-08T11:08:29Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU4Mjc3MDQ2ODk=",
      "title": "Determinism?",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/60",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Does applying a JSONPath query to a JSON data item always generate the same result?\r\n\r\nSome selectors do not have a natural order of the nodelists they return, e.g., $.* applied to a JSON object\r\n\r\nWe could prescribe an order (e.g., sorting keys lexicographically or in JavaScript order) if determinism is important\r\n\r\nWe could disallow .* on JSON objects",
      "createdAt": "2021-03-10T13:02:18Z",
      "updatedAt": "2021-11-10T10:46:57Z",
      "closedAt": "2021-11-10T10:46:57Z",
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "hmm .. depends, how deterministic JSON parsers are when iterating over \r\nobjects ... they should work in ascending chronological order ...\r\n\r\nhttps://stackoverflow.com/questions/42491226/is-json-stringify-deterministic-in-v8\r\n\r\nJavaScript 'Object.keys' also guaranties the same order\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\r\n\r\nSo ... order should be always the same, as long the implementation is \r\nthe same. How different implementations behave is uncertain at best.\r\n\r\nBut why should we care and heal deficiencies of JSON parsers in that case?\r\n\r\nI can't see a benefit of always guaranteeing the same -whatever- order. \r\nAnd disallowing iterating over objects by '$.*' might break existing \r\nimplementations.\r\n\r\n",
          "createdAt": "2021-03-10T14:18:55Z",
          "updatedAt": "2021-03-10T17:16:33Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I can't see a benefit of always guaranteeing the same -whatever- order.\r\n\r\nA minor benefit would be that the Compliance Test Suite would be simpler if the output always had a defined implementation-independent ordering.\r\n\r\n> And disallowing iterating over objects by '$.*' might break existing implementations\r\n\r\nAgreed.\r\n\r\n",
          "createdAt": "2021-03-10T16:59:24Z",
          "updatedAt": "2021-03-10T16:59:24Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "(Determinism in interop testing is a major benefit for me.  But that can be added by reprocessing after the JSONpath processing, so it is not completely a killer argument.)",
          "createdAt": "2021-03-10T17:00:39Z",
          "updatedAt": "2021-03-10T17:00:39Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Another selector which requires careful definition for ordering is `..`, particularly when this recurses over an object or objects.",
          "createdAt": "2021-03-10T17:03:37Z",
          "updatedAt": "2021-03-10T17:03:37Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "hmm ... compliance testing is a point, sure. Simple first tests of `$.obj.*` and `$..*` regarding ordering should be possible with current test suite ... ?",
          "createdAt": "2021-03-10T17:14:50Z",
          "updatedAt": "2021-03-10T17:14:50Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> hmm ... compliance testing is a point, sure. Simple first tests of `$.obj.*` and `$..*` regarding ordering should be possible with current test suite ... ?\r\n\r\nAnything is \"possible\". ;-)\r\n\r\nTests involving objects which have only one name/value pair are trivially easy to test because any non-determinism of object enumeration is irrelevant. But tests involving objects with two or more name/value pairs need to capture the ordering possibilities somehow. Note that the [current test suite](https://github.com/jsonpath-standard/jsonpath-compliance-test-suite/blob/main/cts.json) is a JSON document so there would need to be a _declarative_ way of specifying the ordering possibilities.",
          "createdAt": "2021-03-10T18:16:50Z",
          "updatedAt": "2021-03-10T18:16:50Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "We covered this topic over in the JSON Schema repo somewhere with quite a lengthy discussion.  I'll see if I can dig it up.\n\nIn short, parsers in some languages just can't be made to be deterministic.  Reading the same object from a file (where the keys are certainly in a defined sequence) will yield differing orderings when printing or even debugging the value.\n\nThis topic, therefore, falls into the \"language agnosticity\" category.  I don't think it's something we can enforce.",
          "createdAt": "2021-03-10T19:05:51Z",
          "updatedAt": "2021-03-10T19:05:51Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> Some selectors do not have a natural order of the nodelists they return, e.g., $.* applied to a JSON object\r\n\r\n> We could disallow .* on JSON objects\r\n\r\n`$.*` is accepted (and correctly evalueted) by ~93% of the implementations on the [JSONPath comparison](https://cburgmer.github.io/json-path-comparison/#dot_notation_with_wildcard_on_object).\r\n\r\nEach of them has a number of users, it is really important to not disrupt their existing expressions and their habits.\r\n\r\n> We could prescribe an order (e.g., sorting keys lexicographically or in JavaScript order) if determinism is important\r\n\r\nI don't think determinism is that important, `$.*` on a object evals to an array but semantically it is an unordered set (which is not a JSON type, therefore a different type is used \u00b9) which is still a meaningful result and developers should remember that. Hence we shouldn't discard this feature.\r\n\r\nAnyway what I found confusing when implementing [ExJSONPath](https://github.com/ispirata/exjsonpath/) was the lack of any official recommendation about `$.object.*` on a object behaviour.\r\n\r\nI think we should clearly state that the result has to be treated as unordered but we might suggest using lexicographic order for validation purposes when possibile (I think a huge number of implementations are using ordered maps for JSON objects storage so it shouldn't be hard). \r\n\r\n> Determinism in interop testing is a major benefit for me.\r\n\r\nRemoving an implemented fature used from a number of users for testing purposes is something that I wish to not discuss.\r\n\r\n> hmm .. depends, how deterministic JSON parsers are when iterating over\r\n> objects ... they should work in ascending chronological order ...\r\n\r\nI think a number of JSONPath implementations are completely decoupled from the JSON parser, and they just accepted maps/lists/atomic-values as input ([ExJSONPath](https://github.com/ispirata/exjsonpath/) is one of them, it doesn't depend on any JSON parser and it doesn't care about JSON parsing).\r\n\r\nI'm not even sure if JSONPath is only used for JSON inputs, it works so nicely with any JSON-like structure.\r\n\r\n\u00b9 I'm not 100% sure that all implementations are using JSON types, there might be implementations using unordered sets for real as containers for `$.object.*` results.",
          "createdAt": "2021-03-12T10:29:00Z",
          "updatedAt": "2021-03-12T10:29:00Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Each of them has a number of users, it is really important to not disrupt their existing expressions and their habits.\n\nA noble goal, to be sure. But I imagine that sudden conformance to a spec would natural engender breaking changes, especially in a landscape of Implementation as large as we're dealing with. I don't think it'll be avoided.\n\nAs such, my feeling is that we get the spec right rather than make concessions just because the majority does it some way.\n\n> I think a number of JSONPath implementations are completely decoupled from the JSON parser...\n\nAbsolutely correct.",
          "createdAt": "2021-03-12T11:25:41Z",
          "updatedAt": "2021-03-12T11:25:41Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-12, at 12:26, Greg Dennis ***@***.***> wrote:\n> \n> As such, my feeling is that we get the spec right rather than make concessions just because the majority does it some way.\n\nWe have some of this in our DNA, but we also have a clear mandate not to disregard the installed base (this is JSONpath, not a new protocol based on JSONpath).  \n\nSo any argument on this spectrum will need to be carefully weighed, because both extremes are wrong.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-12T11:31:34Z",
          "updatedAt": "2021-03-12T11:31:34Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I think the summary so far is\r\n\r\n* We recognize that there are operations in JSONPath whose result is ordered but that order needs to be created based on unordered input.\r\n* We are not going to cut off these noses to spite our face.\r\n* We have a choice between imposing a language-defined order (e.g., sorting) or leaving the result non-deterministic.\r\n\r\nI gather that there is a general direction toward non-determinism, as imposing an order would be too expensive, but I'm not sure we have a conclusion here.\r\n\r\nAlso: <https://mailarchive.ietf.org/arch/msg/jsonpath/N_emdQBtZg3xTuVQBFyXcjAR4ZE>\r\n",
          "createdAt": "2021-03-13T13:54:10Z",
          "updatedAt": "2021-03-13T13:54:10Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Carsten's general direction in support of nondeterminism, simply because 8259 explicitly discourages assigning semantics to the ordering of object members.  If we want determinism, we probably have to specify RFC8785 (JCS) conformance, which doesn't feel reasonable. As for testing, anyone who's doing this seriously in the real world has to have an JSONObject.equals() method already, right?",
          "createdAt": "2021-03-16T19:18:37Z",
          "updatedAt": "2021-03-16T19:18:37Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I also agree with supporting non-determinism, but please note that JSONObject.equals() won't necessarily help because the non-deterministic portions of the output won't necessarily be part of a JSONObject. For example, applying `.*` to an input consisting of a JSON object will produce a node list in a non-deterministic order.\r\n\r\nI think we'd either need to decorate such tests with an indication of where non-determinism can occur so that each test framework can compare the output to the expected value and take into account non-determinism or we'd need to have a way of capturing a set of possible alternative outputs. The latter may be preferable as it would complicate the generation of tests, which is a one-off process, but would simplify implementing test frameworks, of which there are likely to be many. (There may be other solutions too - haven't spent very long on this.)",
          "createdAt": "2021-03-17T07:46:11Z",
          "updatedAt": "2021-03-17T07:46:11Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, in implementing JSON Schema, I've found that I need both contents-equality and sequence-equality on arrays depending on the circumstance.\r\n\r\nGiven that JSON Path outputs an array, and the contents of that array are likely to be generated non-deterministically due to evaluating objects, I think it makes sense for implementations to verify evaluation results (e.g. when processing a test suite) in a \"contents-equality\" sense.  It's not per the JSON definition of array equality (which mandates sequence-equality), but I think the circumstance fits.\r\n\r\nThe fact that the result array is not guaranteed to be deterministic would need to be declared in the specification, probably associated with a remark about it deviating from JSON array equalilty and perhaps even an explanation why.",
          "createdAt": "2021-03-17T08:23:49Z",
          "updatedAt": "2021-03-17T08:23:49Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Nodelists are not arrays.\r\n(They can be represented in a JSONPath API as arrays.  Or as lists.  Or as tuples. ...)\r\n",
          "createdAt": "2021-03-17T09:33:10Z",
          "updatedAt": "2021-03-17T09:33:10Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I do agree with common non-determinism here. Naming results as nodelists is clever. Shouldn't we define that term 'nodelist' then ?",
          "createdAt": "2021-03-17T14:21:51Z",
          "updatedAt": "2021-03-17T14:21:51Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Yes, we should define nodelist.  I made a first attempt in PR #72 now.\r\n",
          "createdAt": "2021-03-17T14:33:20Z",
          "updatedAt": "2021-03-17T14:33:20Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "We need to tread carefully here. Are we saying we're comfortable outputting something that's not JSON but acts really similar?\n\nAll implementations (including @goessner) output an array (or optionally `false`) _as JSON_.  If we suddenly call the output a \"nodelist\" are we breaking that?",
          "createdAt": "2021-03-17T18:27:37Z",
          "updatedAt": "2021-03-17T18:27:37Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> If we suddenly call the output a \"nodelist\" are we breaking that?\r\n\r\nNo.  I agree that many APIs will output platform arrays here (which may or may not feel similar to JSON arrays).  Saying that the output is a nodelist is gives them freedom to define their API and how these present the nodelist.\r\n\r\nMore importantly, we make processing for embedded queries less finicky.\r\n",
          "createdAt": "2021-03-17T19:16:05Z",
          "updatedAt": "2021-03-17T19:16:19Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Daniel, nobody can (or will try to) stop you thinking about a nodelist as a JSON array, if that suits your mental model.\r\nGiving a separate name to that concept does have its advantages.\r\nIt, for instance, helps finding answers to the role of nested queries in filter expressions.\r\nIt also helps reflect the fact that some implementations handle nodelists different from others.\r\nSo I don't know why we are having this discussion.\r\n(And why is it under \"Determinism?\".)",
          "createdAt": "2021-03-18T17:05:30Z",
          "updatedAt": "2021-03-18T17:05:30Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> It also helps reflect the fact that some implementations handle nodelists different from others.\n\nThis is irrelevant because of many of the points that @danielaparker mentioned: essentially, implementations don't use nodelists from what we can tell, they use arrays.  And isn't our charter to break existing implementations as little as possible?  If _all_ implementations use arrays, changing that is not something we should consider lightly.\n\n@cabo We're discussing it here because of [your comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/60#issuecomment-800936130).  Following some discussion [elsewhere](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/74#issuecomment-799717411) about expressions, you spammed \"nodelist\" comments anywhere it might be related in order to promote the idea before anyone had a chance to discuss it.  So now we're discussing it.\n\n---\n\nAll of that said, I think we should consider the output format (#23 & #44), determinism (this issue), and paths embedded in expressions (#74) together.  There is some subtle interplay going on.\n\nIf the output is an array of objects that specify location and value, then both that format and the sequence of the items within it need to be considered when returning from an embedded path so that the remainder of the expression can handle it properly.\n\nIf embedded paths are to follow some different output that operators can then use, we need to specify what that is as well.  Maybe that is the idea of a nodelist.  But we need to discuss it first and come to some level of agreement.",
          "createdAt": "2021-03-18T18:52:26Z",
          "updatedAt": "2021-03-18T19:02:08Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "It is a pretty common technique in model building to identify important concepts, and once one has identified them, to give them (tentative) names.  That allows the participants to refer to the concept-in-formation, and to gradually increase certainty about it.  Once there is enough certainty, it may be possible to identify some concepts with each other and turn them into one, but you don't do that before achieving that certainty.\r\n\r\nI think much of the confusion comes from a perception that whatever is in the draft at one time is cast in concrete.  That is not a healthy way to run this, and maybe I was making an unwarranted assumption that this would be obvious.\r\n\r\nSo, indeed, feedback is good, but not so much about reasons wanting to eliminate/equate concepts prematurely and end the discussion about them before understanding them, but more about the properties of the concept itself.  The fact that XPath arrived at a specific form of nodelist after trying nodesets is certainly interesting feedback.  We may not need that complexity, but it is much easier to eliminate complexity once we understand the concepts.",
          "createdAt": "2021-03-18T22:04:45Z",
          "updatedAt": "2021-03-18T22:07:25Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> Given that JSON Path outputs an array, and the contents of that array are likely to be generated non-deterministically due to evaluating objects, I think it makes sense for implementations to verify evaluation results (e.g. when processing a test suite) in a \"contents-equality\" sense. It's not per the JSON definition of array equality (which mandates sequence-equality), but I think the circumstance fits.\r\n\r\nI'm not sure this is sufficient. Let me explain why with an example.\r\n\r\nTake the input argument:\r\n```\r\n{ \"a\": {\"c\": 0, \"d\": 1},\r\n  \"b\": {\"e\": 2, \"f\": 3}\r\n}\r\n```\r\nand the selector `$.*.*`.\r\n\r\nI think the valid outputs should be:\r\n* `[0, 1, 2, 3]`\r\n* `[0, 1, 3, 2]`\r\n* `[1, 0, 2, 3]`\r\n* `[1, 0, 3, 2]`\r\n* `[2, 3, 0, 1]`\r\n* `[2, 3, 1, 0]`\r\n* `[3, 2, 0, 1]`\r\n* `[3, 2, 1, 0]`\r\n\r\nBut I think the following output, for example, should be invalid:\r\n* `[0, 2, 1, 3]`\r\n\r\nThe spec should allow for this level of non-determinism, but not more.\r\n\r\nSimilarly, if the Compliance Test Suite covers this example, it should allow precisely the valid outputs to pass. I don't see how a \"contents-equality\" comparison of arrays would help. This makes me favour encoding _sets_ of possible outputs in the CTS as described in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/60#issuecomment-800871622. ",
          "createdAt": "2021-03-19T06:26:50Z",
          "updatedAt": "2021-03-19T08:49:18Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> * `[0, 1, 2, 3]`\r\n> * `[0, 1, 3, 2]`\r\n> * `[1, 0, 2, 3]`\r\n> * `[1, 0, 3, 2]`\r\n\r\nActually, [2, 3, 0, 1] etc. as well (the outer container also is a map).",
          "createdAt": "2021-03-19T07:25:58Z",
          "updatedAt": "2021-03-19T07:25:58Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> Actually, [2, 3, 0, 1] etc. as well (the outer container also is a map).\r\n\r\nWhoops! Yes. Edited the list so it is now complete.",
          "createdAt": "2021-03-19T08:49:50Z",
          "updatedAt": "2021-03-19T08:49:50Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> (@glyn) But I think the following output, for example, should be invalid:\n> \n> - `[0, 2, 1, 3]`\n\nI'm curious why you think this should be invalid.  I understand how you got the result, and if you include (or replace with) the paths to those values, it's just as (or more) clear.\n\nPartial determinism is going to create a bunch of weird edge cases that will be impossible to completely define.",
          "createdAt": "2021-03-19T09:51:59Z",
          "updatedAt": "2021-03-19T09:51:59Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "That of course depends on the semantics of the nodelist.  If, as I'm assuming, it is sequence-preserving, you cannot arrive at [0, 2, 1, 3], which would be (JSON pointer syntax, I'm lazy) /a/c, /b/e, /a/d, /b/f.",
          "createdAt": "2021-03-19T09:57:30Z",
          "updatedAt": "2021-03-19T09:57:30Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "This is quite a complicated discussion. I'm trying to sum things up:\r\n\r\n* JSON objects as maps are unordered by nature.\r\n* Due to that,  JSONPath query results are non-deterministic regarding their order &ndash; which is common sense here.\r\n* But determinism i.e. reproducability of JSONPath query results is required for compliance tests.\r\n* Now implementations usually return query results as an array &ndash; pragmatically JSON in ... JSON out.\r\n* JSON arrays are ordered by nature, which might falsy signal determinism of results.\r\n* So calling the result a \"node-list\" might help here out, but introduces another level of complexity in terms and their usage.\r\n\r\nHaving understood, that determinism is solely required for compliance testing, I am not sure, how to interprete Glyn's example above. Should future compliance tests really tell about every possible valid and invalid result ordering? \r\n\r\nI am sure someone of us would be able to implement something, exactly reproducing `[0, 2, 1, 3]` as result (noone would of course). Thus it's implementation dependent.\r\n\r\nBut if we only need to insure, to always generate a single reproducable result, we can achieve this by something like ...\r\n\r\n1. Generate a list of output pathes.\r\n2. Sort it lexically or however.\r\n3. Generate the list of values from that path list &ndash; preserving order.\r\n\r\n... which we can even communicate in the draft as a recipe.\r\n\r\nRegarding \"node-list\", there is indeed in JavaScript a concept of \"array-like objects\". Those objects only need to be able to tell the list length and provide an iterator to visit all entries. Defacto dom node-lists are exactly such things. This is what above discussion also reminds me on.\r\n\r\nMaybe I still miss another important point.",
          "createdAt": "2021-03-19T10:27:02Z",
          "updatedAt": "2021-03-19T10:29:38Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": ">     * But determinism i.e. reproducability of JSONPath query results is required for compliance tests.\r\n\r\nNeither determinism of the spec nor determinism for a given JSONPath implementation are necessary for compliance tests, but non-determinism does add some complexity to testing. That said, I am in favour of non-determinism in the spec because it gives the most freedom to implementations.",
          "createdAt": "2021-03-19T10:31:27Z",
          "updatedAt": "2021-03-19T10:31:27Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> > (@glyn) But I think the following output, for example, should be invalid:\r\n> > \r\n> > * `[0, 2, 1, 3]`\r\n> \r\n> I'm curious why you think this should be invalid.\r\n\r\nBecause I would expect each \"stage\" of a selector to be evaluated in turn. In other words, the intermediate results which are output from one stage to the next can be in a non-deterministic order, but that order won't be modified by other stages as those stages are operating on the individual values from earlier stages.\r\n\r\n> I understand how you got the result, and if you include (or replace with) the paths to those values, it's just as (or more) clear.\r\n\r\nSorry, but what is more clear?\r\n\r\n> \r\n> Partial determinism is going to create a bunch of weird edge cases that will be impossible to completely define.\r\n\r\nI don't think so. I think once we have addressed the non-determinism of specific selector \"stages\" applied to objects, that's pretty much it. What you describes as \"partial determinism\" is simply a result of how the spec is constructed from small pieces in a uniform way.\r\n",
          "createdAt": "2021-03-19T10:38:49Z",
          "updatedAt": "2021-03-19T10:38:49Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear, non-determinism in the spec doesn't force implementations to be non-deterministic. But it allows implementations to trade off efficiency against non-determinism. It also allows for variations between (deterministic) implementations.",
          "createdAt": "2021-03-19T10:43:00Z",
          "updatedAt": "2021-03-19T10:43:00Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Also related to (maybe duplicates) #27.",
          "createdAt": "2021-05-12T09:00:29Z",
          "updatedAt": "2021-05-12T09:00:29Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed by #134 ",
          "createdAt": "2021-11-10T10:46:57Z",
          "updatedAt": "2021-11-10T10:46:57Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWU4Mjc4NjEzMzA=",
      "title": "Array Slice Operator",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/61",
      "state": "OPEN",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\n> Thanks! The ABNF for an array slice in that reference\r\n> ```\r\n> integer = [%x2D] (%x30 / (%x31-39 *%x30-39))\r\n>\r\n> array-slice = [ integer ] ws %x3A ws [ integer ]\r\n>                     [ ws %x3A ws [ integer ] ]\r\n>                              ; start:end or start:end:step\r\n> ```\r\n> is consistent with JMESPath, Python, and my understanding of\r\nECMASCRIPT 4.\r\n> *(Daniel P)*\r\n\r\n> Did anyone else have an opinion on the behaviour of slices such as [::0]?\r\nThe current draft allows this and says it returns an empty array, but there\r\nis good reason to say it should error so that the slice operation is then\r\nconsistent with Python slicing. See below for more context.\r\n*(Glyn Normington)*\r\n\r\nIt's good having read this thread and thus understand the current draft much better. I like the decision to be consistent with Python and also getting an empty selection set with `step=0`.\r\n\r\nFYI: there is a recent proposal for adding slice notation syntax to JavaScript, currently at stage 1 of the TC39 process.\r\n\r\nhttps://github.com/tc39/proposal-slice-notation\r\n\r\nInterestingly it won't have a step argument ...\r\n\r\nhttps://github.com/tc39/proposal-slice-notation#why-doesnt-this-include-a-step-argument-like-python-does\r\n\r\n... because of syntax collision with the new `this-binding` syntax proposal `::`\r\n\r\nhttps://github.com/tc39/proposal-bind-operator\r\n\r\nHowever, we should not let us influence by this.\r\n",
      "createdAt": "2021-03-10T14:52:26Z",
      "updatedAt": "2021-03-10T14:58:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Slightly more readable version of the ABNF, as is now in -base-00:\r\n\r\n```\r\n   integer = [\"-\"] (\"0\" / (DIGIT1 *DIGIT))\r\n                               ; optional - followed by 0 or\r\n                               ; sequence of digits with no leading zero\r\n   DIGIT =  %x30-39                  ; 0-9\r\n   DIGIT1 = %x31-39            ; non-zero digit\r\n\r\n\r\n   array-slice = [ start ] ws \":\" ws [ end ]\r\n                      [ ws \":\" ws [ step ] ]\r\n   start = integer\r\n   end = integer\r\n   step = integer\r\n```\r\n",
          "createdAt": "2021-03-10T14:58:14Z",
          "updatedAt": "2021-03-10T14:58:32Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU4Mjc4NjI0NDc=",
      "title": "Error Handling",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/62",
      "state": "OPEN",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\n> My mental model at the moment is that a JSONPath expression can be valid or erroneous; application of a valid expression yields a result (which may be empty), but does not raise errors.  That may not be the right model for all applications.\r\n*(Carsten Bormann)*\r\n\r\n> The  general approach that I've seen several times (including my\r\nElixir implementation) is that an error is raised when there is a\r\nsyntax error, therefore an invalid expression (e.g. $.foo[[5]) raises\r\nan error. Conversely a valid expression applied to a bogus input never\r\nraises an error (e.g. `$.foo.bar on \"test\" evals as []`).\r\n*(Davide Bettio)*\r\n\r\n> On the whole I think JSONPath is designed to be \"forgiving\", i.e. such things aren't errors, e.g. I think I read in the spec that filtering a non-array isn't an error, it's some kind of no-op. That approach isn't always best for everyone, but it's important to be consistent.\r\n*(Michael Kay)*\r\n\r\n> I would expect one component of this policy to be:\r\n>\r\n> Whether a JSONPath query is valid or not does not depend on the arguments it is applied to.\r\n>\r\n> I.e., you can look at the query and find out independently, without knowing any data, whether it is valid or not.\r\n*(Carsten Bormann)*\r\n\r\nI like and totally agree with the *forgiving mental model*, so having  only syntax errors, which do not dependent on data.\r\n",
      "createdAt": "2021-03-10T14:53:12Z",
      "updatedAt": "2021-03-10T14:53:12Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU4Mjc4NjYzOTY=",
      "title": "Respect Implementations",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/63",
      "state": "OPEN",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\n> As I mentioned in the session, I think there's a non-trivial amount of risk here that some implementations won't be willing or able to move away from their current behaviours, even if interoperability would improve if they did so. However, there are ways to mitigate that (e.g., a separate 'rfcxxxx compliant' mode). Even so, it will be important to get good participation from as many current implementers as possible.\r\n*(Mark Nottingham)*\r\n\r\n> The WG will develop a standards-track JSONPath specification that\r\nis technically sound and complete, based on the common semantics\r\nand other aspects of existing implementations.  Where there are\r\ndifferences, the working group will analyze those differences and\r\nmake choices that rough consensus considers technically best, with\r\nan aim toward minimizing disruption among the different JSONPath\r\nimplementations.\r\n*(Barry Leiba)*\r\n\r\n> I'm OK with this, but for context: I've been a pretty intense JSONPath user\r\nin recent years, and AFAIK the spec, and the implementations, are mostly\r\nOK, so the choice between \"make JSONPath good\" and \"don't invalidate\r\nimplementations\" is unlikely to come up. If it did, my predisposition would\r\nbe to err on the side of not breaking implementations, but I don't think\r\nthat's inconsistent with Barry's text.\r\n*(Tim Bray)*\r\n\r\n",
      "createdAt": "2021-03-10T14:55:51Z",
      "updatedAt": "2021-03-27T22:04:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I expect the RFC will have the tar washed off.\r\n(E.g., artifacts from specific scripting languages -- who needs those?)\r\nThis of course means that not all existing queries will work on all implementations of the standards.  \r\nThat should not come as a big surprise.",
          "createdAt": "2021-03-22T15:54:54Z",
          "updatedAt": "2021-03-22T15:54:54Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I don't know -- once the editors start to merge pull requests, and the chairs start to moderate the emerging progress, we might see the convergence materialize in the draft.\r\n",
          "createdAt": "2021-03-23T13:56:40Z",
          "updatedAt": "2021-03-23T13:56:40Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This of course means that not all existing queries will work on all implementations of the standards.\n\nI'd be surprised if any one implementation actually fully complied with the forthcoming spec.  I expect to make changes.",
          "createdAt": "2021-03-23T23:10:49Z",
          "updatedAt": "2021-03-23T23:10:49Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU4Mjc4ODMwNzY=",
      "title": "Filter Expressions",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/64",
      "state": "OPEN",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\n\r\n> Related to that, it would be helpful to determine if JSONPath filters\r\napply to both JSON objects and arrays, or only to JSON arrays.\r\n*(Daniel P)*\r\n\r\n> I would support restricting filters to arrays, if others agree.\r\n*(Glyn Normington)*\r\n\r\nI tend to let implementations and their \"normative force of the factual\" decide here or in doubt agree to Glyn's restriction to arrays.\r\n\r\nI am very unhappy with confusing `$..book[(@.length-1)]`, where `'@'` addresses the array itself and implies that array has a `length` property. In filter expression examples `'@'` more consistently addresses the current array element.\r\n\r\nThe invocation of 'the underlying scripting engine' wasn't meant a serious normative aspect, but rather a quick and dirty solution for JavaScript and PHP implementations at that time.\r\n\r\n\r\n### Corner Case\r\n\r\n> Consider this perfectly legal JSON object\r\n>\r\n> ```{ \"ab\": 0,  \"'a.b\": 1,  \"a-b\": 2, \"a\": { \"b\": 3 } }```\r\n>\r\n>So `$.ab` is 0, `$.a.b` is 3, `$['a.b']` is 1, `$['a-b']` is 2. You'd like to say `$.a-b` but lots of libraries will refuse it because `\"a-b\"` is not a legal JavaScript \"name\" construct, that's why you have to say `$['a-b']`.\r\n>\r\n> But suppose your library would accept `$.a-b`.  Then `$.a-b` and `$['a-b']` would be synonyms, but `$.a.b` and `$['a.b']` wouldn't.\r\n*(Tim Bray)*\r\n\r\nHmm ... this seems to be a hint to better exclude `'-'` from dot-child-selector syntax. I think I have read more discussion about that, currently don't know where.\r\n",
      "createdAt": "2021-03-10T15:07:12Z",
      "updatedAt": "2021-08-25T22:50:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "This actually already has an issue: #47.",
          "createdAt": "2021-03-10T18:59:30Z",
          "updatedAt": "2021-03-10T18:59:30Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this?",
          "createdAt": "2021-03-29T19:38:10Z",
          "updatedAt": "2021-03-29T19:38:10Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Filter expressions `[?(<expr>)]` are completely missing in the current draft.\r\n\r\nImplementations agree, that filter expressions are an essential feature with JSONPath. They are considered much more important than \"index expressions\" `[(<expr>)]`, given that term \"index\" is an interim synonym for \"name / index\" ([#84](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/84#issuecomment-809245242)).\r\n\r\nThere are already some discussions about filters (historically ascending):\r\n\r\n* Non-property-name-friendly chars [#16](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/16)\r\n* Query expression language support [#17](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/17)\r\n* Treating of duplicates [#23](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/23)\r\n* Security items [#25](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/25)\r\n* Filter applied to JSON object [#47](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/47)\r\n* Some observations on the 3 March 2021 draft [#56](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/56)\r\n* JSONPath expression and bracket-notation [#57](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/57)\r\n* Regular expressions in filters [#70](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/70)\r\n* The problem of comparing an evaluated expression with a json literal [#74](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/74)\r\n* The \"current value\" or \"current node\", and the meaning thereof [#76](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/76)\r\n\r\n## 1. Term \"filter expression\"\r\n\r\nThe WG still has to decide, if we want to use the term \"filter expression\" in the draft, as there are some objections against it ([#20](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/20#issue-707818524)).\r\n\r\nAs an alternative the term \"filter selector\" was proposed, which is used below.\r\n\r\n## 2. Apply Filter Selector to Objects\r\n\r\nThere seems to be no agreement, if filters should be applied to objects ([#47](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/47)).\r\n\r\nConsider a school,\r\n```json\r\n{\r\n    \"students\": [...],\r\n    \"staff\": [...],\r\n    \"teachers\": [...]\r\n}\r\n```\r\nwhile looking for the array(s) containing persons named 'M\u00fcller' by `'$[?(@..name == 'M\u00fcller')]'`, which is not the same as looking for the persons themself by `'$.*[?(@.name == 'M\u00fcller')]'`.\r\n\r\nI can see value for allowing filter selectors applied to objects and not really a rational reason to exclude them from filtering.\r\n\r\n## 3. How Filter Selectors Work\r\n\r\nFilter selectors work via iterating over arrays and objects, provided the latter is allowed by the spec. \r\n\r\n### 3.1 Selecting\r\n\r\nDuring iteration process the value of each array element or object member is taken and evaluated against an implicite boolean expression `<expr>` in `'[?(<expr)]'`. If the result is *truthy*, the item is selected. In case of a *falsy* result, it is not.\r\n\r\n### 3.2 The Current Value `@`\r\n\r\nIn expression `<expr>`, the special selector `'@'` represents the currently visited JSON value during iteration process. The most simple JSONPath expression with a filter selector is `'$[?(@)]'`, collecting all items of the related container, provided their individual value is interpreted as truthy.\r\n\r\nSpecial selector `'@'` used outside of filter selectors may have completely different meaning.\r\n\r\n## 4. Syntax\r\n\r\n### 4.1 Filter Selector Syntax\r\n\r\n```abnf\r\nfilter-selector    = \"[?(\" expr \")]\"\r\n```\r\nThere are some discussions / implementations that are leaving out the parentheses. In this case syntax reads:\r\n\r\n```abnf\r\nfilter-selector    = \"[?\" expr \"]\"\r\n```\r\nIt needs to be discussed, if the last - more minimally - syntax works in all practical cases. If it does and `expr` is allowed to contain parentheses, above original syntax would be also valid automatically.\r\n\r\n### 4.2 Filter Selector Expression Syntax\r\n\r\nImplicite boolean expression `expr` is evaluated and converted to the JSON values `true` or `false`. Selection occures in the `true` case only.\r\n\r\nGreg proposes a minimal set of basic comparison, mathematical, and boolean operators [#17](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/17):\r\n\r\n```\r\n==   equal\r\n!=   not equal\r\n<    less than\r\n<=   less than or equal to\r\n>    greater than\r\n>=   greater than or equal to\r\n\r\n+    addition\r\n-    subtraction\r\n*    multiplication\r\n/    division\r\n%    modulus\r\n\r\n&&   and\r\n||   or\r\n```\r\n\r\nTaking this set of operators, excluding arithmetic operators for now, we have something like this:\r\n\r\n```abnf\r\nexpr                = *comparisons\r\ncomparisons         = [\"(\"] comparison *[logical-operator comparison] [\")\"]\r\nlogical-operator    = \"||\" / \"&&\"\r\ncomparison          = relative-path [comparison-operator value]\r\ncomparison-operator = \"==\" / \"!=\" / \"<\" / \">\" / \"<=\" / \">=\"\r\nvalue               = number / quoted-string / true / false / null\r\nrelative-path       = \"@\" *(dot-selector / index-selector)\r\n```\r\n`dot-selector` and `index-selector` is defined elsewhere. `number`, `quoted-string` and `null` is defined analog to RFC8259.\r\n\r\n### 4.3 Arithmetic operator Extension\r\n\r\nTwo scenarios for using (binary) arithmetic operators `op` are possible.\r\n\r\n1. Use it on the left side of the comparison, i.e. `'relativ-path op (relativ-path | number)'`. Here it is implied, that values on both sides of the comparison are of type `number`. If one or both are `string` or `null` it must be decided, what to do.\r\n2. Use it on the right side of the comparison is a trivial thing for number literals and might be directly replaced by its arithmetic result.\r\n\r\nI can hardly see relevant practical use cases here and would opt for not supporting arithmetic operators at the first glance.\r\n\r\n### 4.4 `in` operator Extension\r\n\r\nAn `in` operator might be useful. Examples are\r\n\r\n```js\r\n[?(@.color in ['red','green','blue'])]\r\n[?(@.type in [1,2,4,8])]\r\n```\r\n\r\nIn fact, supporting this would be pure syntactic sugar, as it can always be replaced by\r\n\r\n```js\r\n[?(@.color == 'red' || @.color == 'green' || @.color == 'blue')]\r\n[?(@.type == 1 || @.type == 2 || @.type == 4 || @.type == 8)]\r\n```\r\nWhats your opinion? With minimalism in mind I would opt against it.\r\n\r\n### 4.5 Nested Filter Selectors\r\n\r\nGreg pointed us to an [SO question](https://stackoverflow.com/questions/67017189/jsonpath-can-not-get-the-needed-value-using-expressions). Herein an array element (an object itself) is to be selected, if and only if its subarray property contains an element having a certain index/value pair. Somewhat like\r\n\r\n```js\r\n$.arr[?(@.type == 'a' && @.subarr[?(@.prop == 'b')])]\r\n```\r\nIn this case `relative-path` in 4.2 above should be modified to\r\n\r\n```abnf\r\nrelative-path = \"@\" *(dot-selector / index-selector / filter-selector)\r\n```\r\n\r\nWhat's the general opinion here ?\r\n\r\n### 4.6 Regular expressions with Filter Selectors\r\n\r\nSee [Regular expressions in filters #70](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/70).\r\n\r\nI see usefulness here.\r\n",
          "createdAt": "2021-04-30T10:48:32Z",
          "updatedAt": "2021-04-30T10:48:32Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "First, why post here? This is a duplicate issue, as I noted.\r\n\r\n> They are considered much more important than \"index expressions\" `[(<expr>)]`...\r\n\r\n_**A**_ being \"more important\" (really meaning \"more commonly used\") than _**B**_ does not imply that _**B**_ should be excluded.\r\n\r\nThe index expression format has its uses that cannot be replicated with other mechanisms.  It should be included.",
          "createdAt": "2021-04-30T11:32:05Z",
          "updatedAt": "2021-04-30T11:51:04Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the result is truthy, the item is selected. In case of a falsy result, it is not.\r\n\r\nWe still need to define \"truthiness.\"  There is still [active discussion](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/57#issuecomment-793423011) on this topic.\r\n\r\n> `in` operator Extension\r\n\r\nI see the utility of this.  It does open up the door for other operators.  The inverse of this operator would be `contains`, e.g. `[?(@.colors contains 'red'])]`.\r\n\r\nI'm sure we can think of others.\r\n\r\n> Nested Filter Selectors\r\n\r\nWe need to address scoping.  `$` can always be used to access the root of the input value, and `@` access the \"current\" element.  But once we introduce nested filters, identifying what `@` represents gets murky.\r\n\r\nMaybe `@@` can denote the nested scope instead of just a single `@`.  This leaves the single `@` to denote the initial interated scope.  I can't imagine this would be used much, and maybe we include this functionality with a SHOULD or RECOMMENDED so that it's not a hard requirement, which will alleviate pressure on implementors.",
          "createdAt": "2021-04-30T11:48:09Z",
          "updatedAt": "2021-04-30T11:48:09Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "### Correctum: 4.5 Nested Filter Selectors\r\n\r\nAs I should have been thinking a little longer, I finally realized, that there is no need for nested filter selectors in example above ...\r\n```js\r\n$.arr[?(@.type == 'a' && @.subarr[?(@.prop == 'b')])]\r\n```\r\n... as this might be resolved conventionally by\r\n```js\r\n$.arr[?(@.type == 'a' && @.subarr[*].prop == 'b')])]\r\n```\r\nwithout nesting. I am doubtful, that significant real world examples exist, which are not resolvable without nesting.\r\nSo let's ignore that feature in the spec and leave it to implementations for now.\r\n\r\n",
          "createdAt": "2021-05-02T10:39:53Z",
          "updatedAt": "2021-05-02T10:39:53Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> > `in` operator Extension\r\n> \r\n> I see the utility of this. It does open up the door for other operators. The inverse of this operator would be `contains`, e.g. `[?(@.colors contains 'red'])]`.\r\n\r\nCan be solved without `contains` by `[?(@.colors[*] == 'red')]`.\r\n\r\nWe should take care, not inflationary inventing operators.\r\n",
          "createdAt": "2021-05-02T10:48:33Z",
          "updatedAt": "2021-05-02T10:48:33Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> We still need to define \"truthiness.\" There is still [active discussion](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/57#issuecomment-793423011) on this topic.\r\n\r\nyes, you are right. Or better define falsiness, as Daniel proposes ...\r\n\r\n> Typical conditions to determine whether an arbitrary JSON value can be considered false are:\r\n>\r\n> - empty array: [],\r\n> - empty object: {},\r\n> - empty string: \"\",\r\n> - false boolean,\r\n> - null,\r\n> - zero integer.\r\n\r\nadding ...\r\n\r\n- undefined, i.e. not existing !\r\n\r\n",
          "createdAt": "2021-05-02T10:56:03Z",
          "updatedAt": "2021-05-02T10:56:03Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can be solved without contains by `[?(@.colors[*] == 'red')]`.\n\nWhat are we saying here? `@.colors[*]` returns an array.   So you're implying that `==` functions as a `contains` operator?  That's hideous!  Operators shouldn't be overloaded like that.\n\n> Or better define falsiness, as Daniel proposes ...\n\nMy point is that I don't like the idea of loose equality at all, and I expect implementors in other strongly typed language will have the same reservations.",
          "createdAt": "2021-05-02T19:31:01Z",
          "updatedAt": "2021-05-02T19:33:01Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> \r\n> > Can be solved without contains by `[?(@.colors[*] == 'red')]`.\r\n> \r\n> What are we saying here? `@.colors[*]` returns an array. So you're implying that `==` functions as a `contains` operator? That's hideous! Operators shouldn't be overloaded like that.\r\n\r\nHmm ... what have I been thinking? You are right. It doesn't work that way, of course. I did not intend to introduce an implicit 'contains' operator.\r\n\r\nGiven this, nested filters and/or a contains operator is still worth a discussion.",
          "createdAt": "2021-05-03T15:10:32Z",
          "updatedAt": "2021-05-03T15:10:32Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Or better define falsiness, as Daniel proposes ...\r\n> \r\n> My point is that I don't like the idea of loose equality at all, and I expect implementors in other strongly typed language will have the same reservations.\r\n\r\nWe don't address implementors but ordinary users of JSONPath, which are not necessarily programmers using strongly typed languages.\r\n\r\nOk ... what exactly do equality comparisons look like then? What do you propose?",
          "createdAt": "2021-05-03T15:15:25Z",
          "updatedAt": "2021-05-03T15:15:25Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> So let's ignore [nested filter expressions] in the spec and leave it to implementations for now.\r\n\r\nI think the spec should define whether or not any given JSONPath is syntactically valid rather than leaving this up to implementations. What do others think about this general principle?\r\n\r\nAlso, I'm not sure _how_ the spec's syntax and compliance test suite could allow implementation-specific variants.\r\n\r\nThere isn't much of a [consensus](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subfilter.html) among existing implementations about the behaviour of nested filter expressions. However, [Proposal A](https://github.com/cburgmer/json-path-comparison/tree/master/proposals/Proposal_A) neatly [disallows](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subfilter.html#Proposal_A) nested filter expressions, along with certain other complicated filter expressions. OTOH, I quite like not having apparently arbitrary syntactic restrictions and so [my implementation](https://github.com/vmware-labs/yaml-jsonpath) [allows](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subfilter.html#Golang_github.com-vmware-labs-yaml-jsonpath) nested filter expressions.\r\n\r\n",
          "createdAt": "2021-05-04T02:24:29Z",
          "updatedAt": "2021-05-04T02:24:29Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ok ... what exactly do equality comparisons look like then? What do you propose? - @goessner \n\nDoing loose equality in a strongly-typed system is a serious pain.  However, strict equality in a loosely-typed system is generally easy. For example, JS uses the `===` operator to facilitate this.  I realize that my opinion is biased, but I speak from (recent) experience of having to do the former.\n\n> I think the spec should define whether or not any given JSONPath is syntactically valid rather than leaving this up to implementations. - @glyn \n\nDefinitely, yes, the spec should be as precise and prescriptive as possible on what it covers.  However, I do think that it does need to allow for implementations to expand on the domain in order to foster new syntaxes and ideas, so long as those implementations call out those deviations as non-standard.\n\nI think the spec _should_ define its support for nested queries, even if it's to say they're not supported.  I also think that it should support index queries.\n\nHowever, I recognize that it says _nothing at all_ in regard to expressions currently, and I'm on board with getting _something_ in place to cover the things we at least agree on right now so long as it's done in a way to leave the door open to incorporate these other features after we've discussed them further.",
          "createdAt": "2021-05-04T08:00:54Z",
          "updatedAt": "2021-05-04T08:01:28Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "The spec should be well-defined, but also provide extension points -- both for third parties to use and for evolution of the spec itself.\r\n",
          "createdAt": "2021-05-04T08:36:17Z",
          "updatedAt": "2021-05-04T08:36:17Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Allowing non-scalar comparisons in filter expressions leads to some weirdness. For example, the `>` operator is no longer [total](https://en.wikipedia.org/wiki/Total_order).\r\n\r\nBackground: https://github.com/vmware-labs/yaml-jsonpath/issues/31\r\nDetailed example: https://github.com/vmware-labs/yaml-jsonpath/issues/3\r\n\r\nThe JSONPath comparison project has a couple of relevant examples:\r\n* https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_set_wise_comparison_to_scalar.html\r\n* https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_set_wise_comparison_to_set.html\r\n\r\nI would prefer the spec to disallow non-scalar comparisons. Christoph Burgmer found a neat way to disallow this in the [grammar of Proposal A](https://github.com/cburgmer/json-path-comparison/tree/master/proposals/Proposal_A#grammar).",
          "createdAt": "2021-05-11T11:05:57Z",
          "updatedAt": "2021-05-11T11:05:57Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Found a [StackOverflow question](https://stackoverflow.com/q/68020301/878701) where the OP is looking to use a unary `!` to negate a user-supplied expression.\n\n```\n$[?(!(<expr>))]\n```",
          "createdAt": "2021-06-24T21:49:06Z",
          "updatedAt": "2021-06-24T21:50:40Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": ".. interesting, why he refuses to use `x!=y` instead. We do need logical \nnot-operator `!` not only for completeness, but also as an explicit \ncomplementary for implicit existence test (undefined).\n\n\nAm 24.06.2021 um 23:49 schrieb Greg Dennis:\n>\n> Found a SO question <https://stackoverflow.com/q/68020301/878701> \n> where the OP is looking to use a unary |!| to negate a user-supplied \n> expression.\n>\n> |$[?(!(<expr>))] |\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/64#issuecomment-867973884>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABFM6WSQPEG5YQJPHDREVMLTUOR5XANCNFSM4Y6GZMWA>.\n>\n>\n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n> \tVirenfrei. www.avg.com \n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n>\n>\n> <#DAB4FAD8-2DD7-40BB-A1B8-4E2AA1F9FDF2>\n\n",
          "createdAt": "2021-06-25T06:24:13Z",
          "updatedAt": "2021-06-25T06:24:13Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "If you look at the rest of the post, he shares his code where you can see that he's literally just interpolating user input into the expression and using the negation operator to invert the filter.\n\nThis is why he says the `!=` doesn't work for him.  I suppose he could do something like `<expr> == false`, but that's kinda weird, too.",
          "createdAt": "2021-06-25T07:02:38Z",
          "updatedAt": "2021-06-25T07:02:38Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "We received an [SO question](https://stackoverflow.com/q/68432349/878701) that works be helped by the `in` operator, but the other direction.\n\nThe asker wants a path that can identity paths to arrays that contain two values.  Such a query could be\n\n```\n$[?('PERSON A' in @ && 'PERSON B' in @)]\n```\n\nreturning paths instead of values (so they can get the keys).\n\nThis iterates over the values in the top-level object (which are themselves arrays) and uses the `in` operator to determine if specific values are in the arrays.",
          "createdAt": "2021-07-18T21:26:50Z",
          "updatedAt": "2021-07-18T21:32:51Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's another SO question that would benefit from nested expressions.\n\nhttps://stackoverflow.com/q/68926463/878701",
          "createdAt": "2021-08-25T22:50:19Z",
          "updatedAt": "2021-08-25T22:50:19Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU4Mjc4ODg1NDk=",
      "title": "XPath References",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/65",
      "state": "CLOSED",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\n> I wonder if the analogies between XPath and JSONPath are going to be helpful, or whether they're actually dangerous by implying equivalences between constructs that are in fact somewhat different?\r\n*(Michael Kay)*\r\n\r\n> I tend to agree. Although JSONPath was inspired by XPath, I wouldn't\r\nwant to confuse the JSONPath spec by going into detailed comparisons at\r\nthe risk of contradicting the normative text.\r\n*(Glyn Normington)*\r\n\r\n> Someone on StackOverflow today asked a question about JSONPath; they called it (and tagged it) XPath, we really don't want that kind of confusion.\r\n>\r\n> In addition, the reference to the XPath specification in 6.2 is out of date, and the comparison with XPath in Table 2 is very approximate and the terminology inaccurate: for example there is a mention of \"node sets\", which exist in XPath 1.0 but not in XPath 2.0, yet the citation is to XPath 2.0. For someone who knows the semantics of XPath the comparison raises all sorts of questions about sorting of results into document order, elimination of duplicates etc, which are complications this spec can well do without. (Though some answers are needed, for example if ..store..price matches the same price in more than one way, do you get more than one result? And if not, what does \"the same price\" actually mean?)\r\n*(Michael Kay)*\r\n\r\nIt seemed to be important in 2007, while argumenting to have something like XPath for JSON. If nowadays the terminology used has changed significantly with XPath 2.0 and 3.0, we better leave that comparison table 2 out. I am quite passionless here.\r\n\r\nAt the IETF 110 meeting consensus was raised that inclusion of XPath in the Appendix section would be the most appropriate way to reference to it.",
      "createdAt": "2021-03-10T15:10:58Z",
      "updatedAt": "2021-11-09T21:05:08Z",
      "closedAt": "2021-11-09T21:05:07Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed in #129 ",
          "createdAt": "2021-11-09T21:05:07Z",
          "updatedAt": "2021-11-09T21:05:07Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU4MjgxNTAzMDY=",
      "title": "Clarification on Terminology",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/66",
      "state": "CLOSED",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has PR"
      ],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\n> My own view is that the terminology should stay consistent with RFC\r\n8259, and that the word \"object\" should not be used for items that are\r\nnot JSON objects in the sense of RFC 8259.\r\n*(Daniel P)*\r\n\r\n> To Carsten's point about what we call things, the number of distinguished\r\nterms per RFC8259 is pretty small: JSON text, value, object, array, number,\r\nstring.  Having spent quite a bit of time specifying JSON DSLs, I find that\r\nusing just those terms doesn't seem to get in the way or cause problems, so\r\nI'd argue that we should stick to them (and build up to higher-level\r\nconstructs as required for JSONPath).\r\n>\r\n> \u2026 oh, and I forgot the very useful \"member\".\r\n*(Tim Bray)*\r\n\r\n> \u2026 and \u201celement\u201d (the things in arrays). *(Carsten Bormann)*\r\n\r\n> The problem with JSON value is that it also can be quite confusing due to the usual use of that term.  Pointing to a tree and saying \u201cthe values inside that tree\u201d is not going to be felt as equivalent to \u201cthe set of all subtrees of that tree, including the tree itself\u201d.  But if JSON value is the only term we have, it has to be.  Hence my preference to talk about data items when I mean the items themselves and not their \u201cvalue\u201d.\r\n*(Carsten Bormann)*\r\n\r\n> I think the key difficulty is whether each (key, value) pair in an object is \"a thing\" that can be identified and manipulated and potentially returned. (If we're talking analogies, then it's analogous to an attribute node in the XDM model).\r\n*(Michael Kay)*\r\n\r\n> ECMA-404 uses \"name/value pair\", which is what I understand the term\r\n\"member\" to mean (Douglas Crockford uses \"member\").\r\n*(Daniel P)*\r\n\r\n> I think the term \u201cunion\u201d is poor. If we think of it as concatenation of results, then the result is as expected.\r\n*(Glyn Normington)*\r\n\r\nI understand, that within RFC8259 we have JSON values of different types. They are structured somehow, which is not so much of interest here.\r\n\r\nBut while querying that structure with JSONPath it is vitally important to identify that hierarchical structure as a tree. So in fact we build up a higher-level construct here. We also need to call \"the things\" in the tree somehow. I was able to identify\r\n\r\n* \"node\" or \"item\" of a tree\r\n* \"member\" of an object\r\n* \"name/value\" or \"key/value\" pair alias \"member\"\r\n* \"element\" of an array\r\n\r\nbut could not see an agreement here.\r\n\r\nI agree to Glyn calling the term \"union\" poor (s. below).\r\n",
      "createdAt": "2021-03-10T18:18:40Z",
      "updatedAt": "2021-03-23T19:33:52Z",
      "closedAt": "2021-03-23T15:46:09Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Also relates to #21.",
          "createdAt": "2021-03-10T19:10:01Z",
          "updatedAt": "2021-03-10T19:10:01Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "Until the early discussions on the jsonpath list, I thought more about value selection, I hadn't really thought much about nodes, or appreciated the importance of paths for identity (duplicate removal) and sorting, if the user wanted that. But having changed my thinking based on those conversations, I'd like to understand better what exactly a node represents in JSONPath. \r\n\r\nIn XML, we have the DOM, and DOM nodes. But in JSON we don't really have anything like that. I don't find it natural to think about a \"tree of nodes\" in the context of JSONPath. The implementations I know about don't have a tree, they don't identify location by the position in a tree, rather, they operate on path/value pairs.\r\n\r\nFor example, looking at the slice operator code in [David Chester's Node.js implementation](https://github.com/dchester/jsonpath/)\r\n```\r\n'subscript-child-slice': function(component, partial) {\r\n    if (is_array(partial.value)) {\r\n      var args = component.expression.value.split(':').map(_parse_nullable_int);\r\n      var values = partial.value.map(function(v, i) { return { value: v, path: partial.path.concat(i) } });\r\n      return slice.apply(null, [values].concat(args));\r\n    }\r\n  }\r\n```\r\nthere is no tree, just a selected value and an updated path. That's typical I think of many implementations.\r\n\r\nWould it be better to talk about a node as a path-value pair, rather than a node in a tree? ",
          "createdAt": "2021-03-10T20:17:14Z",
          "updatedAt": "2021-03-10T20:40:46Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "For me, regarding a JSON value as a tree isn't an implementation consideration - it's an observation about the abstract structure of the data. Similarly, the notion of the position (or perhaps location) of a node in the tree is just an abstract way of identifying where the node is in the tree.\r\n\r\nA path is one implementation of the abstract notion of position, but not the only one. I think in the spec we should try to avoid implementation bias and speak of positions rather than paths, references, or pointers, all of which bring to mind implementations.\r\n\r\nIt's unfortunate that (general) trees are also common data structures and maybe that's part of the problem here. But in reality, we also have binary trees, AVL trees, splay trees, B-trees, etc., so I try to think of a general tree data structure as just one way of implementing an abstract tree.\r\n\r\nDoes that help at all?",
          "createdAt": "2021-03-10T20:50:44Z",
          "updatedAt": "2021-03-10T20:50:44Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@glyn wrote:\r\n\r\n> For me, regarding a JSON value as a tree isn't an implementation consideration - it's an observation about the abstract structure of the data. Similarly, the notion of the position (or perhaps location) of a node in the tree is just an abstract way of identifying where the node is in the tree.\r\n\r\nOkay. So we want to talk about abstract input, abstract output. Tree of nodes in, tree of nodes out. It would be really helpful if you could answer two questions.\r\n\r\nQuestion 1: What is a node in JSONPath? What are its properties?\r\n\r\n\"node\" appears 60 times in the draft, but I only found two mentions of what a node is. In section 3.2, it says \"Each node _holds_ a JSON value\" (emphasis added). And then there is \"root node which _is_ the input document\" (emphasis added.)\r\n\r\nI'm assuming (please correct me if I'm wrong), that a JSON value as defined in RFC8259 _cannot_ itself be considered a \"tree of nodes\". It's a hierarchy of values, not nodes that _contain_ values.\r\n\r\nWhat are the properties of a node? We're told it holds a JSON value. What else does it hold?\r\n\r\n- Does a node provide access to its parent node, like a DOM Node does?\r\n- Does a node provide access to its associated key, or index?\r\n\r\nQuestion 2: How do we interpret \"root node which _is_ the input document\"\r\n\r\nThe term \"input document\", is that a real thing? Actual JSON data? No nodes?\r\n\r\nDoes the draft really mean that the root node _is_ the input document? Or that it _represents_ the input document?\r\n\r\nSuppose the input document is \r\n```\r\n[{\"foo\":1, \"bar\":2}]\r\n```\r\nWhat value does the root node contain? `[{\"foo\":1, \"bar\":2}]`?\r\n\r\nApologies for questions that must seem self evident to you, but I don't have any experience with nodes in the context of JSON.\r\n\r\nThanks,\r\nDaniel\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-03-10T22:55:27Z",
          "updatedAt": "2021-03-10T22:56:25Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "The draft defines Position, In section 1.1, as follows:\r\n\r\n\"A JSON data item identical to or nested within the JSON data item to which the query is applied to, expressed either by the value of that data item or by providing a Normalized Path Expression as a JSONPath Output Path.\"\r\n\r\nI think this needs to be clearer.\r\n\r\nIt would be easier to read if the phrase \"the JSON data item to which the query is applied to\" was replaced by a single term defined earlier, perhaps root, or whatever term the authors choose to use consistently that means the same thing.\r\n\r\nThe statement that position can be expressed \"by the value of that data item\" is not clear. What is its intended meaning? A \"data item\" is said earlier to be the the same as a \"JSON value\". I don't understand how \"position\" can be expressed as the value of that item. Is it its location within the data item? Particularly when the alternative is \"a Normalized Path Expression as a JSONPath Output Path\".\r\n\r\nI think it would be easier to read the sentence if \"Normalized Path Expression as a JSONPath Output Path\" was replaced by \"Output Path\", which is defined earlier.\r\n\r\n\r\n  \r\n\r\n\r\n",
          "createdAt": "2021-03-11T13:18:28Z",
          "updatedAt": "2021-03-11T13:25:51Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> Question 1: What is a node in JSONPath? What are its properties?\r\n> \r\n> \"node\" appears 60 times in the draft, but I only found two mentions of what a node is. In section 3.2, it says \"Each node _holds_ a JSON value\" (emphasis added). And then there is \"root node which _is_ the input document\" (emphasis added.)\r\n> ...\r\n> Question 2: How do we interpret \"root node which is the input document\"\r\n\r\nI agree, \"node\"  is an important term to define clearly. Pragmatically quoting [Wikipedia](https://en.wikipedia.org/wiki/Tree_%28data_structure%29) as not being a computer scientist gives:\r\n\r\n> A node is a structure which **may contain a value** or condition, **or represent a separate data structure** (which could be a tree of its own).\r\n\r\nWith this, for me \"node\" is either a primitive JSON value **or** a JSON container &ndash; array or object &ndash; as a possibly empty subtree.  Nodes are either named or indexed; thus have a unique tree location. Leaf nodes are either primitive values or empty containers. There is always a root node.\r\n\r\nWhat do you think &ndash; I'm not an expert with \"abstract data types\".",
          "createdAt": "2021-03-11T13:19:56Z",
          "updatedAt": "2021-03-11T13:19:56Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "A node is an item (a term we have defined), with an emphasis on this item possibly being a specific part of a bigger item.\r\n(Add same instance vs. equal value discussion here.)\r\n",
          "createdAt": "2021-03-11T13:21:14Z",
          "updatedAt": "2021-03-11T13:21:14Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh well: \"(Data) item\" == \"JSON value\" == \"node\". Maybe we should make that triple equivalence explicit.",
          "createdAt": "2021-03-11T13:32:00Z",
          "updatedAt": "2021-03-11T13:32:00Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> Oh well: \"(Data) item\" == \"JSON value\" == \"node\". Maybe we should make that triple equivalence explicit.\r\n\r\nData item and JSON value, as defined in the draft, are crystal clear. \r\n\r\nBut it isn't stated in the text of the draft that \"node\" == \"JSON value\". It's stated that \"Each node _holds_ a JSON value\", and \"the JSON value _held_ by a node \" (emphasis added). My reading of that text is that a node _boxes_ a JSON value ( and possibly has additional attributes, such as location information if the JSON value is a descendent of the root.) \r\n\r\nAlso consider that a reader seeing the term \"node\" may have a priori understanding of the term by analogy to DOM nodes, where it's possible to navigate back to the root from any child node.  \r\n\r\nNote that my concern is with what the text says, what the authors intended, and the alignment thereof. I'm less concerned with any particular resolution.",
          "createdAt": "2021-03-11T13:47:09Z",
          "updatedAt": "2021-03-11T14:41:41Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "So we now have (bold terms added):\r\n\r\n| Term | Description |\r\n|----|----|\r\n| Data Item |  A structure complying to the generic data model of JSON, i.e.,   composed of containers, namely JSON objects and arrays, and of atomic data, namely null, true, false, numbers, and text strings.  Also called a JSON value. |\r\n| Object | A JSON object as defined in {{-json}}  Never used in its generic sense, e.g., for programming language objects. |\r\n| **Array** | A JSON array as defined in {{-json}}  Never used in its generic sense, e.g., for programming language arrays. |\r\n| Member | A name/value pair in a JSON object.  (Not itself a JSON value.) |\r\n| Name | The name in a name/value pair constituting a member.  (Also known as  \"key\", \"tag\", or \"label\".) |\r\n| Element | An item in an array.  (Also used with a distinct meaning in XML context for XML elements.) |\r\n| Query | Short name for JSONPath expression. |\r\n| Argument | Short name for the JSON data item a JSONPath expression is applied to. |\r\n| Output Path | A simple form of JSONPath expression that identifies a Position by  providing a query that results in exactly that position.  Similar  to, but syntactically different from, a JSON Pointer {{-pointer}}. |\r\n| Position | A JSON data item identical to or nested within the JSON data item to which the query is applied to, expressed either by the value of that data item or by providing a Normalized Path Expression as a JSONPath Output Path. |\r\n| Normalized Path Expression | A query in a normalized form that identifies exactly one Position in  an Argument; see {{overview}} |\r\n\r\nLiving table ... Please edit.",
          "createdAt": "2021-03-11T15:06:21Z",
          "updatedAt": "2021-03-11T16:41:19Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Why not simply *Normalized Path* instead of *Normalized Path Expression*, since an *Output Path* is always a *Normalized Path* ?",
          "createdAt": "2021-03-11T15:13:06Z",
          "updatedAt": "2021-03-11T15:13:06Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner  wrote:\r\n> \r\n> With this, for me \"node\" is either a primitive JSON value **or** a JSON container \u2013 array or object \u2013 as a possibly empty subtree. Nodes are either named or indexed; thus have a unique tree location. Leaf nodes are either primitive values or empty containers. There is always a root node.\r\n> \r\n> What do you think \u2013 I'm not an expert with \"abstract data types\".\r\n\r\nWhat my question really comes down to, considering both \"JSON value\" and \"node\" as abstract entities, is this:\r\n\r\nIs this abstract operation defined in one or both cases:\r\n```\r\n(1) parent(JSON-value)\r\n\r\n(2) parent(node)\r\n```\r\nFor (1), my expectation is \"no\", since JSON values are generally regarded in JSON specifications as self-contained. Using RFC 6901 terminology, a \"specific value\" extracted from a \"JSON document\" has no connection anymore to the original \"JSON document\".\r\n\r\nFor (2), my expectation is \"yes\", by analogy to the DOM and DOM nodes. \r\n\r\nMore generally, are there _any_ abstract operations defined on \"node\" that are not also defined on \"JSON value\"?\r\n\r\nIf the answer is no, than introducing the term \"node\" serves no purpose.  ",
          "createdAt": "2021-03-11T15:33:39Z",
          "updatedAt": "2021-03-11T15:37:48Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I don't think we should use \"JSON value\"; we have the term \"item\" for that.\r\n\"node\" means exactly the same, so we don't need it.  \r\nIn the same way that you don't need both the term \"flophouse\" and \"hotel\".\r\nI believe \"node\" is a good term when the emphasis is on the position that item has on a tree.\r\n",
          "createdAt": "2021-03-11T15:55:01Z",
          "updatedAt": "2021-03-11T15:55:01Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> @glyn wrote:\r\n> \r\n> > For me, regarding a JSON value as a tree isn't an implementation consideration - it's an observation about the abstract structure of the data. Similarly, the notion of the position (or perhaps location) of a node in the tree is just an abstract way of identifying where the node is in the tree.\r\n\r\n> \r\n> Okay. So we want to talk about abstract input, abstract output. Tree of nodes in, tree of nodes out.\r\n\r\nFor the whole selector, the input is a JSON value which can be thought of abstractly as a tree of nodes, but the output is a sequence of JSON values each of which can be thought of as a subtree of the input tree.\r\n\r\n> It would be really helpful if you could answer two questions.\r\n> \r\n> Question 1: What is a node in JSONPath? What are its properties?\r\n\r\nIf you're not familiar with trees and nodes, Wikipedia gives a reasonable definition of [trees](https://en.wikipedia.org/wiki/Tree_(data_structure) - see the terminology section for \"node\". However, that page is about data structures, so is not particularly abstract. The page on [Tree structure](https://en.wikipedia.org/wiki/Tree_structure) may be more helpful.\r\n\r\n> \r\n> \"node\" appears 60 times in the draft, but I only found two mentions of what a node is. In section 3.2, it says \"Each node _holds_ a JSON value\" (emphasis added). And then there is \"root node which _is_ the input document\" (emphasis added.)\r\n> \r\n> I'm assuming (please correct me if I'm wrong), that a JSON value as defined in RFC8259 _cannot_ itself be considered a \"tree of nodes\". It's a hierarchy of values, not nodes that _contain_ values.\r\n\r\nA JSON value can be considered as a tree of nodes. A JSON literal corresponds to a single node with value equal to the literal. A sequence corresponds to a node whose children (indexed by position in the sequence) correspond to the values of the sequence. An object corresponds to a node whose children (indexed by name in the object) correspond to the values of the object.\r\n\r\n> \r\n> What are the properties of a node? We're told it holds a JSON value. What else does it hold?\r\n\r\nI think it's probably better to talk of a JSON value corresponding to the tree rooted in a node.\r\n\r\nFor literals, the node holds the type and value of the literal. For sequences or objects, the node holds just the number of children or their names, respectively.\r\n\r\n> \r\n>     * Does a node provide access to its parent node, like a DOM Node does?\r\n\r\nEvery node except the root node _has_ a parent. I don't think it \"provides access\" to anything, because this is an abstraction rather than a programming construct.\r\n\r\n> \r\n>     * Does a node provide access to its associated key, or index?\r\n\r\nNo, a node doesn't know its key or index - that's the concern of its parent.\r\n\r\n> \r\n> \r\n> Question 2: How do we interpret \"root node which _is_ the input document\"\r\n> \r\n> The term \"input document\", is that a real thing? Actual JSON data? No nodes?\r\n\r\nThe input document is JSON data and is also a JSON value. It corresponds to a tree of nodes as outlined above.\r\n\r\n> \r\n> Does the draft really mean that the root node _is_ the input document? Or that it _represents_ the input document?\r\n\r\nProbably \"represents\" is closest. I used the word \"corresponds\" above because I have in mind a mapping from the JSON value to a tree of nodes.\r\n\r\n> \r\n> Suppose the input document is\r\n> \r\n> ```\r\n> [{\"foo\":1, \"bar\":2}]\r\n> ```\r\n> \r\n> What value does the root node contain? `[{\"foo\":1, \"bar\":2}]`?\r\n\r\nThe tree in this case is something like this:\r\n```\r\n                                   sequence\r\n                                      | 0\r\n                                    object\r\n                             foo  /      \\  bar\r\n                               1           2\r\n```\r\n\r\n> \r\n> Apologies for questions that must seem self evident to you, but I don't have any experience with nodes in the context of JSON.\r\n> \r\n> Thanks,\r\n> Daniel\r\n\r\n",
          "createdAt": "2021-03-11T16:02:28Z",
          "updatedAt": "2021-03-11T16:04:32Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think we should use \"JSON value\"; we have the term \"item\" for that.\r\n\r\nIs this a hint to rename \"data item\" to \"item\"?\r\n\r\n> \"node\" means exactly the same, so we don't need it.\r\n> In the same way that you don't need both the term \"flophouse\" and \"hotel\".\r\n> I believe \"node\" is a good term when the emphasis is on the position that item has on a tree.\r\n\r\nok ... \"node\" is self-explaining in the tree context, so I will delete it from the terms list.\r\n",
          "createdAt": "2021-03-11T16:40:53Z",
          "updatedAt": "2021-03-11T16:40:53Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-11, at 17:41, Stefan Goessner ***@***.***> wrote:\n> \n> \n> I don't think we should use \"JSON value\"; we have the term \"item\" for that.\n> \n> Is this a hint to rename \"data item\" to \"item\"?\n\nData item is just the long form.\n\n> \"node\" means exactly the same, so we don't need it.\n> In the same way that you don't need both the term \"flophouse\" and \"hotel\".\n> I believe \"node\" is a good term when the emphasis is on the position that item has on a tree.\n> \n> ok ... \"node\" is self-explaining in the tree context, so I will delete it from the terms list.\n\nI still think we should have a terminology entry (or add it to the \u201citem\u201d entry).\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-11T16:43:02Z",
          "updatedAt": "2021-03-11T16:43:02Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> @glyn wrote:\r\n> \r\n> > ```\r\n> > * Does a node provide access to its parent node, like a DOM Node does?\r\n> > ```\r\n> \r\n> Every node except the root node _has_ a parent. I don't think it \"provides access\" to anything, because this is an abstraction rather than a programming construct.\r\n> \r\nJust to note, abstractions are defined by their properties. It's meaningless to talk about an abstraction without enumerating their properties, much as it would be meaningless to talk about an Abelian Group or a Hilbert Space without enumerating their properties. So I think asking whether a node supports a property \"parent\" is meaningful. My own view is that it would be helpful to define \"node\" succinctly in the terminology section, with its properties briefly mentioned.  Then those properties can be referred to later in the draft when specifying how to go from a node to a Normalized Path or an item. \r\n\r\nI don't think its necessary to talk about a \"tree of nodes\", which is a less abstract concept; it is enough to define node, and identify its properties. \"tree of nodes\" suggests an arrangement of data that is never found in actual implementations, \"node\" by itself doesn't have that connotation. It's properties are all that matter.",
          "createdAt": "2021-03-11T17:39:26Z",
          "updatedAt": "2021-03-11T18:29:13Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think it's necessary for a node to \"know\" about its parent.\r\n\r\nI personally think it's easier to talk about a tree of nodes rather than a node in isolation. The tree structure is implicit in the way JSON is structured.\r\n\r\nAnyway, I feel we are talking somewhat at cross-purposes, but do you think we are converging on a common understanding yet?",
          "createdAt": "2021-03-11T18:30:14Z",
          "updatedAt": "2021-03-11T18:30:14Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> The implementations I know about don't have a tree, they don't identify location by the position in a tree - @danielaparker \n\nThis is precisely how every .net solution I've seen/created works.\n\nAlso, seconding everything that @glyn [said](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/66#issuecomment-796844525).  (I was building such a response, but I upon reading it, I figured the horse was dead enough.)\n\nRegarding access to parents, I'd like to call out that the Newtonsoft parser results in a tree of items that do have such access, while the newer in-built System.Text.Json parser results in a tree of items that _do not_ have access.\n\n_**NOTE** These are represented by .Net classes internally, so naturally they have some extended properties besides the JSON value.  The point here is that one points back to the parent while the other doesn't. Therefore it's completely up to the implementation/parser to determine how it wants to model the JSON internally.  JSON doesn't define how or whether such access should be supported.  It's just a data structure._\n\nAdditionally, `@handrews` (he's on sabbatical, so I don't want to tag him) has released [Relative JSON Pointers](https://tools.ietf.org/id/draft-handrews-relative-json-pointer-00.html) as an extension to the base JSON Pointers spec where the first action is to navigate _up_ the tree before dereferencing the rest of the pointer.  This spec assumes nothing of \"nodes\" that contain any metadata or their navigability.  It's just considering the structure as a tree of values.",
          "createdAt": "2021-03-11T19:58:04Z",
          "updatedAt": "2021-03-11T19:58:24Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just read the current draft carefully and was left unconvinced that the term \"node\" needs to be used.  In particular, consider the nice example in section 3.5. I went through that and it seems to me that every instance of \"node\" could be replaced by \"JSON Value\" and be accurate, because I think every bit of the instance discussed there is a JSON value. \r\n\r\n(If we were going to do this, we should probably have a terminology note that \"Value\" means \"JSON Value\", just for brevity and readability.)\r\n\r\nAre there other places in the spec where the use of the term \"node\" is necessary for accuracy or clarity?  \r\n\r\nTo test my hypothesis, I'll create a PR that updates section 3.5 to (hopefully) support my point.   But if someone has a strong argument why we need to invent new terminology, I'd be happy to avoid the effort.",
          "createdAt": "2021-03-22T19:00:12Z",
          "updatedAt": "2021-03-22T19:00:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "There is no doubt that the draft could be made to work by calling the things \"mugs\".  One can adapt to anything.\r\n\r\nValue is a particularly bad term to use here because it focuses on the valueness, i.e., comparison by value.  Nodes focus on the place, the position, in the tree, i.e., comparison by identity.  Again, the draft can be written in a way that makes the reader make that distinction on their own, but that is not a good way to do tech doc.\r\n\r\nWhy don't the terms from 8259 suffice?  8295 defines a JSON text, not its processing.  It is rather natural that once processing is added, new terms are added, too.",
          "createdAt": "2021-03-22T20:06:26Z",
          "updatedAt": "2021-03-22T20:06:42Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "(Of course, I don't have a strong argument for why we need to \"invent\" \"new\" terminology; I think the term \"node\" has been used before.  Jeez.)",
          "createdAt": "2021-03-22T20:20:36Z",
          "updatedAt": "2021-03-22T20:20:36Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote:\r\n\r\n> There is no doubt that the draft could be made to work by calling the things \"mugs\". One can adapt to anything.\r\n> \r\n> Value is a particularly bad term to use here because it focuses on the valueness, i.e., comparison by value. Nodes focus on the place, the position, in the tree, i.e., comparison by identity. Again, the draft can be written in a way that makes the reader make that distinction on their own, but that is not a good way to do tech doc.\r\n> \r\nConsider the evaluation of a JSON document that produces a JSON array of JSON values,\r\n\r\nJSON = jsonPath(JSON, JSONPath-expression, value-option)\r\n\r\nThis is the most common case, and the entirety of the cburgmer JSONPath Comparisons is devoted to it. \r\n\r\nI believe an implementation could match all of the consensus results, and where no consensus exists, the largest minority result, with doing nothing more than starting with a JSON value and working down through its children, without accumulating paths, and without concerning itself with identity. I note that the consensus is [duplicates allowed](https://cburgmer.github.io/json-path-comparison/results/union_with_duplication_from_array.html) (32 out of 41 implementations); with duplicates, there are issues with identity, but without, there are not.  \r\n\r\nNow consider the evaluation of a JSON document that produces a JSON array of Normalized Paths,\r\n\r\nJSON = jsonPath(JSON, JSONPath-expression, path-option)\r\n\r\nIn terms of the processing model, in the case of duplicates allowed, not much is different, except that in addition to selecting a value at each step, a corresponding path needs to be accumulated. The paths are simply accumulated, we don't do anything with them, we compute them along with the values, and we return a JSON array of them. At every step, the \"current value\" corresponds to an accumulated path, these two exist as a pair, so I think it makes sense to refer to that pair as a \"node\". \r\n\r\nIn the output, a path will be represented as a \"string\". In the processing model, it need not be, we can talk about a \"context position\" if you like, but conceptually it's a path.\r\n\r\nFor either the value or path option, it's in the minority position of \"no duplicates\" that things become interesting, where identity matters. But identity can be determined entirely by paths. Duplicate path-value pairs are straight forward to exclude.\r\n\r\nOf course, other processing models that result in no duplicates are interesting to look at also. \r\n\r\n> Why don't the terms from 8259 suffice? 8295 defines a JSON text, not its processing. It is rather natural that once processing is added, new terms are added, too.\r\n\r\nYes, but it seems to me that the items upon which the processing model operate should be from 8259. New terms shouldn't be introduced gratuitously.\r\n\r\nDaniel\r\n\r\n",
          "createdAt": "2021-03-22T21:27:15Z",
          "updatedAt": "2021-03-22T21:27:15Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> Yes, but it seems to me that the items upon which the processing model operate should be from 8259. \r\n\r\nSo why are you talking about JSON documents, paths, children, etc.?\r\n\r\n> New terms shouldn't be introduced gratuitously.\r\n\r\nI completely agree on this one, but I think you made a great demonstration that a few new terms do help.",
          "createdAt": "2021-03-22T21:33:03Z",
          "updatedAt": "2021-03-22T21:33:03Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Mon, Mar 22, 2021 at 1:06 PM cabo ***@***.***> wrote:\n\n> There is no doubt that the draft could be made to work by calling the\n> things \"mugs\". One can adapt to anything.\n>\n> Value is a particularly bad term to use here because it focuses on the\n> valueness, i.e., comparison by value. Nodes focus on the place, the\n> position, in the tree, i.e., comparison by identity. Again, the draft can\n> be written in a way that makes the reader make that distinction on their\n> own, but that is not a good way to do tech doc.\n>\nWell, you could call them mugs or nodes, but what they actually *are* is\nJSON Values, as defined in 8259.  I'm having trouble parsing the phrase\n\"the place, the position, in the tree, i.e. comparison by identity\".\n\nI'll go ahead and do a PR to update 3.5 without introducing a new term and\nlet's see if we like how it reads.\n",
          "createdAt": "2021-03-22T21:42:28Z",
          "updatedAt": "2021-03-22T21:42:28Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote:\r\n\r\n> > Yes, but it seems to me that the items upon which the processing model operate should be from 8259.\r\n> \r\n> So why are you talking about JSON documents, paths, children, etc.?\r\n\r\nPoint taken :-) One does feel the need to call that first thing provided something other than a JSON value, JSONPointer uses \"JSON document\", JSON Schema uses \"JSON instance\", Goessner uses \"root\". I think paths are required. \"Children\" can be dispensed with.",
          "createdAt": "2021-03-22T21:48:42Z",
          "updatedAt": "2021-03-22T21:49:20Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "#72 uses \"argument\" for the argument of the query.",
          "createdAt": "2021-03-22T21:52:15Z",
          "updatedAt": "2021-03-22T21:52:15Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote:\r\n> \r\n> I completely agree on this one, but I think you made a great demonstration that a few new terms do help.\r\n\r\nIncidentally, specific language issues aside, if you're thinking about processing models for preserving identity and removing duplicates, which is the impression I got from watching the last meeting video, I'm actually quite interested in that.\r\n\r\nDaniel",
          "createdAt": "2021-03-22T21:59:54Z",
          "updatedAt": "2021-03-22T21:59:54Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Mon, Mar 22, 2021 at 2:48 PM Daniel Parker ***@***.***>\nwrote:\n\n> Yes, but it seems to me that the items upon which the processing model\n> operate should be from 8259.\n>\n> So why are you talking about JSON documents, paths, children, etc.?\n>\n> Point taken :-) One does feel the need to call that first thing provided\n> something other than a JSON value, JSONPointer uses \"JSON document\", JSON\n> Schema uses \"JSON instance\", Goessner uses \"root\". I think paths are\n> required. \"Children\" can be dispensed with.\n>\nIn 8259, the top-level production is \" ws value ws \".  Anyone who's read\nthat RFC is not going to have any trouble with the phrase \"root value\".\n 8259 does not define or use the term \"child\", so if we do need it (not\nobvious to me) we can define it as meaning \"elements, if the value is an\narray, member values if it's an object\".\n\nI note that the current draft does not actually define the term \"node\".  I\nthink that if you did, the definition would be something like \"synonym of\nJSON value\". So\u2026\n",
          "createdAt": "2021-03-22T22:03:15Z",
          "updatedAt": "2021-03-22T22:03:15Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Please read #72 at some point.\r\n",
          "createdAt": "2021-03-22T22:36:02Z",
          "updatedAt": "2021-03-22T22:36:02Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@timbray wrote:\r\n\r\n> I note that the current draft does not actually define the term \"node\". \r\n\r\nRight\r\n\r\n> I think that if you did, the definition would be something like \"synonym of JSON value\". So\u2026\r\n\r\nStill, when talking about \"@\", I prefer to talk about it as a \"current node\" rather than a \"current value\". \"current value\" isn't enough for fulling describing the JSONPath processing model, when talking about producing Normalized Paths, the path associated with the current value matters too. It matters even more when we talk about no duplicates. I think @cabo is right to emphasize that aspect. Talking about @ as representing both the location in the root value as well as the value itself, and using node to mean that, seems reasonable to me.\r\n\r\n",
          "createdAt": "2021-03-22T23:31:48Z",
          "updatedAt": "2021-03-22T23:31:48Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I note that the current draft does not actually define the term \"node\". I think that if you did, the definition would be something like \"synonym of JSON value\".\r\n\r\nI think it makes more sense to talk about the location of a node rather than the location of a JSON value because a JSON value could be present at multiple nodes whereas a node has a unique location.",
          "createdAt": "2021-03-23T06:34:59Z",
          "updatedAt": "2021-03-23T06:34:59Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "@glyn: thanks for bringing it to the point pragmatically. In\r\n```\r\n{a:{c:5},b:{d:5}}\r\n```\r\nwe have five JSON values, from which two values are 5, i.e. identical. They belong to two different  name/value pairs (members) according to 8259. Now consider\r\n```\r\n[5,5]\r\n```\r\nwith three JSON values, from which again two values are 5, i.e. identical. They belong to two different ... hmm ... 8259 does not tell. But JSONPath needs to identify them uniquely by their location.\r\n\r\nLooking at JSON Pointer 6901 we read\r\n```\r\nEvaluation of a JSON Pointer begins with a reference to the root\r\nvalue of a JSON document and completes with a reference to some value\r\nwithin the document. Each reference token in the JSON Pointer is\r\nevaluated sequentially.\r\n```\r\nSo JSON Pointer also needs to identify things uniquely by their location and uses ...\r\n\r\n* `root value`\r\n* `reference to some value`\r\n* `reference token`\r\n\r\n... for addressing members in objects and elements in arrays by a single term, since `value` alone simply does not work. \r\n\r\nFor us in fact two additional &ndash; location specifying &ndash; terms would suffice\r\n\r\n* `root (value)`\r\n* `item`,  `node` or `reference` \r\n\r\nor skipping `root`, then only one.",
          "createdAt": "2021-03-23T10:08:33Z",
          "updatedAt": "2021-03-23T10:10:39Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "JSON pointer is about references, so they might have that word in their terminology; I don't think we need that.  node and item are in #72.  root is interesting, because that is an argument to the query \u2014 I called that argument in #72.  We can always change these terms more if we want to, but at some point we need to enable ourselves to work on the content of the draft.",
          "createdAt": "2021-03-23T15:01:30Z",
          "updatedAt": "2021-03-23T15:01:30Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@glyn wrote:\r\n\r\n> > I note that the current draft does not actually define the term \"node\". I think that if you did, the definition would be something like \"synonym of JSON value\".\r\n> \r\n> I think it makes more sense to talk about the location of a node rather than the location of a JSON value because a JSON value could be present at multiple nodes whereas a node has a unique location.\r\n\r\nBut it only makes sense to talk about the location of a \"node\" if the term \"node\" is defined, which I don't believe it is in the current draft. [This](https://www.w3.org/TR/xpath-datamodel-31/#Node) is what \"node\" means in XPath 3.1, but what does it mean in JSONPath? It is meaningless to talk about \"node\" unless \"node\" is defined, and its properties enumerated, as they are in the XPath 3.1 reference. I think terms are being introduced into the draft that are suggestive of terms in XPath, such as \"item\" and \"node\", but surely the one thing that we can all agree on is that we do _not_ want the JSONPath spec to look anything like XPath, with its horrendously complicated data model. \r\n\r\nIt's also unnecessary to introduce \"node\" to fully describe JSONPath, including selection of values or references from a root value with duplicates, selection of Normalized Paths from a root value with duplicates, and both of these operations without duplicates (when identity matters.) It is enough to have the notion of path/value pairs, where \"path\" describes the location of the value in the root value. Nothing else is needed.\r\n\r\nDaniel\r\n\r\n",
          "createdAt": "2021-03-23T15:34:33Z",
          "updatedAt": "2021-03-23T15:36:25Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo ... this was merely an answer for Tim's wish, restricting to 8259 terms exclusively. \r\n@danielaparker ... so you are proposing to use `root value` and `value location`?",
          "createdAt": "2021-03-23T15:42:43Z",
          "updatedAt": "2021-03-23T15:42:43Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "@goessner \u2014 yes, I explained why limiting ourselves to 8259 terminology is misguided.\r\n\r\nWe can certainly invent more and more complex terminology, or we can accept that \"node\" is the term of art here.",
          "createdAt": "2021-03-23T15:45:24Z",
          "updatedAt": "2021-03-23T15:45:24Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner wrote:\r\n\r\n> @danielaparker ... so you are proposing to use `root value` and `value location`?\r\n\r\n@timbray proposed `root value` [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/66#issuecomment-804425507), so I'll stick to that term in my commentary, unless another term is agreed to. I'm broadly in favour of Tim's wish to adhere to 8259 terms to the extent possible. \r\n\r\nI'm happy with \"value location\", since it seems to be nicely symmetrical with the other terms. I believe all operations in the JSONPath processing model can be fully described with just the notions of \"root value\", \"value\" and \"value location\".  \r\n\r\nDaniel\r\n",
          "createdAt": "2021-03-23T15:58:10Z",
          "updatedAt": "2021-03-23T15:58:10Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "#### Table: Terminology compared\r\n\r\n|  | JSONPath | XPath | CSS Selectors| JSON Pointer | JMESPath  |\r\n| --- | --- | --- | --- |--- |--- |\r\n| Title | JSONPath: Query expressions for JSON | XML Path Language  | Selectors | JavaScript Object Notation (JSON) Pointer | A query language for JSON |\r\n| What is it? | string syntax for identifying values within a JSON document | an expression language that allows the processing of values conforming to the data model defined in XDM 3.0 | patterns that match against elements in a tree  | string syntax for identifying a specific value within a JSON document |A query language for JSON\r\n| primary purpose |  `selection`  | `selection`,<br>`addressing`,<br>`matching`,<br>`manipulating` | `matching` |`identifying` | `selection`, `matching`, `manipulating` |\r\n| document root |  `root value`  | `context node` | `document root` | `root value` | `JSON value` |\r\n| models root as ... |  `root value`  | tree of nodes | tree of elements | JSON document?  | `JSON value` |\r\n| primary syntactic construct | `expression`,<br> `value`&nbsp;`location` | `expression`,<br>`location path` | `selector` | `JSON Pointer` | `expression` |\r\n| minimal selector unit | `selector` (?) | `location step` | `simple selector` | `reference token` | `index-expression`, `identifier`, `sub-expression` |\r\n| minimal target | `JSON value`,<br> `node` | `node`, `value` | `element` |  `referenced value` | `JSON value` |\r\n| expression evaluates to | `list of nodes`,<br>`array of values`,<br>`array of output pathes` | `node-set` | `elements` | `JSON value` | `JSON value` |\r\n| what to do on errors | return empty node list ? | errors specified ... but no according behavior  | rule using selector is dropped | not defined by specification | Raise syntax, wrong type, and arity errors detected during evaluation |\r\n\r\nComparison table update from #53. Thanks @danielaparker for adding JMESPath column.",
          "createdAt": "2021-03-23T18:14:37Z",
          "updatedAt": "2021-03-23T19:02:26Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo   Regrading the table with terminology compared, not sure where I can comment on this, as the issue has been closed, and I don't see it in a pull request.\r\n\r\n- \"XPath\" in column heading should specify the version. If \"what is it\" references \"XDM 3.0\", it should be \"XPath 3.0\". You could also specify [XPath 3.1](https://www.w3.org/TR/xpath-datamodel-31/), and change \"what is it\" to reference [XQuery and XPath Data Model (XDM) version 3.1](https://www.w3.org/TR/xpath-datamodel-31/)\r\n- If XPath is 3 or 3.1, \"expression evaluates to\" shouldn't have \"node-set\", node-set disappeared with XPath 1.0.  It should have sequences. Quoting from XPath 3.1,\r\n\r\n\"Sequences replace node-sets from XPath 1.0. In XPath 1.0, node-sets do not contain duplicates. In generalizing node-sets to sequences in XPath 3.0 and XPath 3.1, duplicate removal is provided by functions on node sequences.\"",
          "createdAt": "2021-03-23T19:19:50Z",
          "updatedAt": "2021-03-23T19:33:52Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Hi Daniel,\r\n\r\nThis way of reporting things is fine, but even better is raising an issue -- yes, even small editorial fixes are best handled as issues (you may want to label them \"editorial\").\r\n\r\nRe XPath versions, I'm not sure how much we need to dwell on this in this document.\r\nI think I will try to come up with a pull request that moves some of this material into an appendix  as we said, but I think I'll focus on #79 for a couple of days.",
          "createdAt": "2021-03-23T19:24:58Z",
          "updatedAt": "2021-03-23T19:24:58Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU4MjgxNTY1NDg=",
      "title": "Differentiation from JSON Pointer",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/67",
      "state": "OPEN",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\n> I anticipate being asked \"Why is JSON Pointer not sufficient?\" Indeed its abstract says:\r\n>\r\n>   JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.\r\n>\r\n>... which sounds awfully similar.  If we could include a sentence about\r\nthat, or a link to an answer, that might be helpful.\r\n*(Murray S. Kucherawy)*\r\n\r\n> No - it's not similar in concept, they're separate things. If you really wanted to mention JSON Pointer, you could say something like \"Note that while JSON Pointer (RFC xxxx) is already standardised, it is designed to provide a reference to a single, specific part of a JSON document, whereas JSONPath provides the ability to query a document and potentially return multiple values.\"\r\n*(Mark Nottingham)*\r\n\r\n>The short answer is that JSON pointer is good if you already know the structure of the JSON data item you want to point into, and you want to point to exactly one position in there.  If you need to do something that is closer to a \u201csearch\u201d (which might also result in multiple positions), JSONPath gives you more rope.\r\n*(Carsten Bormann)*\r\n\r\nAs agreed at the IETF 110 meeting the above-mentioned suggestions should be included into the introduction to expand further the distinction between JSON Pointer and our specification.",
      "createdAt": "2021-03-10T18:23:28Z",
      "updatedAt": "2021-03-17T14:27:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Mildly related to some parts of the discussion in #44.",
          "createdAt": "2021-03-10T19:11:06Z",
          "updatedAt": "2021-03-10T19:11:06Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis \r\n\r\n> Mildly related to some parts of the discussion in #44.\r\n\r\nI would suggest \"majorly\" rather than \"mildly\". A Normalized Path Expression as introduced in [Goessner](https://goessner.net/articles/JsonPath/) performs the same role as JSONPointer, to uniquely identify a specific value in a JSON document, which is discussed in that issue.\r\n\r\n",
          "createdAt": "2021-03-11T20:25:08Z",
          "updatedAt": "2021-03-12T15:02:15Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I think we should clearly encourage users using JSON Pointer when security is a concern and they are just interested into selecting a single document sub-tree (when JSON document structure is known).\r\nThis might be a good prescription for the security considerations section.",
          "createdAt": "2021-03-13T12:08:54Z",
          "updatedAt": "2021-03-13T12:08:54Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "> I would suggest \"majorly\" rather than \"mildly\". - @danielaparker \n\nThat issue is about containing the location with the values in the output, but it was hijacked into a discussion about JSON Pointer.",
          "createdAt": "2021-03-13T12:55:53Z",
          "updatedAt": "2021-03-13T12:55:53Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n> \r\n> That issue is about containing the location with the values in the output, but it was hijacked into a discussion about JSON Pointer.\r\n\r\nFair enough. But it was an interesting discussion, given that JSONPointer and Normalized Path both serve to identify a specific value in a JSON document.\r\n\r\nOn the one hand, in the world outside of JSONPath, nobody cares about Normalized Paths, JSONPointer is ubiquitous, and a foundation for other tooling. But within the world of JSONPath, when we perform a JSONPath query with \"Normalized Path\" option specified, we need to get back paths that JSONPath knows about, and that work if they're used as paths in queries. It's a shame that the two syntaxes aren't compatible. But they aren't, and that's about all that an be said.    \r\n",
          "createdAt": "2021-03-13T18:52:49Z",
          "updatedAt": "2021-03-13T19:01:37Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, at AWS we introduced the notion of a \"Reference Path\", which we called a JSONPath that produces a single JSON value as its result: https://states-language.net/spec.html#ref-paths\r\n\r\nIt was quite useful.  But I don't think adding such a thing is consistent with our charter. ",
          "createdAt": "2021-03-16T19:05:53Z",
          "updatedAt": "2021-03-16T19:05:53Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-16, at 20:06, Tim Bray ***@***.***> wrote:\n> \n> \n> FWIW, at AWS we introduced the notion of a \"Reference Path\", which we called a JSONPath that produces a single JSON value as its result: https://states-language.net/spec.html#ref-paths\n> \n> It was quite useful. But I don't think adding such a thing is consistent with our charter.\n\nIt\u2019s called \u201cOutput Path\u201d in the current I-D.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-16T19:56:38Z",
          "updatedAt": "2021-03-16T19:56:38Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@timbray wrote:\r\n\r\n> FWIW, at AWS we introduced the notion of a \"Reference Path\", which we called a JSONPath that produces a single JSON value as its result: https://states-language.net/spec.html#ref-paths\r\n> \r\n> It was quite useful. But I don't think adding such a thing is consistent with our charter.\r\n\r\nJust out of curiosity, why not? The idea of a \"Normalized Path Expression\" that matched a specific JSON value is in the original [Goessner article](https://goessner.net/articles/JsonPath/), and an option to produce Normalized Path Expressions was present in both of the two most influential early implementations: Goessner and Jayway. Unlike your \"Reference Path\", though, a Normalized Path Expression was understood to _uniquely_ identify a specific JSON value. As such it was restricted to the bracket notation with only single quoted names and indices allowed.\r\n\r\nDaniel",
          "createdAt": "2021-03-16T20:59:58Z",
          "updatedAt": "2021-03-16T21:35:30Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Pardon me, you're right. Somehow I'd forgotten that part of the existing\nJSONPath.\n\nOn Tue, Mar 16, 2021 at 2:00 PM Daniel Parker ***@***.***>\nwrote:\n\n> @timbray <https://github.com/timbray>\n>\n> FWIW, at AWS we introduced the notion of a \"Reference Path\", which we\n> called a JSONPath that produces a single JSON value as its result:\n> https://states-language.net/spec.html#ref-paths\n>\n> It was quite useful. But I don't think adding such a thing is consistent\n> with our charter.\n>\n> Just out of curiosity, why not? The idea of a \"Normalized Path Expression\"\n> that produces a single JSON value is in the original [Goessner article] (\n> https://goessner.net/articles/JsonPath/), and an option to produce\n> Normalized Path Expressions was present in both of the two most influential\n> early implementations: Goessner and Jayway.\n>\n> Daniel\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/67#issuecomment-800600959>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJE3LRCAAL5I55DKRMK3TD7BGDANCNFSM4Y6TKXSQ>\n> .\n>\n",
          "createdAt": "2021-03-16T21:59:54Z",
          "updatedAt": "2021-03-16T21:59:54Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "'Reference Path' is not bad. But I can't see what is referenced then. So I would like to stick with 'Normalized Path' (proposal: leaving out 'expression' here) as a compagnon to \"Output Path\".",
          "createdAt": "2021-03-17T14:27:32Z",
          "updatedAt": "2021-03-17T14:27:32Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU4MjgxNTc5NTA=",
      "title": "Document Title",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/68",
      "state": "CLOSED",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has PR"
      ],
      "body": "(This was original raised in #54 and now being split out)\r\n\r\nAt IETF 110 we reached rough agreement for \u201cJSONPath: Query expressions for JSON\u201d to be the title of the document.",
      "createdAt": "2021-03-10T18:24:33Z",
      "updatedAt": "2021-11-09T21:07:40Z",
      "closedAt": "2021-11-09T21:07:40Z",
      "comments": [
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Created PR #77 ",
          "createdAt": "2021-03-22T18:37:37Z",
          "updatedAt": "2021-03-22T18:37:37Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed in #85 ",
          "createdAt": "2021-11-09T21:07:40Z",
          "updatedAt": "2021-11-09T21:07:40Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU4MjgxODU2ODM=",
      "title": "Examples Appendix",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/69",
      "state": "OPEN",
      "author": "fiestajetsam",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As was brought up by Kristina via Jabber:\r\n\r\n> Is there any way we could quickly resolve not to change the most basic obj.first.second and other pathing syntax, so that implementers who are using those things today can feel safer that they\u2019re not going to get hit with a breaking change?\r\n\r\nCarsten suggested:\r\n\r\n> Could start an examples appendix where we all agree what the result should be. E.g. $.a.b is one such example where we all agree. But there are questions about what happens when one such item is an array.\r\n",
      "createdAt": "2021-03-10T18:46:28Z",
      "updatedAt": "2021-03-17T09:30:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe Glyn is already working on such a thing. Per our charter there really shouldn't be any risk of us breaking the current existing syntax.",
          "createdAt": "2021-03-16T19:02:36Z",
          "updatedAt": "2021-03-16T19:02:36Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> Carsten suggested:\r\n> \r\n> > Could start an examples appendix where we all agree what the result should be. E.g. $.a.b is one such example where we all agree. But there are questions about what happens when one such item is an array.\r\n\r\nStrictly speaking, even for this there isn't agreement, in the [JSONPath Comparisons](https://cburgmer.github.io/json-path-comparison/), 9 out of 41 implementations return a single value where only one match is possible (instead of an array of a single value). ",
          "createdAt": "2021-03-16T23:14:23Z",
          "updatedAt": "2021-03-16T23:14:23Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I believe Glyn is already working on such a thing. Per our charter there really shouldn't be any risk of us breaking the current existing syntax.\r\n\r\nCorrect. I'm working on a Compliance Test Suite. However, I haven't yet heard a conclusion as to whether it would be ok to include the whole CTS, which could end up being quite large, in an appendix of the spec.",
          "createdAt": "2021-03-17T07:49:58Z",
          "updatedAt": "2021-03-17T07:49:58Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "It's probably better to not reference any examples as being part of the CTS in the specification as the test suite should be organic.  I would instead list independent examples (which may or may not be in the CTS) and then separately include a link to the CTS (maybe in a separate appendix).",
          "createdAt": "2021-03-17T08:27:20Z",
          "updatedAt": "2021-03-17T08:27:20Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> > Carsten suggested:\r\n> > > Could start an examples appendix where we all agree what the result should be. E.g. $.a.b is one such example where we all agree. But there are questions about what happens when one such item is an array.\r\n> \r\n> Strictly speaking, even for this there isn't agreement, in the [JSONPath Comparisons](https://cburgmer.github.io/json-path-comparison/), 9 out of 41 implementations return a single value where only one match is possible (instead of an array of a single value).\r\n\r\nHow multi-valued results are shown in our examples needs to be worked out.\r\nThe result is not a single JSON data item that wasn't in the input (the array constructed in the API), but a nodelist.\r\n",
          "createdAt": "2021-03-17T09:30:45Z",
          "updatedAt": "2021-03-17T09:30:45Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWU4Mjk3NTk2NzU=",
      "title": "Regular expressions in filters",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/70",
      "state": "OPEN",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue 17 [proposed](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/17#issuecomment-797044615) regular expressions in filters, which is supported by [several implementations](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_regular_expression.html) of JSONPath. This raises two questions:\r\n\r\n1. What is the precise syntax of regular expressions?\r\n2. How should [ReDOS attacks](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/25#issuecomment-700801725) be mitigated?\r\n\r\nOne approach which addresses both these questions would be to adopt [RE2 syntax](https://github.com/google/re2/wiki/Syntax) as discussed in [ReDOS attacks](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/25#issuecomment-700801725), although not all languages may yet have support for RE2.",
      "createdAt": "2021-03-12T05:00:59Z",
      "updatedAt": "2021-09-23T09:50:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "So you are saying JSONpath should only support regular expression literals, not strings with regular expressions.",
          "createdAt": "2021-03-13T13:35:43Z",
          "updatedAt": "2021-03-13T13:35:59Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> So you are saying JSONpath should only support regular expression literals, not strings with regular expressions.\r\n\r\nUnfortunately, no, I'm saying that at the time I wrote that sentence, I had forgotten that Perl/Python/Ruby et al support variables inside the \"/\" delimiters. I wish I could interpret it the way you suggested.\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n",
          "createdAt": "2021-03-13T15:16:54Z",
          "updatedAt": "2021-03-13T15:20:17Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Do you mean as in (1) interpolating variables into the RE (`#{name}`) or (2) filling in variables with results of the RE scan (`?P<name>...`)?\r\n\r\nSo far, I haven't seen any proposal for variables in the JSONPath expression language that could go into either place.",
          "createdAt": "2021-03-13T15:48:44Z",
          "updatedAt": "2021-03-13T15:49:17Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "RE2 syntax would have the advantage that nobody of us likes it :-)\r\nBut seriously, any RE syntax that is not already documented will need to be defined in the document.\r\nThat leaves the ECMAscript syntax of the week or W3C XSD syntax.\r\nECMAscript is a bit anemic but changes all the time.\r\nW3C XSD REs are exactly what would be needed here, but are not very popular.",
          "createdAt": "2021-03-13T16:57:05Z",
          "updatedAt": "2021-03-13T16:57:05Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo  wrote:\r\n\r\n> Do you mean as in (1) interpolating variables into the RE (`#{name}`) or (2) filling in variables with results of the RE scan (`?P<name>...`)?\r\n> \r\n> So far, I haven't seen any proposal for variables in the JSONPath expression language that could go into either place.\r\n\r\nPerhaps an expression e.g. `@.pattern` that evaluated to a string should be allowed within \"/\" delimiters. I haven't thought this through, I only have experience implementing it with character literals, and the [JSONPath comparison](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_regular_expression.html) only has character literals. I'll submit a pull request with JSONPath comparison with a match against an expression, to see what everybody else does.",
          "createdAt": "2021-03-13T17:16:36Z",
          "updatedAt": "2021-03-13T17:22:20Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer to restrict the right hand side of a regular expression match (`=~`) to a literal regular expression. I might be persuaded that we should also allow a JSONPath expression which evaluates to a (single) literal regular expression. I really would like to avoid literal regular expressions that _contain_ JSONPath expressions as that would mean not being able to reuse an existing regular expression syntax (such as RE2).",
          "createdAt": "2021-03-15T07:08:41Z",
          "updatedAt": "2021-03-15T12:11:46Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> I would prefer to restrict the right hand side of a regular expression match (`=~`) to a literal regular expression. \r\n\r\nAfter giving this some thought, I agree.\r\n\r\nIntroducing \"/\" delimiters for regular expressions suggests static \"compilation\" of the regular expression, as it does in perl/ruby/python. If in JSONPath we're applying a regular expression in a search of a million items, we wouldn't want the regular expression to depend on the data, as that would defeat the purpose of introducing the \"/\" delimiters in the first place. We wouldn't want to force implementations to \"recompile\" the regular expression every time the current node changed.\r\n\r\nAlso, I don't think my speculation above about allowing `@.child` inside \"/\" delimiters makes sense, as the symbols allowed within \"/\" delimiters are reserved for regular expression symbols.\r\n\r\nThese observations are consistent with the [Jayway Java](https://github.com/json-path/JsonPath#filter-operators) implementation of the \"~=\" operator. \r\n\r\nIn terms of functional requirements, regular expressions are very useful for search and filtering, but such expressions are generally statically known. \r\n\r\n> I might be persuaded that we should also allow a JSONPath expression which evaluates to a (single) literal regular expression. \r\n\r\nI don't fully understand this sentence. JSONPath expressions don't produce character literals, character literals are a static concept. JSONPath expressions can produce strings, but that's not the same thing. The key feature of character literals is that they don't depend on the data, and in particular on the current node `@`.\r\n\r\n> I really would like to avoid literal regular expressions that _contain_ JSONPath expressions as that would mean not being able to reuse an existing regular expression syntax (such as RE2).\r\n\r\nI don't think anybody would propose that!\r\n\r\n\r\n \r\n\r\n",
          "createdAt": "2021-03-15T11:51:40Z",
          "updatedAt": "2021-03-15T12:12:02Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-15, at 12:51, Daniel Parker ***@***.***> wrote:\r\n> \r\n>> I really would like to avoid literal regular expressions that contain JSONPath expressions as that would mean not being able to reuse an existing regular expression syntax (such as RE2).\r\n>> \r\n> I don't think anybody would propose that!\r\n\r\nWell, then let me propose that :-)\r\n\r\nBuilding a RE out of data that has been found in the input is not that outlandish, I think.  I\u2019m not sure that we ultimately want to support that, but it is not something that is self-evidently excluded.\r\n\r\nGr\u00fc\u00dfe, Carsten\r\n\r\n",
          "createdAt": "2021-03-15T11:54:50Z",
          "updatedAt": "2021-03-15T12:12:15Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I might be persuaded that we should also allow a JSONPath expression which evaluates to a (single) literal regular expression.\r\n> \r\n> I don't fully understand this sentence. JSONPath expressions don't produce character literals, character literals are a static concept. JSONPath expressions can produce strings, but that's not the same thing. The key feature of character literals is that they don't depend on the data, and in particular on the current node `@`.\r\n\r\nPardon my confusion, but what I had in mind was to allow the likes of `... =~ $.a` where `$.a` evaluates to a regular expression such as `/x.*y/`.",
          "createdAt": "2021-03-15T12:10:55Z",
          "updatedAt": "2021-03-15T12:12:44Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@glyn wrote:\r\n> \r\n> Pardon my confusion, but what I had in mind was to allow the likes of `... =~ $.a` where `$.a` evaluates to a regular expression such as `/x.*y/`.\r\n\r\nOne minor point, I believe it should say that it evaluates to a string `\"x.*y\"`, rather than character literals `/x.*y/`. \r\n\r\nOtherwise, I believe that that's technically sound, and permits an efficient implementation, in the sense of \"compile\" regular expression once and apply many times. And it's somewhat more likely that there is a regular expression to be found at an absolute location in the JSON document, as opposed to in all current nodes :-) I still think it's an unlikely user requirement. If you do become persuaded to support this syntax, it probably won't be because I've tried to persuade you.",
          "createdAt": "2021-03-15T16:17:33Z",
          "updatedAt": "2021-03-15T17:14:23Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-15, at 17:17, Daniel Parker ***@***.***> wrote:\n> \n> And it's somewhat more likely that there is a regular expression to be found\n\nThe expression language could also contain something like RegExp.escape, and it is likely to be helpful to compose the regular expression out of constant and variable (from input item) parts.  What\u2019s out there in today\u2019s implementations?\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-15T16:24:24Z",
          "updatedAt": "2021-03-15T16:24:24Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote:\r\n\r\n> The expression language could also contain something like RegExp.escape, and it is likely to be helpful to compose the regular expression out of constant and variable (from input item) parts. What\u2019s out there in today\u2019s implementations? \r\n\r\n> For implementations that rely on Javascript/Python/Perl/PHP et al for a filter predicate implementation, the capabilities of the regular expression evaluator are of course the capabilities of the scripting language, but I think the support for providing input for the evaluator are quite limited, perhaps limited to a string with pre-evaluated `@.something` terms. \r\n\r\nAs it turns out, no implementation supports `@.something` terms in regular expressions.",
          "createdAt": "2021-03-15T17:01:05Z",
          "updatedAt": "2021-03-16T02:08:55Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> ...what I had in mind was to allow the likes of ... `=~ $.a` where `$.a` evaluates to a regular expression such as `/x.*y/`.\n\nI could get behind this.\n\nBut I definitely wouldn't want to \"construct\" a RegEx from input data, as others have also been opposed to.",
          "createdAt": "2021-03-15T19:30:30Z",
          "updatedAt": "2021-03-15T19:30:30Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-15, at 18:01, Daniel Parker ***@***.***> wrote:\n> \n> Do you have some candidate syntax in mind that you would like to have investigated?\n\nIt would easy to come up with something, but I\u2019d rather not invent something \u2014 if there is no current practice for this, we should not include it.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-15T20:10:38Z",
          "updatedAt": "2021-03-15T20:10:38Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On 2021-03-15, at 18:01, Daniel Parker ***@***.***> wrote: Do you have some candidate syntax in mind that you would like to have investigated?\r\n> It would easy to come up with something, but I\u2019d rather not invent something \u2014 if there is no current practice for this, we should not include it. Gr\u00fc\u00dfe, Carsten\r\n\r\nAgree. Reminder: Charter says we're supposed to specify something \"based on the common semantics and other aspects of existing implementations\".  So there's a judgment call to be made as to whether enough of them support a common regex that we can reasonably claim it constitutes \"common semantics\".  My impression had been No, but it's months since I looked at the overlap chart.",
          "createdAt": "2021-03-16T19:01:35Z",
          "updatedAt": "2021-03-16T19:01:35Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I can tell you neither of mine support RegEx (one is obsolete now).  But I'm open to adding it to the current one.",
          "createdAt": "2021-03-17T03:21:39Z",
          "updatedAt": "2021-03-17T03:21:39Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I would really wish support for regex, and honestly I think they are nearly a must.\r\nHowever I'm really worried about all the implications behind them.\r\n\r\nWe are working hard for making sure that any future implementation is going to behave consistently with any other which follows our work.\r\n\r\nI'm worried that all the complexity and differences behind regex is going to reintroduce back all the discrepancies we are trying hard to remove.\r\n\r\nI think that If we wish any regex support we need to go for a regex syntax which is well specified and comonly implemented.\r\n\r\nHonestly I'm not happy with RE2 that has been mentioned before, as far as I know it is available to most of languages as a C library through bindings (bindings might be really problematic).\r\n\r\nFor instance I wasn't happy with RE2 library while working with Erlang and Elixir, among all the reasons, using it would force my JSONPath implementation to depend on native code using a NIF while the whole library is 100% Elixir compiled into BEAM byte code.\r\n\r\nIMHO we might investigate a Perl-like or POSIX-like regex support (that are quite popular). But again we should avoid getting stuck into all the regex complexities.\r\n\r\nI have also some further points, questions and doubts:\r\n\r\n1. I think that regex should be supported only as a constant, therefore they must not be taken from a JSONPath evaluation result (e.g. disallow `$[?(@.foo =~ @.regex)]`).\r\nWe might change idea on a future revision, but right now I'm worried that this might introduce further complexity, discrepancies and performance penalities (we can parse and compile the regex while parsing the JSONPath).\r\n\r\n2. are we going to treat regex as strings when using == comparison (e.g. `$[?(@.foo == /[a-z]*/)]` is true when `foo` is `\"[a-z]*\"`) or are we going to use any special type, therefore == will never be true when comparing with a string?\r\n\r\n3. should we raise a parsing time error if a ill-formed regex is provided (e.g. `/[a-z/`)?\r\n",
          "createdAt": "2021-03-17T22:10:03Z",
          "updatedAt": "2021-03-17T22:12:40Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "My 2 \u00a2:\r\n\r\nAny RE syntax we decide to use will need to be thoroughly documented in JSONPath, except if it is one of the ECMAscript versions or W3C XSD syntax.  (I do not really consider Posix a candidate, it is a bit anemic.)\r\nOf course, we don't need capture groups, global substitute, and can probably live without back references etc.  That makes W3C XSD syntax my favorite, but it is also less widely implemented than others.  It's 2021, so strings and REs will be Unicode text.\r\n\r\nIs it (1) string =~ RE, or (2) RE =~ string, or (3) both or even (4) both but with subtly different semantics (horror experience from the Ruby language)?\r\n\r\n> * I think that regex should be supported only as a constant, therefore they must not be taken from a JSONPath evaluation result (e.g. disallow `$[?(@.foo =~ @.regex)]`).\r\n>   We might change idea on a future revision, but right now I'm worried that this might introduce further complexity, discrepancies and performance penalities (we can parse and compile the regex while parsing the JSONPath).\r\n\r\nThat is a sensible approach.  Unless there is a large installed base that depends on computed REs, I agree.  We could make sure that a later extension can be added seamlessly.\r\n\r\n> * are we going to treat regex as strings when using == comparison (e.g. `$[?(@.foo == /[a-z]*/)]` is true when `foo` is `\"[a-z]*\"`) or are we going to use any special type, therefore == will never be true when comparing with a string?\r\n\r\nWe have the luxury of being able to provide strong typing, so a RE literal should be a (syntax?) error except near a `=~`.\r\n\r\n> * should we raise a parsing time error if a ill-formed regex is provided (e.g. `/[a-z/`)?\r\n\r\nYes.  If we can check a query before applying it to input, we should do that with failing fast.\r\n",
          "createdAt": "2021-03-17T22:50:16Z",
          "updatedAt": "2021-03-17T22:50:16Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I tried to query this example [1] using a JSONPath with a XSD regex\r\n\r\nI tried using `$.store.book[?(@.title =~ /[a-z-[s-u]]/)]` (which is equivalent to `$.store.book[?(@.title =~ /[a-rv-z]/)]`):\r\n\r\nJayway: fails to understand it and returns a \"bogus\" result (but it doesn't fail with the \"regular\" regex)\r\n\r\n**Personal opinion about XSD regex**: I feel like that no implementation is supporting them (I'm not aware of any), I feel like that every implementation supports whatever the language provides as builtin regex implementation (which is likely far from XSD regex syntax). Please, let me know if any implementation is supporting that syntax. If none supports that syntax, are we really sure to go for a syntax that nobody is using? Furthermore I didn't find any online tool to test regex with XSD style, conversely, PCRE style regex are easy to test (this is not really encouraging).\r\n\r\nI also did few tests with some online test tools, following implementations just **fail to understand** any regex (I tried with \"basic\" syntax `$.store.book[?(@.title =~ /[a-z]/)]`):\r\n\r\n* jsonpath-plus (javascript, 0.18.1)\r\n* goessner: bogus result here, it replaces every title occurrence with -1\r\n\r\n**Personal opinion**: previous results make me feel skeptic about the whole regex feature. Do we know which implementations are supporting regex?\r\n\r\n[1]:\r\n```json\r\n{\r\n    \"store\": {\r\n        \"book\": [\r\n            {\r\n                \"category\": \"reference\",\r\n                \"author\": \"Nigel Rees\",\r\n                \"title\": \"a\",\r\n                \"price\": 8.95\r\n            },\r\n            {\r\n                \"category\": \"fiction\",\r\n                \"author\": \"Evelyn Waugh\",\r\n                \"title\": \"s\",\r\n                \"price\": 12.99\r\n            },\r\n            {\r\n                \"category\": \"fiction\",\r\n                \"author\": \"Herman Melville\",\r\n                \"title\": \"x\",\r\n                \"isbn\": \"0-553-21311-3\",\r\n                \"price\": 8.99\r\n            },\r\n            {\r\n                \"category\": \"fiction\",\r\n                \"author\": \"J. R. R. Tolkien\",\r\n                \"title\": \"The Lord of the Rings\",\r\n                \"isbn\": \"0-395-19395-8\",\r\n                \"price\": 22.99\r\n            }\r\n        ],\r\n        \"bicycle\": {\r\n            \"color\": \"red\",\r\n            \"price\": 19.95\r\n        }\r\n    },\r\n    \"expensive\": 10\r\n}\r\n```",
          "createdAt": "2021-03-18T23:34:48Z",
          "updatedAt": "2021-03-18T23:44:42Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> But there are online XPATH 3 evaluators. Have you tried testing regex with them?\r\n\r\nAs far as I know XPath/XQuery regex [are different than XML Schema ones](https://www.regular-expressions.info/xml.html):\r\n> Note that the regular expression functions available in XQuery and XPath use a different regular expression flavor. This flavor is a superset of the XML Schema flavor described here. It adds some of the features that are available in many modern regex flavors, but not in the XML Schema flavor.\r\n\r\nI feel like there is a lack modern tooling for testing XML Schema flavor regex (outside XML schemas), and this might be quite frustrating for end users.\r\n\r\nBy the way [JSON Schema is borrowing syntax from ECMA 262](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html).",
          "createdAt": "2021-03-19T00:43:30Z",
          "updatedAt": "2021-03-19T00:43:30Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I did some further investigation into regex support (using cburgmer's tool and his implementations list).\r\n\r\nI usued a quite simple regex `[a-rv-z]` (JSON input was: `[{\"a\": \"a\"}, {\"b\": \"s\"}]` and JSONPath was: `$[?(@.a =~ /[a-rv-z]/)]`).\r\n\r\nThey are supported by 11 implementations in 7 different languages [1], interestingly JavaScript implementations were not supporting it, and 3/4 of them were completely misbehaving [2]:\r\n- JavaScript brunerd \"matches\" everything\r\n- JavaScript Goessner and jsonpath-plus replace matches with -1\r\n\r\nI'm worried that users might expect to use regex to reliably validate/filter out invalid inputs, but they get accepted anyway.\r\n\r\nInstead `$[?(@.a =~ \"[a-rv-z]\")]` is not supported at all.\r\n\r\nAlso I tested a XSD-like syntax, `$[?(@.a =~ /[a-z-[s-u]]/)]` is supported by a further limited subset of implementations (5/11).\r\n\r\n[1] List of implementations supporting `$[?(@.a =~ /[a-rv-z]/)]`:\r\nC++ (1/1 implementation):\r\n- jsoncons\r\n\r\nGo (2/6 implementations):\r\n- github.com-bhmj-jsonslice\r\n- github.com-vmware-labs-yaml-jsonpath\r\n\r\nJava (2/2 implementations):\r\n- com.github.jsurfer\r\n- com.jayway.jsonpath\r\n\r\nObjective-C (1/1 implementation):\r\n- SMJJSONPath\r\n\r\nRuby (1/1 implementation):\r\n- jsonpath\r\n\r\nPHP (3/4 implementations):\r\n- galbar-jsonpath\r\n- remorhaz-jsonpath\r\n- softcreatr-jsonpath\r\n\r\ndotNET (1/4 implementations):\r\n- Json.NET\r\n\r\n[2] JavaScript misbehaving implementations:\r\n- Goessner: [{\"a\": -1}, {\"a\": -1, \"b\": \"s\"}]\r\n- brunerd: [{\"a\": \"a\"}, {\"b\": \"s\"}]\r\n- jsonpath-plus: [{\"a\": -1}, {\"a\": -1, \"b\": \"s\"}]",
          "createdAt": "2021-03-20T14:09:16Z",
          "updatedAt": "2021-03-20T14:09:16Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Interesting.  While it may be a bit early to actually decide anything about regular expressions, this also seems to show some differences in expression evaluation.  Can you do a similar check with `== \"a\"` and `== \"b\"`?",
          "createdAt": "2021-03-20T14:14:29Z",
          "updatedAt": "2021-03-20T14:14:29Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@cabo: it's fine. Let me know what kind of output are you looking for, so I can summarize it in a helpful way.",
          "createdAt": "2021-03-23T15:27:20Z",
          "updatedAt": "2021-03-23T15:27:20Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> \r\n> By the way [JSON Schema is borrowing syntax from ECMA 262](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html).\r\n\r\n@bettio, what is your opinion about ECMA 262? All other things equal, and when it doesn't matter too much, I am strongly in favour of staying consistent with other standards, whether IETF recommendation or de facto standards such as JSON Schema. \r\n\r\nDaniel",
          "createdAt": "2021-03-25T18:26:27Z",
          "updatedAt": "2021-03-25T18:26:57Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... this might be a way to go. Sharing a small, well defined subset of [tc39](https://tc39.es/ecma262/#sec-regexp-regular-expression-objects) with JSON Schema.",
          "createdAt": "2021-03-25T18:36:21Z",
          "updatedAt": "2021-03-25T18:36:21Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the purpose of the RFC is to give advice to implementers and users\nas to what works.  It's very unlikely that any existing implementation will\nchange its semantics because of our work - but new ones will follow it if\nwe do a good job.  So I'd like the RFC to say something like \"Some\nimplementations support regular expression filters in JSONPaths; maximum\ninteroperability can be achieved by using subset $X.\"\n\nIn particular, since regexes exhibit an 80/20 rule - you get 80% of the\nbenefit with 20% of the features. Another reason a modest subset seems like\na good idea for the JSONPath RFC.\n\nOn Thu, Mar 25, 2021 at 11:36 AM Stefan Goessner ***@***.***>\nwrote:\n\n> ... this might be a way to go. Sharing a small, well defined subset of\n> tc39 <https://tc39.es/ecma262/#sec-regexp-regular-expression-objects>\n> with JSON Schema.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/70#issuecomment-807253161>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJE3AIFKRKWWMCYHT5TLTFN7DTANCNFSM4ZBSRVIQ>\n> .\n>\n",
          "createdAt": "2021-03-25T18:40:59Z",
          "updatedAt": "2021-03-25T18:40:59Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Some historical context: JSON Schema specifies 262 because that was what was available when the feature was added.  It maintains 262 because that's what implementations now support.\n\nI don't think this is cause enough for us to adopt it here.  We should look at which RegEx specification serves our needs and use that. If it also happens to be 262, that's fine.\n\n---\n\nOn a side note of implementation support, neither of my implementations support RegEx, but I'm happy to add it.  I expect other maintainers wouldn't complain about it if it became a requirement.",
          "createdAt": "2021-03-25T19:10:39Z",
          "updatedAt": "2021-03-25T19:11:11Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@timbray:\r\n> Another reason a modest subset seems like\r\n> a good idea for the JSONPath RFC.\r\n\r\nThe modest subset is what actually really works in a consistent manner: `$.key` is supported by 100% implementations, and Goessner's article is enough for that (I believe that some \"basic\" features are not supported by every implementation just because they are incomplete implementations, so no RFC is going to fix an unfinished or unmaintained project).\r\n\r\nI don't see any useful reason about documenting just the \"modest subset\" (and I don't think it is worth it), also I think that is not compatible with our WG charter:\r\n\r\nI will quote Barry Leiba, that asked to change the original charter.\r\n\r\nThe original charter:\r\n> The WG will develop a standards-track JSONPath specification, with the primary goal of capturing the common semantics of existing implementations and, where there are differences, choosing semantics with the goal of causing the least disruption among JSONPath users.\r\n\r\nBarry Leiba:\r\n> I fear that this text appears to say that we primarily want to develop a dumbed-down compromise mush, and I'm sure that's not what we really mean. The primary goal is, surely, to develop a specification for JSONPath that is technically sound, complete, and useful.\r\n\r\nAnd the following has been proposed:\r\n\r\n> The WG will develop a standards-track JSONPath specification that is technically sound and complete, based on the common semantics and other aspects of existing implementations. Where there are differences, the working group will analyze those differences and make choices that rough consensus considers technically best, with an aim toward minimizing disruption among the different JSONPath implementations.\r\n\r\nHonestly what I found hard was taking decisions about quite commonly implemented \"extensions\" and a number of corner cases, and users love extensions (such as regex) because they find them useful.\r\n\r\n@timbray: however if you are willing to work on it, we might document a \"JSONPath Core\" subset, that can be safely used across implementations for portability reasons, and for transitional purposes, but I don't agree about just limiting to it.\r\n\r\nSorry for the OT, let's continue the regex topic.\r\n\r\n**Edit**: I wrote a quick proposal that tries to match the 2 point of view I see here (and in other discussions): https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/78#issuecomment-807810986",
          "createdAt": "2021-03-25T23:59:52Z",
          "updatedAt": "2021-03-26T00:31:10Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "Talking about regex: I think we should start again from requirements. I'll start with some of them:\r\n* Good enough for matching URLs, domain names, mail addresses, IP addresses, UUIDs and all the stuff that people keep asking on stackoverflow \r\n* Reasonable unicode support (it is 2021, honestly I rather not support them than supporting a limited version that is mostly good for Latin1).",
          "createdAt": "2021-03-26T00:55:24Z",
          "updatedAt": "2021-03-26T00:58:41Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we all agree:\r\n\r\n* JSONPath must stipulate a regular expression syntax for use in filters, and\r\n* it's not the role of JSONPath to define a new regular expression standard.\r\n \r\nFortunately, there's a clean syntactic and semantic separation between JSONPath and regular expression (_de facto_ or _de jure_) standards.\r\n\r\nI suggest we then stipulate RE2 for its security properties and unicode support (with \"SHOULD\" language) and allow for other regular expression standards (with \"MAY\" language).\r\n\r\nJSONPath implementations that share a regular expression standard will interoperate on JSONPaths involving regular expressions. JSONPath implementations which don't share a regular expression standard may or may not interoperate on particular JSONPaths, depending on the regular expressions used.\r\n\r\nIn terms of compliance testing, it may be sufficient to include a few simple regular expressions which will work \"everywhere\".  \r\n",
          "createdAt": "2021-03-27T11:00:55Z",
          "updatedAt": "2021-03-27T11:00:55Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suggest we then stipulate RE2 for its security properties and unicode support\r\n\r\nI see your intent here, but I have to say that I'm not a fan of pure wrappers (especially as I work in .Net), and it seems that _all_ of the implementations for RE2 are just wrappers for the C++ implementation.  There are a lot of benefits to developers when a library is written in the language.  I don't think we should ignore that.\r\n\r\nLet's make sure that [this comparison](https://en.wikipedia.org/wiki/Comparison_of_regular-expression_engines) is considered in this decision.",
          "createdAt": "2021-03-27T22:01:15Z",
          "updatedAt": "2021-03-27T22:01:15Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Go has RE2 built in (https://golang.org/pkg/regexp/), but point taken. I agree that a wrapper is to be avoided, especially if it makes shipping a static binary impossible. \r\n\r\nWhich other regex (_de facto_ or _de jure_) standards support unicode?",
          "createdAt": "2021-03-28T11:46:27Z",
          "updatedAt": "2021-03-28T11:46:27Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "It's 2021, so all (notable) RE standards support Unicode.\r\n\r\nI think, for once, recent drafts from json-schema.org got this right:\r\nLet's define a common subset, and reference that to an existing written up standard such as ECMAScript.\r\n(json-schema.org got the idea right, not necessarily the specific subset -- there is quite some fluff in that.)\r\n\r\nIf nobody else wants, I'll do a PR with an ABNF definition of such a subset.\r\nWe can then debate what to leave in/throw out/add.\r\n",
          "createdAt": "2021-03-28T11:51:48Z",
          "updatedAt": "2021-03-28T11:51:48Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Example [StackOverflow question](https://stackoverflow.com/q/67417229/878701) that could be solved using RegEx.",
          "createdAt": "2021-05-06T21:38:08Z",
          "updatedAt": "2021-05-06T21:38:08Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Another [question](https://stackoverflow.com/q/69296622/878701) on the usage of RegEx in filters.",
          "createdAt": "2021-09-23T09:50:10Z",
          "updatedAt": "2021-09-23T09:50:10Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU4MzAwMjg1ODg=",
      "title": "YAML support",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/71",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While not mentioned in the spec, JSON Schema is often represented in YAML rather than JSON for various reasons.  OpenAPI is a common example of this.\n\n(Personally I don't like YAML, but my opinions seem to have no effect on it's continued public use.)\n\nIs processing a JSON Path over YAML data something that we want to consider for the specification, or do we leave that to the implementations to decide (as JSON Schema does)?\n",
      "createdAt": "2021-03-12T11:30:51Z",
      "updatedAt": "2021-03-18T19:07:12Z",
      "closedAt": "2021-03-18T19:07:12Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "It could be mentioned, but will otherwise have no influence on the specification, so I dont's see a reason for that.",
          "createdAt": "2021-03-13T13:33:59Z",
          "updatedAt": "2021-03-13T13:33:59Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I wrote https://github.com/vmware-labs/yaml-jsonpath/ because of a need to\napply JSONPath to YAML data (Kubernetes resource files). But I would prefer\nto avoid importing the additonal complexity of YAML into our internet draft\nas I don't think it adds sufficient value and I doubt many JSONPath\nimplementations would support YAML.\n\nOn Fri, 12 Mar 2021, 11:31 Greg Dennis, ***@***.***> wrote:\n\n> While not mentioned in the spec, JSON Schema is often represented in YAML\n> rather than JSON for various reasons. OpenAPI is a common example of this.\n>\n> (Personally I don't like YAML, but my opinions seem to have no effect on\n> it's continued public use.)\n>\n> Is processing a JSON Path over YAML data something that we want to\n> consider for the specification, or do we leave that to the implementations\n> to decide (as JSON Schema does)?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/71>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2ME7FXTRMBZLQYJUJ3TDH3P3ANCNFSM4ZCDR32A>\n> .\n>\n",
          "createdAt": "2021-03-13T14:21:34Z",
          "updatedAt": "2021-03-13T14:21:34Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "One can always write a spec that explains how to apply JSONPath to more extensive data models than that of JSON (and probably extend it in the process).  But that is not what this WG is chartered to do.\r\n",
          "createdAt": "2021-03-13T14:24:55Z",
          "updatedAt": "2021-03-13T14:24:55Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "I think we have a consensus to not support YAML at this time.  Closing the issue.",
          "createdAt": "2021-03-18T19:07:09Z",
          "updatedAt": "2021-03-18T19:07:09Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU4MzA5OTc1OTQ=",
      "title": "The problem of comparing an evaluated expression with a json literal",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/74",
      "state": "CLOSED",
      "author": "danielaparker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This issue relates to suggested expression syntax described in #17.\r\n\r\nFor a given JSON document\r\n```\r\n[[1, 2, 3], [1], [2, 3], 1, 2]\r\n```\r\nthe following queries are considered:\r\n\r\n```\r\n$[?(@ == 2)]               (1)\r\n\r\n$[?(@ == [1,2,3])]       (2)\r\n\r\n$[?(@[0:1]==[1])]        (3)\r\n```\r\n\r\nIn these three queries, the left side of the expression is a JSONPath selector against the current node<sup>[1](#footnote1)</sup>, and the right side is a JSON literal.\r\n\r\nIf the selector on the left side is evaluated such that only a single value is returned when only one match is possible (instead of an array of a single value), the following results are expected:\r\n\r\n```\r\n[2]                                  (4)\r\n\r\n[[1,2, 3]]                         (5)\r\n\r\n[[1, 2, 3],  [1]]                 (6)\r\n```\r\n\r\nCpp (jsoncons), Java (com.jayway.jsonpath) , Objective-C (SMJJSONPath), and Python (jsonpath) are consistent with these results. For comparable queries in JSONPath Comparison, see [Filter expression with bracket notation with number](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_bracket_notation_with_number.html), [Filter expression with equals array](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_equals_array.html), [Filter expression with equals array for array slice with range 1](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_equals_array_for_array_slice_with_range_1.html)\r\n\r\nBut let's consider the case where the selector on the left side is evaluated such that an array is always returned, including an array of a single value (typical behavior of a JSONPath evaluator.) If we take the first element of that array to compare with the JSON literal on the right, we match (4) and (5), but not (6).   \r\n\r\nIt seems to me that for sensible results, in the context of filter expressions, the selector on the left side must be evaluated such that only a single value is returned when only one match is possible. \r\n\r\nI note that most implementations do _not_ support comparisons between evaluated JSONPath expressions and JSON arrays, in JSONPath Comparisons, only six give the expected result in a query analogous to (2), and four for the query (3).  \r\n\r\nMost implementations give the expected result for (1).\r\n\r\n<a id=\"footnote1\">1</a>: In many implementations, particularly ones using an external script engine, these aren't in fact evaluated as JSONPath selectors, but in some they are.\r\n\r\n",
      "createdAt": "2021-03-13T21:15:57Z",
      "updatedAt": "2021-04-28T18:47:45Z",
      "closedAt": "2021-04-28T18:47:45Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems to me that for sensible results, in the context of filter expressions, the selector on the left side must be evaluated such that only a single value is returned when only one match is possible.\n\nThis seems to touch on value equivalency a bit, which @danielaparker [commented on in another issue](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/57#issuecomment-792857872) and I replied to.\n\nConsider the cases (1) and (4).  If the expression returns a single value, it _could_ be valid to operate on that single value directly rather than its containing array (which is what is technically returned).  JSON Logic [does something similar](https://jsonlogic.com/operations.html#merge) to make authoring logic constructs simpler.  It's a sort of short-hand or syntax sugar.\n\nI can see value in this.\n\n(Also, I've already coded it, although it went against all of the strongly-typed bones in my body.)",
          "createdAt": "2021-03-14T05:30:18Z",
          "updatedAt": "2021-03-14T05:31:07Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> > It seems to me that for sensible results, in the context of filter expressions, the selector on the left side must be evaluated such that only a single value is returned when only one match is possible.\r\n> \r\n> This seems to touch on value equivalency a bit, which @danielaparker [commented on in another issue](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/57#issuecomment-792857872) and I replied to.\r\n> \r\n> Consider the cases (1) and (4). If the expression returns a single value, it _could_ be valid to operate on that single value directly rather than its containing array (which is what is technically returned). \r\n\r\nRight, taking the first element is the obvious rule, and corresponds to intuition when the JSONPath expression does in fact evaluate to a single value, as in (1) and (2). But that rule doesn't correspond to intuition when the JSONPath expression evaluates to multiple values, such as with a wildcard selector, a union selector, or a slice selector, as in (3). \r\n\r\nIn any case, the draft needs to specify rules for how the results of these expressions are to be compared. The simplest would be to define operators only between single values, which is what the majority of implementations have. But a few implementations have been more ambitious.",
          "createdAt": "2021-03-14T18:27:53Z",
          "updatedAt": "2021-03-14T18:32:26Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So supposing that the spec defines behavior for single values / single-valued arrays, what's the behavior when multiple values are returned?  I think either:\n\n- this needs to be explicitly defined (e.g. operators return `false`, `null`, some unevaluatable state, etc.), or\n- the spec should explicitly state that behavior is not defined.\n\nThe nice thing about the second option is that it leaves the behavior open to the implementations for now.  Then future versions of the spec can use the behavior defined by the implementations to define it officially.\n\n---\n\nBut then some cases might require returning multiple values, such as functions, e.g. `len()` or `contains()`.",
          "createdAt": "2021-03-14T19:07:33Z",
          "updatedAt": "2021-03-14T19:09:10Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis \r\n\r\n> So supposing that the spec defines behavior for single values / single-valued arrays, what's the behavior when multiple values are returned? I think either:\r\n> \r\n> * this needs to be explicitly defined (e.g. operators return `false`, `null`, some unevaluatable state, etc.), or\r\n> * the spec should explicitly state that behavior is not defined.\r\n> \r\nI think the general rule should be that the JSONPath expression be evaluated in expressions without putting single values in an array. That works for all cases, and in particular it works for the comparison of a slice and an array in (3). Putting single values in an array makes sense for the final result, but not in expressions.\r\n\r\nTo make live easier for legacy implementations, I would suggest the specification only _require_ comparison of paths returning single values.  In this case it doesn't make any difference whether the JSONPath evaluator puts an array around the single value or not, the implementation can use the single value or the element in the array. It can be left as an implementation extension whether to support more general paths such as slices in expressions, as a few currently do.\r\n\r\nDaniel\r\n\r\n\r\n\r\n \r\n\r\n",
          "createdAt": "2021-03-15T01:49:50Z",
          "updatedAt": "2021-03-15T01:49:50Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> ... JSONPath expression be evaluated in expressions without putting single values in an array. That works for all cases... - @danielaparker \n\nIt doesn't work for all cases when combining this with #59.  If paths can start with `@` then it makes sense that they always return an array.  This allows the expression evaluation to use the overall party logic to evaluate the path.  In this approach, the _operator_ interprets a single-value array as merely the value as necessary.\n\nThere's also, the ambiguity where the value returned is actually an array.  E.g. `$[?(@.foo == [1, 2, 3])]`\n\nI think returning an array has valid use cases.",
          "createdAt": "2021-03-15T03:44:38Z",
          "updatedAt": "2021-03-15T03:44:38Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> There's also, the ambiguity where the value returned is actually an array. E.g. `$[?(@.foo == [1, 2, 3])]`\r\n>\r\nThat's effectively covered by example (2) in the OP, for the simplest possible case. \r\n> \r\n> I think returning an array has valid use cases.\r\n\r\nIt would be helpful to keep the discussion example driven, as comparing a path result on the left side with a JSON literal on the right side, or another path on the right side, is really hard to wrap one's mind around without them. At least with \"return as array\". This is one situation where the \"return as single value\" advocates, whose case is represented in section 8 of [minutes-109-jsonpath-00](https://datatracker.ietf.org/doc/minutes-109-jsonpath/),  have an easier story.\r\n\r\nCould you explain with an example how you think these two comparisons should work, with consistent rules in both cases:\r\n\r\n- A comparison of a slice expression against the current node, with a JSON literal array (i.e. example (3)) \r\n- A comparison of one slice expression against the current node, with another slice expression against the current node on the right side. \r\n\r\nAlso, be explicit about what information you assume is available to the equality operator when performing the evaluation. In the [JMESPath equality operator](https://jmespath.org/specification.html#equality-operators), for example, it is specified that the operator only sees a JSON value on the left, and a JSON value on the right, the expression evaluation has already taken place.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-03-15T17:48:28Z",
          "updatedAt": "2021-03-15T18:35:04Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-13, at 22:16, Daniel Parker ***@***.***> wrote:\n> \n> But let's consider the case where the selector on the left side is evaluated such that an array is always returned, including an array of a single value. If we take the first element of that array to compare with the JSON literal on the right, we match (4) and (5), but not (6).\n\nI\u2019m having a hard time following this conversation.\n\nWhy would we want to do what you describe?\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-15T17:54:58Z",
          "updatedAt": "2021-03-15T17:54:58Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was thinking about this some more.\n\nHaving the operator itself strip off the outer array for single-value arrays doesn't make sense.  If you use substitution, evaluating the path on `@..foo == 1` would result in `[1] == 1` which is wrong.  So for this case, it makes sense to _not_ allow multiple return values and always strip the array.\n\nHowever, supposing that we define functions, you could have something like `contains(@..foo, 1)` in which case, you might _want_ to allow multiple return values.\n\nBut.... Then there's an ambiguity between `@..foo` returning multiple values and it returning a single value which happens to be an array.\n\nConsidering these variants, I think it only makes sense to force the return of a single value from paths inside expressions. I just don't see a reliable way to return the full match set and still get the expressions that we want.\n\nI see this as an _implicit_ `single()` function wrapping the path, e.g. `single(@..foo) == 1` where `@..foo` returns its normal array of matches, but the `single()` ensures that it only contains one value, otherwise an error results (or, to be non-destructive, the expression evaluates to `false` so that the item is not selected).\n\nIf this `single()` function were the default behavior (implicit), we could define another function, say `all_results()`, that could be used explicitly to declare that we want the full match set so that we can operate on the result as an array.",
          "createdAt": "2021-03-15T19:51:58Z",
          "updatedAt": "2021-03-15T19:51:58Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry if that's not clear \u261d\ufe0f.  Was thinking out loud a bit.",
          "createdAt": "2021-03-15T19:53:09Z",
          "updatedAt": "2021-03-15T19:53:09Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-15, at 20:52, Greg Dennis ***@***.***> wrote:\n> \n> returning multiple values\n\nThis whole discussion is confused between this (returning multiple values) and JSON arrays.\n\nJSON arrays are items in the input.\n\nMultiple values are, just that, multiple values.\n(Call them, collectively, collections if you like.)\n\nCan we keep these two concepts separate?\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-15T20:08:40Z",
          "updatedAt": "2021-03-15T20:08:40Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This whole discussion is confused between this (returning multiple values) and JSON arrays. - @cabo \n\nThat's because the multiple values are returned as a JSON array.\n\nSince a path returns an array, it makes sense to at least consider the option of and discuss taking that array of results into account when evaluating expressions that can include paths.",
          "createdAt": "2021-03-15T23:13:24Z",
          "updatedAt": "2021-03-15T23:13:24Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote\r\n\r\n>> On 2021-03-13, at 22:16, Daniel Parker ***@***.***> wrote: But let's consider the case where the selector on the left side is evaluated such that an array is always returned, including an array of a single value. If we take the first element of that array to compare with the JSON literal on the right, we match (4) and (5), but not (6).\r\n\r\n> I\u2019m having a hard time following this conversation. Why would we want to do what you describe? Gr\u00fc\u00dfe, Carsten\r\n\r\nThe question is, what does it mean to compute the result of a JSONPath expression evaluated against the current node, and compare it to a JSON literal?  For advocates of \"return as single value\", whose case is represented in section 8 of  [minutes-109-jsonpath-00](https://datatracker.ietf.org/doc/minutes-109-jsonpath/), the answer is completely clear. The path evaluates to a single value, which can be compared to a JSON literal on the right hand side, and there is no issue.  \r\n\r\nHowever, for advocates of \"return as array\" (the majority), the answer is less clear, as the JSONPath Comparison examples illustrate. Rules need to be defined, and the obvious one is not equivalent to the \"return as single value\" case.\r\n\r\n",
          "createdAt": "2021-03-16T03:04:29Z",
          "updatedAt": "2021-03-16T03:48:02Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "We are completely free to define what it means to compare a literal to a nodelist.  We don't have to have the same semantics as with comparing a literal to an array (which has an obvious answer).\r\n",
          "createdAt": "2021-03-17T14:23:20Z",
          "updatedAt": "2021-03-17T14:23:20Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote:\r\n\r\n> This whole discussion is confused between this (returning multiple values) and JSON arrays. JSON arrays are items in the input. Multiple values are, just that, multiple values. (Call them, collectively, collections if you like.) Can we keep these two concepts separate?\r\n\r\nThe distinction between \"return as array\" and \"return as single value\", as discussed in [minutes-109-jsonpath-00](https://datatracker.ietf.org/doc/minutes-109-jsonpath/), is well understood. In terms of existing practice,  the [JSONPath Comparisons](https://cburgmer.github.io/json-path-comparison/) show that 9 out of 41 implementations return a single value where only one match is possible, 32 return an array.  \r\n\r\nIn [Goessner](https://goessner.net/articles/JsonPath/), the \"collection\" of \"multiple values\" _is_ a JSON array. Goessner writes\r\n\r\n\"Please note, that the return value of jsonPath is an array, which is also a valid JSON structure. So you might want to apply jsonPath to the resulting structure again or use one of your favorite array methods as sort with it.\"\r\n\r\nAs far as I can tell, _all_ JSONPath implementations, whether \"return as array\" or \"return as single value\", are consistent with the idea of JSON in, JSON out. That the result can be provided back as input. That's true when the \"value\" option is specified, and also when the \"path\" option is specified.\r\n",
          "createdAt": "2021-03-17T14:44:17Z",
          "updatedAt": "2021-03-17T14:45:36Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I don't doubt that many implementations implement returning the nodelist as returning an array.  That was not my point.\r\nThe nodelist returned by a nested query does not need to be reified as a JSON array before it is compared to a literal.\r\n",
          "createdAt": "2021-03-17T14:50:07Z",
          "updatedAt": "2021-03-17T14:50:07Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU4Mzc5NzQ3MzU=",
      "title": "The \"current value\" or \"current node\", and the meaning thereof",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/76",
      "state": "CLOSED",
      "author": "danielaparker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This post opens a discussion of the meaning of \"current value\" or \"current node\" in JSONPath, with comparisons to similar concepts in JMESPath and XPath 3.1. (I've moved content here from a comment in the related but soon to be closed #59.)\r\n\r\nFirst, consider the analogous notions of \"current object\", \"current node\", and \"context item\" in [Goessner JSONPath](https://goessner.net/articles/JsonPath/), [JMESPath](https://jmespath.org/specification.html#current-node), and [XPath 3.1](https://www.w3.org/TR/xpath-31/#eval_context). \r\n\r\n&nbsp;|Goessner JSONPath|JMESPath|XPath 3.1\r\n----|-----------|-----------|-----------\r\nWhat is it called?|\"current object\"<sup>[1](#footnote1)|\"current node\"<sup>[2](#footnote2)</sup>|\"context item\" (or \"context node\" if the context item is a node)<sup>[3](#footnote3)</sup>\r\nWhere is it defined?|[Goessner](https://goessner.net/articles/JsonPath/)|[JMESPath Specification](https://jmespath.org/specification.html#current-node)|[XPath 3.1 W3C Recommendation](https://www.w3.org/TR/xpath-31/#eval_context)\r\nHow is it represented?|`@`|`@`|`.`\r\nHow is it defined?|By example (see below) and \"using the symbol '@' for the current object\"|\"The current-node token can be used to represent the current node being evaluated...At the start of an expression, the value of the current node is the data being evaluated by the JMESPath expression. As an expression is evaluated, the value the the current node represents MUST change to reflect the node currently being evaluated. \"|\"The context item is the item currently being processed. When the context item is a node, it can also be referred to as the context node. The context item is returned by an expression consisting of a single dot (.).\"\r\nHow does it appear in the grammar?|&nbsp;|current-node  = \"@\"|ContextItemExpr &verbar; ::= &verbar; \".\"\r\nExplicit or understood?|Always explicit|Usually understood - \"JMESPath assumes that all function arguments operate on the current node unless the argument is a literal or number token. Because of this, an expression such as @.bar would be equivalent to just bar, so the current node is only allowed as a bare expression.\"|Sometimes explicit - `.//para` selects the para element descendants of the context node. Sometimes understood - `para` selects all para children of the context node\r\nHow is it used?|`$.store.book[(@.length-1)].title` `$.store.book[?(@.price < 10)].title`|`foo[].[count(@), bar]`<sup>[4](#footnote4)</sup>|`.//para` `/books/book[fn:count(./author)>1])`\r\n\r\n<a id=\"footnote1\">1</a>.  In Goessner JSONPath, the term \"object\" used here seems to refer to any JSON value. The term \"node\" is only used when referring to XPATH 1.\r\n<a id=\"footnote2\">2</a>.  In JMESPath, the term \"node\" is undefined, but can be considered synonymous with \"JSON value\". In JMESPath, results may be elements in the original JSON document, or newly created elements that don't exist in the JSON document, preserving paths into the original JSON document doesn't figure into it.\r\n<a id=\"footnote3\">3</a>. For XPath 3.1, \"node\" is defined in the [XQuery and XPath Data Model 3.1 W3C Recommendation](https://www.w3.org/TR/xpath-datamodel-31/#Node). Among other properties, each node must have a unique identity, distinct from all others. Element nodes have a property children and a property parent, possibly empty.\r\n<a id=\"footnote4\">4</a>. In this JMESPath expression, `foo` is understood to mean `@.foo`, and `bar` is understood to mean `@.bar`. The only place where the symbol `@` is used explicitly is as a \"bare expression\", as shown in the argument to the `count` function.\r\n\r\n\"current object\" in Goessner JSONPath as represented by `@` is clearly underspecified, but can easily be understood in the more general sense in JMESPath, as \"the node currently being evaluated\", or in XPath 3.1, as \" the item currently being processed\".\r\n\r\nThe Goessner examples:\r\n```\r\n$.store.book[(@.length-1)].title                   (1)\r\n\r\n$.store.book[?(@.price < 10)].title               (2)\r\n```\r\nare fully consistent with the more general sense. In (1), the \"current value\" @ represents the array `$.store.book`, in (2), the `?` connotes iteration over the array, and `@` represents an array element.\r\n\r\nIn my opinion, it's natural to generalize that at `$`, the current value `@` represents the JSON document; at `$.store`, it represents the result of evaluating `$.store`, and so on.\r\n",
      "createdAt": "2021-03-22T17:57:47Z",
      "updatedAt": "2021-04-28T18:48:06Z",
      "closedAt": "2021-04-28T18:48:06Z",
      "comments": [
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds reasonable. Legacy implementations [don't show](https://cburgmer.github.io/json-path-comparison/results/filter_expression_on_object.html) clear consensus on `$[?(@.key)]`, but at least some of them (including JayWay's one) behave in the way you described.\r\n\r\nShould we define \"current value\" only inside a filter explicitly? The only possible use outside of filter, as far as I can see it, is just replacing `$` in the beginning; but in this case `@` should represent the result of evaluating an empty string. So, this question may be related to the question \"can `$` in the beginning be optional\"; and if yes - then empty string is evaluated equally to `$`, which makes your definition consistent outside of filter.",
          "createdAt": "2021-03-23T21:51:48Z",
          "updatedAt": "2021-03-23T21:51:48Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "MDU6SXNzdWU4MzgwMjczNjg=",
      "title": "What do we want our RFC to do?",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/78",
      "state": "OPEN",
      "author": "timbray",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(Co-chair hat off)\r\n\r\nThis is related to #63 (\"Respect Implementations\").  I think it will help us if we think about what we want the output of our work to be.  It is a fact that there are lots of implementations, that they are incompatible in places, and that few of them are likely to change as a result of us publishing an RFC.  Given that, what are reasonable goals for our work bearing our charter in mind?\r\n\r\nFirst, provide a formal, readable, and helpful specification of JSONPath syntax as it exists.  To the extent that there is \"consensus\" (a matter of judgment, not voting) we can use MUST here.   If we encounter a case where there are broad divergences in with more than 1 in widespread use, we make a judgment call which to describe - it's OK to describe more than one option - and possible to use SHOULD.  For example, there are a significant number of implementations that support initial \"@\" and so we should describe that syntax.\r\n\r\nSecond, provide interoperability guidance (one of my favorite parts of 8259).  For example, for interoperability, users SHOULD avoid JSONPaths with initial \"@\".  Another example: they SHOULD prefer bracket notation to dot notation so they don't have to worry about selectors with hyphens in them.  I suspect there are lots of other opportunities to do this usefully.\r\n\r\nThird, provide lots and lots of examples.  For every fragment of syntax, offer examples. There are a few sections that lack this currently.\r\n\r\nFourth (maybe not possible) find a way to include (if only by reference) the existing work from Glyn and cburgmer which provides concrete data about expected inputs and outputs, and variations observed in the field.\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2021-03-22T19:09:28Z",
      "updatedAt": "2021-03-28T18:54:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "When I was faced with using JSONPath for the first time, it required guesswork and experimentation because the implementation concerned was essentially undocumented. Guesswork and experimentation can lead to dependency on unintended or unstable behaviour. This was not satisfactory. Also, any bug fixing of the implementation in the absence of a specification would not necessarily lead to convergence. One benefit of an RFC would be to clearly specify (common) behaviour of JSONPath such that implementations could either migrate to supporting that behaviour or, failing that, could at least document which standard behaviours they support and how they deviate from standard behaviour. Given a RFC and supposing the implementation I was using was still undocumented, I would have performed experiments on the implementation to see which standard behaviours it supported. I could even have contributed the results to form partial documentation since the implementation was open source.\r\n\r\nSimilarly, when I had to implement JSONPath, I found it was necessary to come up with my own specification of syntax and semantics. @cburgmer's comparison project gave me a consensus to aim for, but outside that consensus, there was a lot of latitude and I had to make several policy decisions which, being relatively new to JSONPath, I wasn't certain about. If an RFC had existed, I would have tried to implement it, or at least a subset.\r\n\r\nSo, for me, it is more important that a RFC provide a clear and unambiguous specification of common behaviour of JSONPath rather than necessarily exploring features provided by a minority of implementations. I'm certainly not looking for innovation or new features to be added to JSONPath by a RFC because I want to encourage implementations to (slowly) migrate towards standard behaviour over time and I'd like to minimise the cost of developing new implementations. Also, from a usability point of view, I think \"less is more\", so it's important to keep the scope of the RFC fairly small to avoid producing a large, and potentially unreadable, document.",
          "createdAt": "2021-03-23T06:57:36Z",
          "updatedAt": "2021-03-23T06:57:36Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@glyn:\r\n> So, for me, it is more important that a RFC provide a clear and unambiguous specification of common behaviour of JSONPath rather than necessarily exploring features provided by a minority of implementations.\r\n\r\n\r\nI will use regex (#70) again as an example:\r\nYour priority is clearly (unintentionally) against regex, [which are implemented by a minority](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/70#issuecomment-803355900) (11 implementations), moreover expressions using them aren't even portable: when used on some notable implementations an unexpected (not empty) result is given.\r\nAlso I expect that choosing the regex flavor is something that matters for compatibility and it will be even a more painful choice. For example, you mentioned re2, but it is not widely available and I'm not even sure if any implementation is actually using it.\r\n\r\n@glyn:\r\n> Also, from a usability point of view, I think \"less is more\", so it's important to keep the scope of the RFC fairly small to avoid producing a large, and potentially unreadable, document.\r\n\r\nSo for instance your point of view is again against regex, according to #70 there is a lot of specification work (and a lot of text needs to be written).\r\n\r\nI think that regex are useful, but do we wish excluding them?\r\n\r\nI don't think so, I think that we need a different attitude if we want standardize something useful. I believe that there is a number of topics that will run into the same kind of problems, if we stick to this idea.\r\n\r\nFurthermore,\r\n\r\n@glyn:\r\n> So, for me, it is more important that a RFC provide a clear and unambiguous specification of common behaviour of JSONPath rather than necessarily exploring features provided by a minority of implementations. I'm certainly not looking for innovation or new features to be added to JSONPath by a RFC\r\n\r\nIs your point of view compatible with our charter?\r\n\r\nThe draft charter was:\r\n> The WG will develop a standards-track JSONPath specification, with\r\n> the primary goal of capturing the common semantics of existing\r\n> implementations and, where there are differences, choosing\r\n> semantics with the goal of causing the least disruption among\r\n> JSONPath users.\r\n\r\nI will quote Barry Leiba, that asked to change it:\r\n> I fear that this text appears to say that we primarily want to develop a\r\n> dumbed-down compromise mush, and I'm sure that's not what we really mean.  The\r\n> *primary* goal is, surely, to develop a specification for JSONPath that is\r\n> technically sound, complete, and useful.\r\n\r\nAnd the following has been proposed:\r\n> The WG will develop a standards-track JSONPath specification that\r\n> is technically sound and complete, based on the common semantics\r\n> and other aspects of existing implementations.  Where there are\r\n> differences, the working group will analyze those differences and\r\n> make choices that rough consensus considers technically best, with\r\n> an aim toward minimizing disruption among the different JSONPath\r\n> implementations.\r\n     \r\nHonestly, I think that your point of view (which I quoted before) is *not compatible* with the aim of the charter.\r\n\r\nI wish we succeed in writing and standardizing a feature rich (e.g. which may include regex and other features), that is valuable for users (again users need features) \r\n\r\nI'm pretty sure that if we standardize something interesting, users will prefer this to the legacy implementations.\r\n\r\nOf course we need to stay coherent with our core values, that are described in Goessner's article, but this is not in contradiction with reasonable adjustments, polishing and additions (such as regex) to it.\r\n\r\nSome disruptions will happen anyway (we need to make a choice about filters at a certain point, and we are going to define a DSL for them), but it will happen for a reason.\r\n\r\nI also wish you understand that deferring difficult choices is not helpful, maybe we rather need to discuss them as soon as possible. We don't need writing the spec for all of them right now, but we need to discuss and check consensus for several of them as soon as possible so we don't waste precious time.\r\n\r\nAnyway if your plan is just mapping the status quo and writing a document about a common interoperable subset, I think that might be useful for some users, however it sounds to me  quite sterile (and I'm not interested to spend my time on it) and I think that there isn't any need of a standard or a discussion on it for just gathering facts about existing implementations.\r\n\r\n@timbray I acknowledge that you are a heavy JSONPath user and you don't want to see useless disruptions, my aim is to avoid them too, but we also need  to acknowledge that some disruptions may happen (e.g. no one is going to replace `$.foo` with `\u20ac.foo` ;) ).\r\n",
          "createdAt": "2021-03-23T15:07:28Z",
          "updatedAt": "2021-03-23T15:10:06Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@bettio I was simply expressing my, perhaps idealistic, preference for what I want our RFC to do, so that the WG knows where I'm coming from. I wouldn't attempt to suggest this as a consensus in the WG. If the RFC does more than I'd like without becoming bloated and unreadable, that's a bonus. Now you know where I am coming from, hopefully the motivation for some of my comments in others issues will be clearer.\r\n\r\nOn regexes, I fully expect we'll need to come up with some kind of compromise rather than omit them altogether. (BTW [my implementation](https://github.com/vmware-labs/yaml-jsonpath/) supports RE2. ;-) )",
          "createdAt": "2021-03-23T16:36:26Z",
          "updatedAt": "2021-03-23T16:37:03Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@glyn:\r\n> On regexes, I fully expect we'll need to come up with some kind of compromise rather than omit them altogether.\r\n\r\nYes, we really should support them, however we need to stay inside of our decision process frame (I'm strongly against any kind of cherry picking or any double standard, so let's agree on a common ground and let's stick to it).\r\n\r\nSo, we can have regex *if our common decision process allows* us to: accept features implemented by a minority (just 11 implementations), eventual disruptions (they will happen for sure with regex), features that are not part of the common subset (regex are out of that subset) or any semantic/flavor that doesn't already exist (or which is not already part of existing implementations or just a couple of them).\r\n\r\nTo be honest I don't feel like at the moment we share the right set of values to allow regex, but we can fix that and we can allow regex and other features.\r\nOn the other side I feel like that the charter already allows us to support such similar features, so it is just up to us, and I feel like that we are just limiting ourself without any good reason.\r\n\r\nI'm on the side of regex, because we should build something \"based on existing implementations\", not \"limited to existing implementations\". And we should work towards something sound and complete, not a compromise mush.\r\n\r\n",
          "createdAt": "2021-03-25T17:46:37Z",
          "updatedAt": "2021-03-25T17:56:41Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "Let's try to write a proposal that may hopefully make everyone happy:\r\n\r\nThe RFC will contain a JSONPath Core subset that is meant for interoperability across about 70%~90% of existing implementations (the number depends on the extent of the Core subset) and for transitional purposes.\r\nThe RFC will contain also a number of extensions and additions built around JSONPath Core that are *required* for a full JSONPath implementation. The full JSONPath set is not limited to existing implementations and will contain everything is needed for a technically sound and complete specification (regex will be part of this set).\r\n\r\nJayway Java JSONPath will be likely a JSONPath Core implementation.\r\n\r\nDo you think that this approach will be viable and able to match the 2 different point of view?",
          "createdAt": "2021-03-26T00:26:06Z",
          "updatedAt": "2021-03-26T00:31:37Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Obviously, restricting the standard (or even its core) to the places where all the holes in the Swiss cheese align is not going to lead to a successful specification.  I'd rather state this as an objective, i.e., we don't have to do it when it is not possible to do it.  Even limiting ourselves to existing practice is thinking too small, because there may be a good way forward that none of the individual implementations were forced to take because they could always cook their own soup.\r\n\r\nIn general, the discussion here is somewhat useful to get on the same page, but I don't expect we will have hard and fast rules at the end \u2014 we need to do the right thing instead.",
          "createdAt": "2021-03-26T09:53:26Z",
          "updatedAt": "2021-03-26T09:53:26Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "My primary guiding principle is Minimalism. As a bad example I would consider bloated SVG webstandard, purely designed by committee. Browser vendors were reluctant for a very long time before they finally started to implement it. \r\n\r\nIn contrast, current JSONPath situation can be seen beneficial, as there is already a lot of practical experience with numerous implementations from which the WG can learn. \r\n\r\nLooking at some standards, we have\r\n\r\n* JSON RFC 8259 (16 pages)\r\n* JSON Pointer RFC 6901 (8 pages)\r\n* JSON Schema ID (19 pages)\r\n* XPath 1.0 (30 pages)\r\n* XPath 3.1 (186 pages)\r\n\r\nPlease don't get me wrong. I do not want to limit the page count to ... say 25, but I want to minimize size of the specification ... and thus the hurdle for future implementors. It seems to work, when you look at the overall size of my proposal from 2007. So how can we cover only the essentials (examples included) ?\r\n\r\n* use [Pareto principle](https://en.wikipedia.org/wiki/Pareto_principle) ... the 80/20 rule already quoted by Tim.\r\n* \"If in doubt, leave it out\" ... We don't need to decide for one side, if two implementions disagree in one aspect. It might not be essential.\r\n* If two implementations disagree in one essential aspect, the WG pragmatically decides for the best of both ... or for an even better third.\r\n\r\nThis is roughly inline with ...\r\n\r\n> The WG will develop a standards-track JSONPath specification that\r\nis technically sound and complete, based on the common semantics\r\nand other aspects of existing implementations ...\r\n\r\nOur biggest challenge here seems to define \"*complete*\" ...",
          "createdAt": "2021-03-26T10:20:26Z",
          "updatedAt": "2021-03-26T10:20:26Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@goessner:\r\n> My primary guiding principle is Minimalism. As a bad example I would consider bloated SVG webstandard, purely designed by committee. Browser vendors were reluctant for a very long time before they finally started to implement it.\r\n\r\nThat would be a disaster: we can all agree that it must not happen.\r\n\r\nHowever I don't have any evidence at the moment that we are running into that problem, conversely most of the proposals I saw so far are quite reasonable.\r\n\r\n(Does anyone have any kind of proof that this is happening right now?)\r\n\r\nI feel like that we are maybe just bikeshedding (and wasting our time) against a situation that might never happen, so maybe we should take actions against it just in case it happens.\r\n\r\nSome additional thoughts: \r\n\r\n@goessner:\r\n> use Pareto principle ... the 80/20 rule already quoted by Tim.\r\n\r\nIf my users/customers complain about missing features 2 times on 10, I cannot be happy at all (I would call that a disaster), if that kind of annoyance is caused by a compliant JSONPath I will be asked to extend it for sure (regardless of the RFC or other implementations).\r\nThe result would be a jungle of custom additions that will bring us back to the original problem.\r\n\r\nAlso RFC compliancy can be appealing only if it has a reasonable number of features, otherwise people will continue to customize their implementations regardless of our work. If no one will use the work produced by this WG it means that we are just wasting our time.\r\n\r\n@goessner:\r\n> \"If in doubt, leave it out\" ... We don't need to decide for one side, if two implementions disagree in one aspect. It might not be essential.\r\n\r\nI think that implementations are frequently focused on use-cases in their developers mind. It means that some features that are not compelling for an important use-case, might be vital for another important use-case.\r\nSo I don't agree here, otherwise we might end into rejecting features like regex (and I would regret that).\r\n\r\nAnyway I think that we should lean towards including features, rahter excluding them.\r\nAgain I have no evidence that we actually risk of running into a bloated specification, in the worst case we can clean up superfluos features during review phase.\r\n\r\n@goessner:\r\n> If two implementations disagree in one essential aspect, the WG pragmatically decides for the best of both ... or for an even better third.\r\n\r\nSadly \"best\" is quite subjective, I would rather evaluate:\r\n- Internal consistency\r\n- Implementations weighted consensus (e.g. my implementation is not widely used as Jayway)\r\n- Practical implementation effort (is X hard or simple to implement?)\r\n\r\n@goessner:\r\n> Our biggest challenge here seems to define \"complete\" ...\r\n\r\nI think that a reasonable rough upper limit might be XPath 1.0.\r\n\r\n**Proposal 2**: Let's just close this conversation and let's include all the features (that are supported by reasonable arguments).\r\n\r\nAlso we should encourage people to open PR for the features they want in, so we are not taking more editor's time and we can involve more people into this WG.\r\n",
          "createdAt": "2021-03-26T11:49:08Z",
          "updatedAt": "2021-03-26T11:49:08Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "It's helpful to look at the major features that are still to be added (in addition to the processing model):\r\n\r\n1. nested descendants (`..`) - seems uncontentious - just needs a PR.\r\n2. filter expressions (`?()`) - contains some areas where there is a lack of consensus, so probably best to subdivide this.\r\n3. \"script\" expressions (`()`) - I'd hope we could offer minimal support for these without too much contention.\r\n\r\nAny I've missed?",
          "createdAt": "2021-03-26T12:27:57Z",
          "updatedAt": "2021-03-26T12:27:57Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-26, at 18:16, Daniel Parker ***@***.***> wrote:\n> \n> \t\u2022 Avoid introducing new terms such as \"data item\" that are \"Also called a JSON value.\" Stick to 8259 terms wherever possible.\n> \t\u2022 Focus narrowly on the grammar and the semantics of each selector, rather than talk about \"processing models\" or general things. By comparison, XPath talks about \"processing models\", the JMESPath specification, which is an exceptionally clear specification of a JSON transformation language, doesn't mention \"processing models\" at all.\n\nWe don\u2019t need the terms data item or processing model.\nWe don\u2019t need any terms at all and can explain everything everywhere again and again.\nBut if we want to keep the spec concise, clear thinking helps.\nGood terms help clear thinking.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-26T17:25:49Z",
          "updatedAt": "2021-03-26T17:25:49Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> Regarding \"designed by committee\", the WG is itself a committee, which is proper for a standardization body. \r\n\r\nYes, of course  ... but in the initial SVG committee there was only a single implementor from \"Macromedia\" &ndash; later aquired by \"Adobe\" &ndash; badly influencing and bloating the emerging web standard.\r\n\r\n> The JSON Pointer RFC, which is less complicated than JSONPath, doesn't follow the 80/20 rule, its specification is unambiguous. All implementations will behave the same, and hence are interoperable. \r\n\r\nIf we would skip (or haven't invent)\r\n\r\n* filter expressions\r\n* current node selector\r\n* ideas for regex's\r\n\r\nwe would be interoperable  as well. And even if we strictly follow Greg's and yours proposal for only basic math and boolean operators in #17 and also a very basic subset of regex-rules we can tell everyone then, that we are unambiguous and complete now on 100 %.\r\n\r\n> @bettio suggested the possibility of a proposal that would \"make everyone happy\", but I think that may be somewhat ambitious. I would be satisfied with a proposal that made Stefan Goessner happy. It is after all his creation.\r\n\r\nThank you very much for that nice compliment :)",
          "createdAt": "2021-03-26T18:14:37Z",
          "updatedAt": "2021-03-26T18:14:37Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What constitutes \"breaking\" an implementation?\r\n\r\n- Adding something to the spec that an implementation doesn't support?\r\n- Not including something that an implementation already supports?\r\n- Defining the behavior of a supported syntax in a way different to the implementation?\r\n\r\nI'd like to highlight the discussion at #88 on unions.  My implementation already doesn't support multiple indices of any kind, so adding this concept at all \"breaks\" my implementation, according to the above scenarios.\r\n\r\nIs this really a break though?  The spec has required something that my implementation doesn't support.  But I never claimed to be in compliance with the spec.  I couldn't have claimed that because the spec didn't exist when I published the library.  That means that the spec could _completely overhaul_ the syntax, and my implementation wouldn't break.  It still adheres to what it claims to.  That someone published a document that says \"this is what JSON Path is now\" doesn't change what my implementation claims to support.\r\n\r\nConsider my JSON Schema library.  It claims to support drafts 6 through 2020-12 (we had a version scheme change a bit ago).  When the next draft is published, probably draft 2021-_something_, my implementation will still be in compliance with what it claims.  It doesn't claim to support the new draft, and the draft's mere existence doesn't break anything in my implementation.\r\n\r\nNow, if I want to be able to claim compliance to this new JSON Path spec, I'll need to make updates, and I'm fine with that.  It makes sense that I would have to.\r\n\r\nI honestly don't think that we can create a specification that won't break anyone (without making it uselessly simplistic) or to which any single implementation will be able to claim compliance without having to update _something_.\r\n\r\nImplementations should expect to have to change in order to comply with this new specification.\r\n\r\nI think this is the line of thought that we need to take when we consider what a breaking change is.  We can try to minimize that impact as much as possible, but we're not going to be able to eliminate it.\r\n\r\nTherefore I think we need to put less weight on the idea of not \"breaking\" implementations because they're going to need updates, regardless of what we do.\r\n",
          "createdAt": "2021-03-27T22:36:40Z",
          "updatedAt": "2021-03-27T22:36:40Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "> What constitutes \"breaking\" an implementation?\r\n\r\nI think that breaking for us means turning existing valid expresions for a certain implementation invalid from the RFC point of view (or changing their behavior). So the implementation will have to decide whether comply with the new RFC or invalidating already existing user expresions.\r\n\r\ne.g. changing `$.foo` in `\u00a3.foo` is breaking, accepting also `@.bar` as an addition (while also accepting `$.foo` with no changes to it) is not breaking. \r\n\r\nAvoiding changing code is not a point. This is going to happen, otherwise it means that our job here is mostly useless.\r\nFrom my point of view my users are more important than my code.\r\n\r\n> Adding something to the spec that an implementation doesn't support?\r\n\r\nnot breaking\r\n\r\n> Not including something that an implementation already supports?\r\n\r\nbreaking, but it may allow some kind of legacy additional features with a reasonable effort. It might not work in certain situations.\r\n\r\n> Defining the behavior of a supported syntax in a way different to the implementation?\r\n\r\nbreaking and requires user knowledge about the change.\r\n\r\n\r\n> Is this really a break though? The spec has required something that my implementation doesn't support. But I never claimed to be in compliance with the spec. I couldn't have claimed that because the spec didn't exist when I published the library. That means that the spec could completely overhaul the syntax, and my implementation wouldn't break. It still adheres to what it claims to. That someone published a document that says \"this is what JSON Path is now\" doesn't change what my implementation claims to support.\r\n\r\nThis is a good argument. Anyway, I honestly don't mind changing my implementation code, I mostly care about users expresions.\r\n\r\n> Now, if I want to be able to claim compliance to this new JSON Path spec, I'll need to make updates, and I'm fine with that. It makes sense that I would have to.\r\n\r\nI agree.\r\n\r\n> I honestly don't think that we can create a specification that won't break anyone (without making it uselessly simplistic) or to which any single implementation will be able to claim compliance without having to update something.\r\n\r\nIndeed. 100% agree.\r\n\r\n> Implementations should expect to have to change in order to comply with this new specification.\r\n\r\nRight.\r\n\r\n> Therefore I think we need to put less weight on the idea of not \"breaking\" implementations because they're going to need updates, regardless of what we do.\r\n\r\nI completely agree.\r\n",
          "createdAt": "2021-03-28T01:19:30Z",
          "updatedAt": "2021-03-28T01:19:30Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that breaking currently valid query expressions is something most implementations will want to avoid. I'm not convinced that should be an absolute constraint on the standard, since implementations always have the option of not supporting the standard. (The standard would still have some value for such implementations as a point of reference for documentation.) Of course, we shouldn't make such changes lightly, but let's not tie our hands prematurely either. Let's discuss specific cases on their merits, bearing in mind the general desire not to break currently valid query expressions.",
          "createdAt": "2021-03-28T07:41:20Z",
          "updatedAt": "2021-03-28T07:41:20Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "#88 is another example of proposal which:\r\n1. no existing implementation is implementing it right now\r\n2. introduces an addition to the existing \"common\" syntax\r\n3. increases the specification surface (e.g. multiple expressions combined with an | operator)\r\n4. requires a non-negligible amount of work\r\n\r\nI'm ok with all the previous points, and I would like to get involved into #88 discussion which is interesting.\r\n\r\nHowever before spending time on it, if anyone wants to stop it with a \"it is incompatible with our WG charter\" comment, I would like to ask to let us know here so we don't spend our precious time on a dead end discussion.\r\n\r\nHonestly I think that #88 is 100% compatible with our charter, and I think that it should be discussed.\r\nI think it should be accepted or rejected according to technical arguments rather than arguments about the WG charter itself.\r\n\r\nSo if we are going to discuss #88 further (hence investing more time investigating it) I think that clearly means that there is consensus about its compatibility with the charter and that previous points are ok for most of us (therefore we are implicitly agreeing  that this issue is resolved).",
          "createdAt": "2021-03-28T11:18:24Z",
          "updatedAt": "2021-03-28T11:20:43Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I would say the discussion in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88 is part of thrashing out the union feature and so is compatible with the WG charter.",
          "createdAt": "2021-03-28T11:31:47Z",
          "updatedAt": "2021-03-28T11:31:47Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@glyn: I wish to read a feedback from you about my last post.\r\n\r\nDo you agree with my points 1-4? If you don't agree with any of them, can you tell us which one and why you don't agree? ",
          "createdAt": "2021-03-28T13:10:48Z",
          "updatedAt": "2021-03-28T13:11:39Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@bettio Yes, I agree with those points.",
          "createdAt": "2021-03-28T15:44:29Z",
          "updatedAt": "2021-03-28T15:44:29Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "@glyn thanks for your feedback.\r\n\r\nI will take part into that discussion as we agreed that those points 1-4 are compatible with our charter (and not required by it). As you know, it really matters for me not spending time on a discussion that is going to be \"cancelled\" for \"charter compatibility\" reasons.\r\n ",
          "createdAt": "2021-03-28T18:54:24Z",
          "updatedAt": "2021-03-28T18:54:24Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU4Mzk1NjIxNjk=",
      "title": "Fix ABNF syntax checker",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/81",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "The syntax appears to be broken currently:\r\n```\r\n$ scripts/gen.sh\r\n.refcache/reference.RFC.3629.xml: renewing (stale by 16.7 days) from https://www.rfc-editor.org/refs/bibxml/reference.RFC.3629.xml\r\n....\r\n Created file draft-ietf-jsonpath-base.txt\r\n\r\n Created file draft-ietf-jsonpath-base.html\r\n\r\nstdin(0:0): error: state 2, token $end: syntax error, unexpected $end, expecting RULENAME or CWSP or CRLF\r\nparsing failed: 1 errors encountered\r\n```",
      "createdAt": "2021-03-24T10:13:02Z",
      "updatedAt": "2021-11-09T21:02:43Z",
      "closedAt": "2021-11-09T21:02:43Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Could the gen.sh script leave the .abnf around for people to separately consume?  It currently leaves .html, .xml, and .txt around, which is redundant with the gh-pages info left by I-d-template.",
          "createdAt": "2021-03-24T10:27:36Z",
          "updatedAt": "2021-03-24T10:27:36Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "It appears that this is fixed now.",
          "createdAt": "2021-11-09T21:02:43Z",
          "updatedAt": "2021-11-09T21:02:43Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU4Mzk1NjMxNDk=",
      "title": "Check ABNF syntax in CI",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/82",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "help wanted",
        "has PR"
      ],
      "body": "`scripts/gen.sh` exits with status code 0 if the syntax is correct. This needs to be driven from a CI check so that syntax checks are performed on each PR and on merges to master.",
      "createdAt": "2021-03-24T10:14:17Z",
      "updatedAt": "2021-11-10T12:02:57Z",
      "closedAt": "2021-11-10T12:02:57Z",
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Note https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/81",
          "createdAt": "2021-03-24T10:14:56Z",
          "updatedAt": "2021-03-24T10:14:56Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-24, at 11:14, Glyn Normington ***@***.***> wrote:\n> \n> \n> scripts/gen.sh exits with status code 0 if the syntax is correct. This needs to be driven from a CI check so that syntax checks are performed on each PR and on merges to master.\n\nThis requires that the tools that you are using in that script are available to the \"github actions\" CI platform.  That sure can be done, but it is its own piece of work.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-24T10:16:22Z",
          "updatedAt": "2021-03-24T10:16:22Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I can help with GitHub actions, and with setting up required docker images.\r\n",
          "createdAt": "2021-03-24T10:21:13Z",
          "updatedAt": "2021-03-24T10:21:13Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> This requires that the tools that you are using in that script are available to the \"github actions\" CI platform. That sure can be done, but it is its own piece of work.\r\n\r\nHappy for this to be done separately first, but in the past, a good validation that software has been installed is that it runs, so it might be best to attack the two together. Let's see how @bettio gets on!",
          "createdAt": "2021-03-24T10:23:04Z",
          "updatedAt": "2021-03-24T10:23:04Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "That would be great!\r\nThe fun part is making sure this integrates nicely with the existing github actions set up by I-D-template, and survives an update of the latter.",
          "createdAt": "2021-03-24T10:23:17Z",
          "updatedAt": "2021-03-24T10:23:27Z"
        },
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "I can likely spend some time on it on the weekend, so if anyone can help before the end of the week is welcome :)",
          "createdAt": "2021-03-24T10:26:49Z",
          "updatedAt": "2021-03-24T10:26:49Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> The fun part is making sure this integrates nicely with the existing github actions set up by I-D-template, and survives an update of the latter.\r\n\r\nI would suggest setting up an orthogonal github action with its own file in `.github/workflows`.",
          "createdAt": "2021-03-24T10:36:21Z",
          "updatedAt": "2021-03-24T10:36:21Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the `master` branch is going away, here are the installation instructions from the README, for posterity and for help with this issue.\r\n\r\n### Install [kramdown-rfc2629](https://github.com/cabo/kramdown-rfc2629)\r\n```\r\ngem install kramdown-rfc2629\r\n```\r\nYou may need to prefix the above command with `sudo` if it doesn't have sufficient permissions to complete the installation.\r\n\r\n### Install [xml2rfc](https://xml2rfc.tools.ietf.org/):\r\n```\r\npip3 install xml2rfc --user\r\n```\r\nThis will place the executable in `~/.local/bin`\r\n\r\n### Install [xmlstarlet](http://xmlstar.sourceforge.net/)\r\nOn macOS, issue:\r\n```\r\nbrew install xmlstarlet\r\n```\r\nOn Linux, issue something like:\r\n```\r\napt-get install -y xmlstarlet\r\n```\r\n\r\n### Install `aex` and `bap`\r\n\r\n`aex` is an ABNF extractor and `bap` an ABNF syntax checker.\r\n\r\n1. Clone https://github.com/fenner/bap\r\n2. In the cloned directory execute\r\n   1. `./configure`\r\n   2. `make`\r\n3. `aex` and `bap` binaries should now exist in the directory\r\n4. Add them to your path\r\n\r\n### Re-generate files\r\n\r\n This will:\r\n - re-generate the `.txt` and `.html` files\r\n - check the ABNF syntax\r\n\r\n```\r\nxml2rfc ./draft-ietf-jsonpath-base.xml --text --html && aex draft-ietf-jsonpath-base.txt | bap -S path -q\r\n```\r\n\r\nA script [gen.sh](scripts/gen.sh) is provided for convenience. You can also use [docker-gen.sh](scripts/docker-gen.sh)\r\nversion that installs and runs all utilities within a Docker container.\r\n",
          "createdAt": "2021-03-24T10:50:24Z",
          "updatedAt": "2021-03-24T10:50:24Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Should we put this into a TOOLS.md, so it is not buried in a closed issue?\r\n",
          "createdAt": "2021-03-24T12:22:24Z",
          "updatedAt": "2021-03-24T12:22:24Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, we probably should. Or we could add it to the contributors guide if we want to encourage contributors to check syntax as they go.",
          "createdAt": "2021-03-24T13:38:10Z",
          "updatedAt": "2021-03-24T13:38:10Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU4Mzk2ODAyNTI=",
      "title": "Terminology: next round",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/84",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Clusters of terms:\r\n\r\n* Cluster 1\r\n\r\n  * JSON value\r\n  * (data) item\r\n  * node\r\n  * location\r\n\r\n  These are related, but different.  We probably do not need all four.\r\n  (Of course, JSON value is a 8259 term, so it does not go away.)\r\n  We should decide which of these terms we want to use, and what they exactly mean.\r\n  A node seems to be a combination of a discrete JSON value and its location.\r\n  JSON value seems to imply equivalence by value (even though equivalence is undefined in RFC 8259),\r\n  while node is based on equivalence by identity.\r\n  Location seems to imply that you can get to the node (and thus the value) from it.\r\n\r\n* Cluster 2\r\n\r\n  * Argument: input to executing JSON query\r\n  * root value, root node (used as Argument, may be used in nested queries)\r\n  * current node (current item):\r\n    * input to selector function invocation, \r\n    * maybe used inside filtering/indexing selectors\r\n\r\n* Cluster 3\r\n\r\n  * selector (part of the selector chain that makes up a JSONPath query)\r\n  * (we probably need a word for) selector function \\[invocation]\r\n\r\n    This is needed if we stick to the model that each node in the\r\n    input node list is treated separately and the results are then\r\n    combined using (TBD) combine1.\r\n\r\n  * combine1 (placeholder for what combines the outputs of the selector function invocations)\r\n\r\n    This becomes important when we either resolve there is only one\r\n    combine1 function or we resolve that combine1 functions are\r\n    (within limits) implemenation specific (i.e., we give up) or that\r\n    different selectors have different combine1 functions.\r\n\r\n  All these can only be meaningfully decided once we have agreement on a processing model.\r\n",
      "createdAt": "2021-03-24T12:38:46Z",
      "updatedAt": "2021-11-09T20:57:39Z",
      "closedAt": "2021-11-09T20:57:38Z",
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... (we probably need a word for) selector function [invocation] ...\r\n\r\nperhaps ...\r\n* selection\r\n* selection process \r\n* selection step (atomic)\r\n",
          "createdAt": "2021-03-24T13:12:34Z",
          "updatedAt": "2021-03-24T13:12:34Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\n> On 2021-03-27, at 03:12, Daniel Parker ***@***.***> wrote:\n> \n> My view is that Argument is too generic a term, e.g. it is common to talk about providing an argument to a function. I like @timbray 's suggestion of root value. \"root\" is used in Goessner 2007.\n\nWe are using way more generic terms: value, object etc.\n(I\u2019d rather get rid of those first.)\n\nThe Argument is the JSON value that goes into the evaluation of the query.\nThe Argument is then viewed as a tree and *has* a root node.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-27T05:06:13Z",
          "updatedAt": "2021-03-27T05:06:13Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... using some examples ...\r\n\r\n* `$.obj['city']` ... `'city'` is the *name* of a member value `\"Berlin\"` of object `obj`. \r\n* `$.arr[12]` ... `12` is the *index* of an entry value `3.14` of array `arr`. \r\n* *location* is a general/abstract term for *name* and *index*. So `'city'` and `12` are both locations.\r\n* `$` is *name* and *location* of the root value.\r\n* A (normalized) path is a sequence of locations enclosed in brackets.\r\n* A `node` is a `location / value` pair.\r\n* A `selector` in its simpliest case is a location. Special selectors are `*, .., @`.\r\n\r\nI think with this we have a minimalistic and complete term set.",
          "createdAt": "2021-03-27T09:32:35Z",
          "updatedAt": "2021-03-27T09:32:35Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Unless I've missed a strict definition in our discussions, there can be more than one normalised path for a given location.\r\n\r\nFor instance, to identify the child node of the root node with name `a`, and assuming we are using the more general \"bracket\" form of child name (the `child` production in the current grammar), we could use an array consisting of any one of the following name components:\r\n* \"a\"\r\n* 'a'\r\n* \"u0061\"\r\n* '\\u0061'\r\n\r\nTo accommodate this, we could associate a location with an [equivalence class](https://en.wikipedia.org/wiki/Equivalence_class) of normalised paths.\r\n\r\nAlternatively, we could define a unique normalised path for each location (e.g. for names by stipulating double quotes and unicode escapes for every character, even if that would be unfriendly to end users and, for indices, by stipulating non-negative indices). I guess we could even standardise on basic Latin unicode characters and use unicode escapes for everything else, but that seems a little biased.",
          "createdAt": "2021-03-27T11:40:54Z",
          "updatedAt": "2021-03-27T11:40:54Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> * \"a\"\r\n> * 'a'\r\n> * \"u0061\"\r\n> * '\\u0061'\r\n\r\nThat is not exactly a terminology issue.\r\n\r\nIf we want the output paths to be normalized, we would need to define that normalization.\r\nIf we just want them to be stylized (e.g., bracket notation only, unsigned integer indexing or quoted name indexing) and leave representation details to the implementations, we could do that, too.\r\n\r\n(My personal view is that they should be normalized.  Single quotes are very un-JSON, and escaping non-control characters is un-2000s, so it is pretty clear that \"a\" would be the normalized form.)",
          "createdAt": "2021-03-27T12:36:55Z",
          "updatedAt": "2021-03-27T12:36:55Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> @goessner wrote:\r\n> \r\n> > * _location_ is a general/abstract term for _name_ and _index_. So `'city'` and `12` are both locations.\r\n> \r\n> I think a _location_ is an abstraction that represents a full path, \r\n\r\nI think that works best the other way around: a location is an abstraction that can be represented by a path (full path, path from the root, ...).\r\n\r\n> it has to uniquely identify a JSON value within a root value. \r\n\r\nWe don't really need locations for member names, so I would limit this to nodes.\r\n\r\n> In terms of its actual representation, it could be a normalized path, or an array of name or index components, or a name or index component with a parent.\r\n> \r\n> > * A (normalized) path is a sequence of locations enclosed in brackets.\r\n> \r\n> I think a _normalized path_ is a property of a location.\r\n\r\nIf we have normalization of paths, a normalized path can indeed be derived from the path (from the root) of the location.  (But I don't know yet whether we opt for normalization of output paths.)\r\n\r\n",
          "createdAt": "2021-03-27T12:56:39Z",
          "updatedAt": "2021-03-27T12:56:39Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "*  charming aspect of single quotes in normalized pathes would be to use them as JSON values itself without escaping ...\r\n* We should care for: There can be only one normalized path per JSON value !\r\n* If `location` is defined as the complete path, we need another universal term for `name / index`.\r\n\r\nhmm ... why not simply use `path` instead of `location` from root to value and redefine `location` as local location relative to parent value ... ?",
          "createdAt": "2021-03-27T13:54:06Z",
          "updatedAt": "2021-03-27T14:00:37Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really, really like Stefan's approach here. I it is precise and easy to\nunderstand and does the minimum amount of invention required.\n\nOn Sat, Mar 27, 2021 at 2:32 AM Stefan Goessner ***@***.***>\nwrote:\n\n> ... using some examples ...\n>\n>    - $.obj['city'] ... 'city' is the *name* of a member value \"Berlin\" of\n>    object obj.\n>    - $.arr[12] ... 12 is the *index* of an entry value 3.14 of array arr.\n>    - *location* is a general/abstract term for *name* and *index*. So\n>    'city' and 12 are both locations.\n>    - $ is *name* and *location* of the root value.\n>    - A (normalized) path is a sequence of locations enclosed in brackets.\n>    - A node is a location / value pair.\n>    - A selector in its simpliest case is a location. Special selectors\n>    are *, .., @.\n>\n> I think with this we have a minimalistic and complete term set.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/84#issuecomment-808702099>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJE5SCNZY3WXTTJ2IXN3TFWQ37ANCNFSM4ZXFS2IA>\n> .\n>\n",
          "createdAt": "2021-03-27T17:14:40Z",
          "updatedAt": "2021-03-27T17:14:40Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Sat, Mar 27, 2021 at 4:41 AM Glyn Normington ***@***.***>\nwrote:\n\n> Unless I've missed a strict definition in our discussions, there can be\n> more than one normalised path for a given location.\n>\n> For instance, to identify the child node of the root node with name a,\n> and assuming we are using the more general \"bracket\" form of child name\n> (the child production in the current grammar), we could use an array\n> consisting of any one of the following name components:\n>\n>    - \"a\"\n>    - 'a'\n>    - \"u0061\"\n>    - '\\u0061'\n>\n> While I normally run screaming in the other direction when people propose\na \"canonical form\" of anything, I think we could get away with it here. Any\nJSON string can be represented as a sequence of Unicode codepoints -\ngranted, some of them might not be *valid* codepoints - and for the purpose\nof a normalized path, we could either (a) specify UTF-8 or (b) say that the\ncodepoints are all that matters, the syntactic expression is not\nsignificant.\n\nOr am I missing something?\n\n\n\n\n>\n>\n> To accommodate this, we could associate a location with an equivalence\n> class <https://en.wikipedia.org/wiki/Equivalence_class> of normalised\n> paths.\n>\n> Alternatively, we could define a unique normalised path for each location\n> (e.g. for names by stipulating double quotes and unicode escapes for every\n> character, even if that would be unfriendly to end users and, for indices,\n> by stipulating non-negative indices). I guess we could even standardise on\n> basic Latin unicode characters and use unicode escapes for everything else,\n> but that seems a little biased.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/84#issuecomment-808719479>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJEZ5LBFNACCMOYKGGCDTFW75FANCNFSM4ZXFS2IA>\n> .\n>\n",
          "createdAt": "2021-03-27T17:17:28Z",
          "updatedAt": "2021-03-27T17:17:28Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> hmm ... why not simply use `path` instead of `location` from root to value\r\n\r\nI don't feel strongly. I think we could define an abstract \"path\" term, but I wonder if it might sound a bit odd in places in context of _JSONpath_?\r\n\r\n> and redefine `location` as local location relative to parent value ... ?\r\n\r\nI'm not sure we need a term for that. We already have names in objects and indices in arrays.\r\n",
          "createdAt": "2021-03-28T11:51:14Z",
          "updatedAt": "2021-03-28T11:51:14Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "It would help the concision to have a single common term for indexing by name and indexing by index.  I don't have a proposal, though...\r\n(\"location\" probably is not it, that term is better used the way it is now.  A location in that sense can be expressed by an output path, but it \"is\" not an output path.)",
          "createdAt": "2021-03-28T12:42:23Z",
          "updatedAt": "2021-03-28T12:42:23Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> It would help the concision to have a single common term for indexing by name and indexing by index. - @cabo \n\nThis has been brought up before.  To me, `child` is the only sensible term that covers both objects and arrays.  I know there's other discussion regarding this term, but I'm on mobile and can't find it right now.",
          "createdAt": "2021-03-28T19:28:35Z",
          "updatedAt": "2021-03-28T19:28:35Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\"child\" gives me the XPath heebie-jeebies...  But that is a reasonable working term for array element or member value (i.e., data items that result from indexing a container).\r\n\r\nWhat's missing is a term for the parameter that goes into the indexing (array index or member name).  Maybe we need to rename array index so we can use index for the combined term (which also would solve the fact that indexing otherwise isn't always related to indexes).\r\n",
          "createdAt": "2021-03-28T20:34:26Z",
          "updatedAt": "2021-03-28T20:34:44Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe we need to rename array index so we can use index for the combined term (which also would solve the fact that indexing otherwise isn't always related to indexes).\n\nThis works for me. I tend to think of a thing inside `[]` as an index, whether it's a number or a string (because the `[]` in .Net is called the \"index\" operator).\n\nIt also helps define a union as \"a set of indices\" where a single \"index\" could be a number, a string, a slice, etc. Unions can then be any combination of these things.\n\n(We should also decide on \"indices\" vs \"indexes\". I'm not sure which is more correct. [This](https://grammarist.com/usage/indexes-indices/) seems to indicate there's not a \"correct,\" but we should decide on one or the other.)",
          "createdAt": "2021-03-29T01:54:11Z",
          "updatedAt": "2021-03-29T03:19:22Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Search engine of my choice offers \"tag, label, mark\" as kind of synonyms for \"name / index\". So how do we like to talk about (including Carsten's proposal):\r\n\r\n* tag/value pair\r\n* label/value pair\r\n* mark/value pair\r\n* index/value pair\r\n\r\n\"tag\" may be too HTML'ish ... ?\r\n\r\n\r\n",
          "createdAt": "2021-03-29T07:26:53Z",
          "updatedAt": "2021-03-29T07:35:14Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Given those options, I think I'll stick with my vote for \"index\".",
          "createdAt": "2021-03-29T07:43:34Z",
          "updatedAt": "2021-03-29T07:43:34Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Don't forget \"key\" ...\r\n\r\n* key/value pair\r\n",
          "createdAt": "2021-03-29T09:53:33Z",
          "updatedAt": "2021-03-29T09:53:33Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I think we can stick with 8259 for member name.  Key is maybe indeed a candidate for \"member name or array index\".\r\n\r\nI'll propose a PR as soon as #90 is through (too many conflicts otherwise).\r\n",
          "createdAt": "2021-03-29T09:55:00Z",
          "updatedAt": "2021-03-29T09:55:00Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Following on from the previous comments, I propose to add two additional terms to the terminology list:\r\n* **Key**: Synonym for array index or object member name.\r\n\r\n* **Selector**: An atomic component of a query expression. Different selector types are ...\r\n    * Root selector `'$'`\r\n    * Current item selector `'@'`\r\n    * Nested descendants selector `'..'`.\r\n    * Dot selector `'.<name>'`, used with object member names exclusively.\r\n    * Dot wild card selector `'.*'`.\r\n    * Key selector `'[<key>]'`, where `<key>` is either an (possibly negative) array index or an object member name.\r\n    * Key wild card selector `'[*]'`.\r\n    * Array slice selector `'[<start>:<end>:<step>]'`, where `<start>`, `<end>`, `<step>` are integer literals.\r\n    * Union selector `'[<key1>,<key2>,...,<keyN>]'`, holding a comma delimited list of keys.\r\n    * Filter selector `[?(<expr>)]`\r\n\r\nI hope I did not miss a selector type. Also, I dislike the current fact, that union selectors are first class citizens in the spec. They should be equal among equal. Let's discuss ...\r\n",
          "createdAt": "2021-04-29T14:38:48Z",
          "updatedAt": "2021-04-29T14:38:48Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-04-29, at 16:39, Stefan Goessner ***@***.***> wrote:\n> \n> \t\u2022 Key: Synonym for array index or object member name.\n\nHow about maybe index/key?  index key?  indexing key?\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-04-29T15:02:36Z",
          "updatedAt": "2021-04-29T15:02:36Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "We will use that mostly in the form \"key/value pair\", where \"index/key/value pair\" is confusing. \"index/value pair\" would be better then, but \"index\" alone is often mentally completed to \"array index\".",
          "createdAt": "2021-04-29T15:27:29Z",
          "updatedAt": "2021-04-29T15:27:29Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... if agreement goes to \"index/value pair\", I can live with it ...",
          "createdAt": "2021-04-29T15:33:04Z",
          "updatedAt": "2021-04-29T15:33:04Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "~I still think \"index\" denotes an array specifically.~\n\nThinking over this again, yeah, index/value.  For reasons I've mention above.  (Sorry, typing without thinking)",
          "createdAt": "2021-04-30T06:15:36Z",
          "updatedAt": "2021-04-30T06:23:42Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "ok ... then ...\r\n\r\n* **Index**: Synonym for array index or object member name.\r\n\r\n* **Selector**: An atomic component of a query expression. Different selector types are ...\r\n    * Root selector `'$'`\r\n    * Current item selector `'@'`\r\n    * Nested descendants selector `'..'`.\r\n    * Dot selector `'.<name>'`, used with object member names exclusively.\r\n    * Dot wild card selector `'.*'`.\r\n    * Index selector `'[<index>]'`, where `<index>` is either an (possibly negative) array index or an object member name.\r\n    * Index wild card selector `'[*]'`.\r\n    * Array slice selector `'[<start>:<end>:<step>]'`, where `<start>`, `<end>`, `<step>` are integer literals.\r\n    * Union selector `'[<index1>,<index2>,...,<indexN>]'`, holding a comma delimited list of indices (indexes ?).\r\n    * Filter selector `[?(<expr>)]`\r\n\r\n",
          "createdAt": "2021-04-30T07:07:19Z",
          "updatedAt": "2021-04-30T07:07:19Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Indices\" is more correct, but \"indexes\" has become more common recently.\n\nAlso, I still think we should include the `[(<expr>)]`  selector.  I've already explained its uses in other issues, but we should keep it for no other reason than people will complain if it's not supported.",
          "createdAt": "2021-04-30T11:25:44Z",
          "updatedAt": "2021-04-30T11:26:02Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Well ... I would like to get filter selector syntax straight first. Then discuss, if and what subset of it we want to support with index selectors.",
          "createdAt": "2021-04-30T12:36:44Z",
          "updatedAt": "2021-04-30T12:36:44Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I would expect that the expression syntax would be the same. The resulting value would need to, instead of being truthy, be able to evaluate to a well-defined index, e.g. a number or string.",
          "createdAt": "2021-05-01T00:29:01Z",
          "updatedAt": "2021-05-01T00:29:01Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\r\n>   * Index selector `'[<index>]'`, where `<index>` is either an (possibly negative) array index or an object member name.\r\n>   * Array slice selector `'[<start>:<end>:<step>]'`, where `<start>`, `<end>`, `<step>` are integer literals.\r\n>   * Union selector `'[<index1>,<index2>,...,<indexN>]'`, holding a comma delimited list of indices (indexes ?).\r\n\r\nI think we should summarize all the above kinds of selector into \"indexing selectors\".\r\n(Note that the wild card selector is not there, as there is no indexing key.)",
          "createdAt": "2021-05-11T08:39:58Z",
          "updatedAt": "2021-05-11T08:39:58Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft says:\r\n> union-element =/ array-index / array-slice\r\n\r\nThus a an indexing expression can include multiple slice expressions:\r\n\r\n```\r\n[<start1>:<end1>:<step1>,<start2>:<end2>:<step2>]\r\n```",
          "createdAt": "2021-05-11T09:14:17Z",
          "updatedAt": "2021-05-11T09:14:34Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "We may want to adjust that after agreeing on a term",
          "createdAt": "2021-05-11T09:15:41Z",
          "updatedAt": "2021-05-11T09:15:41Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed by #97 (but \"resolves\" doesn't trigger closing the issue, so I'm doing this by hand here).",
          "createdAt": "2021-11-09T20:57:38Z",
          "updatedAt": "2021-11-09T20:57:38Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU4NDIxMjE2OTg=",
      "title": "Unions revisited",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88",
      "state": "OPEN",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "overtaken by events -- can we close this now?"
      ],
      "body": "Consider following JSON value ...\r\n\r\n```\r\n{\r\n  \"id\": \"v\",\r\n  \"a\": { \"u\": [1,2], \"v\": [3,4] },\r\n  \"b\": { \"u\": [11,12], \"v\": [13,14] },\r\n  \"c\": [ [21,22], [23,24] ]\r\n}\r\n```\r\n### 1. Basic Usage\r\n\r\n* JSONPath allows alternate names or array indices as a set.\r\n* Names or indices refer to their immediate parent object or array.\r\n\r\nExamples are ...\r\n\r\n| expression | result |\r\n|:--:|:--:|\r\n|`$['a','b'].u`| `[[1,2],[11,12]]` |\r\n|`$.c[0,1]`| `[[21,22],[23,24]]` |\r\n|`$.a..['u',1]`| `[[1,2],2,4]` |\r\n\r\n### 2. Unions are Syntactic Sugar\r\n\r\nExample expressions above can easily be singularized, i.e.\r\n\r\n| union expression | singularized expressions |\r\n|:--:|:--:|\r\n|`$['a','b'].u`| `$['a'].u \\| $['b'].u` |\r\n|`$.c[0,1]`| `$.c[0] \\| $.c[1]` |\r\n|`$.a..['u',1]`| `$.a..['u'] \\| $.a..[1]` |\r\n\r\nusing XPath operator `|` for `or`.   \r\nSo if all union expressions are only syntactic sugar, why do they exist? Possible answers are:\r\n\r\n* Sparing key strokes.\r\n* Better performance.\r\n\r\nLast point is the more serious one. Only implementors can show individually, if processing union expressions is more performant than multiple invocations of their JSONPath command / function with singularized expressions or otherwise round.\r\n\r\nMaybe this is motivation enough to slightly change the spec from\r\n\r\n> An implementation of this specification, from now on referred to\r\n   simply as \"an implementation\", SHOULD takes two inputs, **a JSONPath**\r\n   and a JSON value, and produce ...\r\n\r\nto\r\n\r\n> An implementation of this specification, from now on referred to\r\n   simply as \"an implementation\", SHOULD takes two inputs, **a single JSONPath or a list of JSONPath queries**\r\n   and a JSON value, and produce ...\r\n\r\nin order to allow implementors applying a list of queries to a JSON value and thus improving their performance.\r\n\r\n### 3. Duplicates and Ordering\r\n\r\nAccepting equivalence of an union expression and its set of singularized expressions according to Ch.2, neither duplicates nor ordering needs to be discussed anymore with unions, since\r\n\r\n* `$[0,0]` yields the same result as `$[0] | $[0]`, which is obviously twice the same value.\r\n* `$[1,2]` should yield the same result as `$[1] | $[2]`. Exact order might still be not deterministic.\r\n\r\n### 4. Variable Expressions\r\n\r\nI know only a handful examples using the root selector, which are of practicle value. One of them is internal referencing ala `$.a[($.id)] === $.a['v'] => [[3,4]]`. Examples with the current node selector are questionable at best, like `$.a.u[(@[0])] === $.a.u[1] => [2]`.\r\n\r\nResults of those expressions are always interpreted as names or indices (JSON literals string and number) according to the nature of their parents.\r\n\r\nNow there are rising some questions regarding this:\r\n\r\n* Do we allow those expressions, despite comments say, that their practical value is quite low.\r\n* If we do, wouldn't it be safe &ndash; as also proposed &ndash; to leave out the parenthesis, giving: `$.a[$.id]` and `$.a.u[@[0]]`.\r\n* If we allow, how to deal with nesting ... `$.a[@.u[@[0]]]` ?\r\n* If we do, it might be consequent to also allow that with unions, as in `$.a['u',$.id]`?\r\n\r\n### 5. Path Expressions\r\n\r\n@danielaparker linked to an interesting [discussion](https://stackoverflow.com/questions/55497833/jsonpath-union-of-multiple-different-paths) regarding unions containing paths, as in `$..[id,a.u]` wanting to get `$.id | $.a.u`. Applying singularization principle yields\r\n\r\n* `$..[id]` ... ok, if `'id'` was used.\r\n* `$..[a.u]` ... nonsense, since `$.a.u` was meant.\r\n\r\nUsing `$..['id',@.a.u]` according to Ch.4 is completely different. \r\n\r\n### 6. Resumee\r\n\r\n1. Union expressions can always be replaced by a set of singularized expressions.\r\n2. So union expressions might become obsolete, while propagating parallel evaluation of multiple query expressions.\r\n3. I propose to support union expressions for historical reasons and allow string or number literals exclusively.\r\n4. If variable expressions are allowed, only the root selector should be used. Current node selector as well as nested expression are disallowed.\r\n5. Unions shouldn't be first class citizens.\r\n\r\nI simply took the term \"union\" from XPath 1.0. Now I also agree with most of others here, that \"union\" should be replaced by a better term.\r\n\r\n",
      "createdAt": "2021-03-26T16:25:16Z",
      "updatedAt": "2021-11-09T22:27:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-03-26, at 17:25, Stefan Goessner ***@***.***> wrote:\n> \n> $['a','b'].u\t$['a'].u | $['b'].u\n\nSo\n\n$[\u2018a\u2019,\u2019b\u2019][\u2018u\u2019,\u2019v\u2019]\n\u2794\n$[\u2018a\u2019][\u2018u\u2019,\u2019v\u2019] | $[\u2019b\u2019][\u2018u\u2019,\u2019v\u2019]\n\u2794\n\t$[\u2018a\u2019][\u2018u\u2019] | $[\u2018a\u2019][\u2018v\u2019] |\n\t$[\u2018b\u2019][\u2018u\u2019] | $['b\u2019][\u2018v\u2019]\n\n(i.e., ausmultiplizieren)?\n\n(Please excuse the smartquotes)\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-03-26T16:42:18Z",
          "updatedAt": "2021-03-26T16:42:18Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> > An implementation of this specification, from now on referred to\r\n> > simply as \"an implementation\", SHOULD takes two inputs, **a single JSONPath or a list of JSONPath queries**\r\n> > and a JSON value, and produce ...\r\n> \r\n> in order to allow implementors applying a list of queries to a JSON value and thus improving their performance.\r\n\r\nAlternatively, we could spec the behaviour for a single JSONPath query and leave it up to implementations to support lists of queries. Since we don't seem to be in the business of standardising the API to implementations, that keeps our job a bit simpler. And we could do away with or at least simplify \"unions\".\r\n\r\n> 3. I propose to support union expressions for historical reasons and allow string or number literals exclusively.\r\n\r\nNote that whether to remove duplicate nodes would still need to be decided for cases such as `[0,0]`.\r\n",
          "createdAt": "2021-03-26T16:42:33Z",
          "updatedAt": "2021-03-26T16:42:33Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote:\r\n\r\n> On 2021-03-26, at 17:25, Stefan Goessner ***@***.***> wrote: $['a','b'].u $['a'].u | $['b'].u\r\n> So $[\u2018a\u2019,\u2019b\u2019][\u2018u\u2019,\u2019v\u2019] \u2794 $[\u2018a\u2019][\u2018u\u2019,\u2019v\u2019] | $[\u2019b\u2019][\u2018u\u2019,\u2019v\u2019] \u2794 $[\u2018a\u2019][\u2018u\u2019] | $[\u2018a\u2019][\u2018v\u2019] | $[\u2018b\u2019][\u2018u\u2019] | $['b\u2019][\u2018v\u2019] (i.e., ausmultiplizieren)? (Please excuse the smartquotes) Gr\u00fc\u00dfe, Carsten\r\n\r\nIndeed.\r\n\r\nSparing key strokes ... and not have to mentally compute what all the single paths are. I don't see \"unions\" as merely syntactic sugar.\r\n\r\nDaniel  ",
          "createdAt": "2021-03-26T20:21:09Z",
          "updatedAt": "2021-03-26T20:21:09Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner wrote:\r\n\r\n> ### 6. Resumee\r\n> 1. Union expressions can always be replaced by a set of singularized expressions.\r\n> 2. So union expressions might become obsolete, while propagating parallel evaluation of multiple query expressions.\r\n> 3. I propose to support union expressions for historical reasons and allow string or number literals exclusively.\r\n> 4. If variable expressions are allowed, only the root selector should be used. Current node selector as well as nested expression are disallowed.\r\n> 5. Unions shouldn't be first class citizens.\r\n> \r\nI don't agree with the conclusion because the notational convenience of unions has value, the convenience of not having to repeat the first part of the path is significant, especially with combinations such as in [@cabo's example](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88#issuecomment-808362881). I don't think the performance concerns are as important, singularized expression evaluation can be optimized, and unions can also execute in parallel. Although with wildcards in the path, I think the edge goes to unions.\r\n\r\nBut I think this way of looking at the problem is helpful, because it suggests what the allowed items in a union expression should be. The proposal notes that union expressions can always be replaced by a set of singularized expressions. If conversely we require that a  a set of singularized expressions can always be replaced by a single expression with unions, it suggests that the allowed items in a union should include all of indices, identifiers, slices, wildcards, and relative path expressions beginning with `@`.\r\n\r\nFor example, given the root value,\r\n\r\n```\r\n{\r\n          \"firstName\": \"John\",\r\n          \"lastName\" : \"doe\",\r\n          \"age\"      : 26,\r\n          \"address\"  : {\r\n            \"streetAddress\": \"naist street\",\r\n            \"city\"         : \"Nara\",\r\n            \"postalCode\"   : \"630-0192\"\r\n          }\r\n}\r\n```\r\nand single expressions\r\n```\r\n$..'firstName'\r\n$..address.city\r\n```\r\nthe result would be\r\n```\r\n[\r\n    \"John\",\r\n    \"Nara\"\r\n]\r\n```\r\nA corresponding expression with unions could be\r\n```\r\n$..['firstName',@.address.city]\r\n```\r\nand the result would be the same.\r\n\r\nAn alternative equivalent union would be\r\n```\r\n$[@..'firstName',@..address.city]\r\n```\r\nwhich suggests that a convenient way to provide a set of singular paths is through a union.\r\n\r\nThis understanding of unions is supported in the [jsoncons](https://github.com/danielaparker/jsoncons/blob/master/doc/ref/jsonpath/jsonpath.md) implementation, and its author thinks it's a natural generalization of the union concept. \"Variable Expressions\" don't really fit into this dual view (although the jsoncons implementation supports them with the parentheses providing disambiguation). Personally, I think \"Variable Expressions\" could be dropped, or kept for historical reasons only.\r\n\r\nDaniel ",
          "createdAt": "2021-03-26T21:38:58Z",
          "updatedAt": "2021-03-26T21:57:40Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner wrote:\r\n\r\n> ### 3. Duplicates and Ordering\r\n> Accepting equivalence of an union expression and its set of singularized expressions according to Ch.2, neither duplicates nor ordering needs to be discussed anymore with unions, since\r\n> \r\n> * `$[0,0]` yields the same result as `$[0] | $[0]`, which is obviously twice the same value.\r\n> * `$[1,2]` should yield the same result as `$[1] | $[2]`. Exact order might still be not deterministic.\r\n>\r\nI'm not convinced. I think the issue of duplicates is orthogonal to looking at unions in this way.\r\n\r\nConsider the root value\r\n```\r\n[\r\n    \"first\",\r\n    \"second\",\r\n    \"third\",\r\n    \"forth\",\r\n    \"fifth\"\r\n]\r\n```\r\nand singular paths\r\n```\r\n\"$[1]\r\n\"$[0:3]\r\n```\r\nThe resulting values and paths are\r\n```\r\n[\"second\",\"first\",\"second\",\"third\"]\r\n[\"$[1]\",\"$[0]\",\"$[1]\",\"$[2]\"]\r\n```\r\nThe issue of whether to remove the duplicate item `\"$[1]\"` would be the same for `operator |` as it would be for the union operator. It depends entirely on how the operators are defined.\r\n\r\nNote that it would be possible for an implementation to provide an option to return results with duplicates or without duplicates. The implementation jsoncons supports both options.\r\n\r\n\r\n",
          "createdAt": "2021-03-26T23:32:49Z",
          "updatedAt": "2021-03-26T23:32:49Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> I simply took the term \"union\" from XPath 1.0. Now I also agree with most of others here, that \"union\" should be replaced by a better term. - @goessner \r\n\r\nI think \"union\" is fine for \"multiple indices combined into a single bracket-notation selector.\"  Previous usages of this term had been as for what we now call a \"selector.\"  This was my primary argument in #21.\r\n\r\n> `$..['firstName',@.address.city]` - @danielaparker \r\n\r\nWhile I'm happy to have multiple indices, I think each index needs to be valid unto itself.  The current syntax wouldn't accept `$[@.address.city]`, so I don't think the union should.\r\n\r\nAdditionally, I'm not sure I like the idea of paths _being_ indices, whether or not they use `@`.  I think I would prefer `$..['firstName','city']`, though it doesn't do quite the same thing since yours looks specfically for `address.city`.  We should probably take this syntax to another issue.\r\n\r\n> The issue of whether to remove the duplicate item \"$[1]\" would be the same for operator | as it would be for the union operator. It depends entirely on how the operators are defined. - @danielaparker \r\n\r\nAgreed.  `$[0,0]` would follow suit.",
          "createdAt": "2021-03-27T05:41:51Z",
          "updatedAt": "2021-03-27T05:41:51Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> \r\n> > `$..['firstName',@.address.city]` - @danielaparker\r\n> \r\n> While I'm happy to have multiple indices, I think each index needs to be valid unto itself. The current syntax wouldn't accept `$[@.address.city]`, so I don't think the union should.\r\n> \r\nI don't fully understand this point (putting aside concerns about the @ notation.) The grammar as currently presented in the draft doesn't distinguish between bracketed expressions with one entry and unions. Bracketed expressions are defined entirely in terms of union elements. The grammar is currently incomplete, but I'm interested in what the grammar does with \"*\" and filters.  ",
          "createdAt": "2021-03-27T11:41:39Z",
          "updatedAt": "2021-03-27T11:41:39Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "As another data point on unions and filters, @cburgmer's Proposal A has a clever [restricted syntax](https://github.com/cburgmer/json-path-comparison/blob/master/proposals/Proposal_A/selector.peg) within filters which disallows \"*\" and ensures that comparisons inside filters are only operating on single values.",
          "createdAt": "2021-03-27T11:46:11Z",
          "updatedAt": "2021-03-27T11:46:11Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm perfectly happy with the union (more than one index in a bracket).  My concern was the `@` syntax inside the bracket (which you put aside).  That's not defined anywhere, and I think it should be discussed separately.",
          "createdAt": "2021-03-27T11:46:27Z",
          "updatedAt": "2021-03-27T11:46:27Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@glyn wrote:\r\n\r\n> As another data point on unions and filters, @cburgmer's Proposal A has a clever [restricted syntax](https://github.com/cburgmer/json-path-comparison/blob/master/proposals/Proposal_A/selector.peg) within filters which disallows \"*\" and ensures that comparisons inside filters are only operating on single values.\r\n\r\n@glyn, Thanks for the link. As far as I can tell the grammar in the draft hasn't changed since your original upload, it would be nice to see it move forward :-) Or do you feel that it's gone as far as it can before other issues are resolved?",
          "createdAt": "2021-03-27T12:19:16Z",
          "updatedAt": "2021-03-27T12:19:16Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> @glyn, Thanks for the link. As far as I can tell the grammar in the draft hasn't changed since your original upload, it would be nice to see it move forward :-) Or do you feel that it's gone as far as it can before other issues are resolved?\r\n\r\nI'd like to see a PR for `..` soon as well as script expressions and then probably a series of PRs for filter expressions, picking off the consensus first before we move on to the more contentious items.\r\n\r\nFor the record, I agreed with the WG chairs to focus on the compliance test suite and reference implementation (and thereby provide a counterbalance to, and critique of, the \"pure\" spec work) rather than doing more spec work. Also, I'd like the spec details to genuinely be a product of multiple minds and I don't have much written evidence that many others have yet engaged with the details of how selectors are combined into JSONPaths. When I see the PRs I just mentioned start to appear, I'll be very happy...",
          "createdAt": "2021-03-27T13:14:32Z",
          "updatedAt": "2021-03-27T13:14:32Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner wrote:\r\n\r\n> ### 2. Unions are Syntactic Sugar\r\n> Example expressions above can easily be singularized, i.e.\r\n> \r\n> union expression\tsingularized expressions\r\n> `$['a','b'].u`\t`$['a'].u | $['b'].u`\r\n> `$.c[0,1]`\t`$.c[0] | $.c[1]`\r\n> `$.a..['u',1]`\t`$.a..['u'] | $.a..[1]`\r\n> using XPath operator `|` for `or`.\r\n> So if all union expressions are only syntactic sugar, why do they exist? Possible answers are:\r\n> \r\nBut also note that in XPath, [the union and | operators are equivalent](https://www.w3.org/TR/xpath-31/#combining_seq), and parentheses are supported, so I think the XPath style | operator equivalent of `$.a..['u',1]` would be\r\n```\r\n$.a..('u' | 1)\r\n```\r\n ",
          "createdAt": "2021-03-27T13:52:36Z",
          "updatedAt": "2021-03-27T13:52:36Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "hmm ... if we agreed, that would break existing implementations ... !?",
          "createdAt": "2021-03-27T14:05:39Z",
          "updatedAt": "2021-03-27T14:05:39Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner wrote:\r\n\r\n> hmm ... if we agreed, that would break existing implementations ... !?\r\n\r\nAssuming this is replying to [this](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88#issuecomment-808736266), of course, I'm not proposing that notation :-) That notation would change the JSONPath parse tree from a simple list of selectors to a full tree with operands and operator precedence, as it is in XPath and JMESPath. I think the existing union notation is fine. I'm only suggesting that `$.a..('u' | 1)` would be the equivalent JSONPath notation if JSONPath did support the | operator in the same way as XPath, and you mentioned both in your comment. \r\n\r\nOn [this point](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88#issuecomment-808522662), there would be no break to existing implementations, it would be a generalization only.",
          "createdAt": "2021-03-27T14:23:51Z",
          "updatedAt": "2021-03-27T16:35:51Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n\r\n> I'm perfectly happy with the union (more than one index in a bracket). My concern was the `@` syntax inside the bracket (which you put aside). That's not defined anywhere, and I think it should be discussed separately.\r\n\r\nOkay, putting aside the specific notation, I'll just note that the union in XPath that inspired the union in JSONPath allows expressions as union elements (in the same way as I suggested with the @ notation, they're evaluated against the current item), and the somewhat analogous `multi-select-list` in JMESPath allows expressions (again evaluated against the current item).\r\n\r\nThese are some motivations. I think @goessner's thoughts about the equivalence of  an | operator and a union provide additional motivation if interpreted in the right way, meaning the way in which I want them to be interpreted :-)\r\n\r\nThere are a few implementations in JSONPath comparisons that support [an example of this](https://cburgmer.github.io/json-path-comparison/results/bracket_notation_with_two_literals_separated_by_dot.html) but without the leading '@'. There have been requests for this feature on stackoverflow and elsewhere.\r\n\r\nI think that covers the reasons in favour.\r\n",
          "createdAt": "2021-03-27T15:02:49Z",
          "updatedAt": "2021-03-27T15:04:10Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis wrote:\r\n> \r\n> Additionally, I'm not sure I like the idea of paths _being_ indices, whether or not they use `@`. I think I would prefer `$..['firstName','city']`, though it doesn't do quite the same thing since yours looks specfically for `address.city`. We should probably take this syntax to another issue.\r\n> \r\nI think the issue here is with the bracket notation being overloaded in JSONPath for both indexes, on the one hand, and XPath style unions, on the other. For \"indexes\" interpreted broadly, it's natural to restrict to numbers, slices and wildcards, and perhaps identifiers. For unions, it's natural to allow paths, as XPath does.  \r\n\r\nJMESPath also uses brackets for both indices and multi-select-list (analogous to unions), but in the grammar distinguishes between them. It distinguishes between a bracket specifier, with one element,\r\n```\r\nbracket-specifier = \"[\" (number / \"*\" / slice-expression) \"]\" / \"[]\"\r\nbracket-specifier =/ \"[?\" expression \"]\" ; analogous to JSONPath filter\r\n```\r\nand a multi-select-list, which only allows comma separated expressions (paths). In JMESPath, identifiers cannot start with a number, so there is no ambiguity.\r\n\r\nBut even without that grammatical distinction, there would be no ambiguity to allow both indexes and paths as union elements in JSONPath unions.\r\n\r\nThe reason for raising this in this issue is that it fits naturally with @goessner's discussion about the equivalence of the 'or' operator and unions, and clearly in the `or` operator paths are allowed. In XPath, the 'or' operator is explicitly equivalent to the union, and any union can be replaced anywhere in the path by an equivalent `or` operator, with parenthesis.\r\n\r\n",
          "createdAt": "2021-03-27T16:18:12Z",
          "updatedAt": "2021-03-27T16:44:35Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to put what qualifies as an \"index\" (used here to describe a single element inside the bracket notation, e.g. `[1]` or `['foo']`) in another issue.  This issue seems to center around supporting more than one \"index\", i.e. a \"union\".\r\n\r\nI am fine with combining more than one \"index\" separated by commas.  Further, whatever is decided to qualify as an \"index\" should be unionable in this way.  For example, these should all be valid:\r\n\r\n- `$[1,'foo']`\r\n- `$['foo',-1]`\r\n- `$[1,'foo',3:5]`\r\n\r\nwhere `1`, `foo`, `-1`, and `3:5` are all examples of an \"index\" as used in this comment.  (We should probably have a generic term for this. Also see @goessner's [comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/84#issuecomment-808736474), point 3.)",
          "createdAt": "2021-03-27T22:49:47Z",
          "updatedAt": "2021-03-27T22:49:47Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Putting this here b/c I'm not sure where else to put it.\n\nA [StackOverflow](https://stackoverflow.com/questions/66851403/quicksight-parsejson-with-dots-in-key) question regarding support for dotted paths inside brackets.\n\nThe main point of confusion here is the idea that a dotted path could legitimately represent a key.  \n\nConsider the following JSON:\n\n```json\n{\"foo.bar\": 0, \"foo\": {\"bar\": 1}}\n```\n\nWhat would the path `$['foo.bar']` return?  My implementations would return the `0`, but not the `1`.  I'm not necessarily pushing for this behavior, though.\n\nThe same argument applies whether a path starts with a `@` or not.\n\nI think this is something that we need to cover in the spec, even if we decide not to support it.\n\n(This would be one of the options for a _key_ or _index_ or whatever we end up calling a thing inside the brackets.)",
          "createdAt": "2021-03-29T11:06:06Z",
          "updatedAt": "2021-03-29T11:06:06Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Starting to interpret indexing strings as if they were JSONPath syntax leads to a slippery slope.  Strong opinion against that.\r\n",
          "createdAt": "2021-03-29T11:12:03Z",
          "updatedAt": "2021-03-29T11:12:03Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Following @gregsdennis' hint I raised a new issue `bracket notation` #92 , consensus in which will directly influence this issue and hopefully leads to closing both.\r\n\r\nPS: Excuse me for introducing `'|'` as a shortcut for `'or'` (one character saved ... minimization principle :-) and the confusion followed. It was never meant to propose a new syntax here ala XPath.\r\n\r\nPPS: [in](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88#issuecomment-808738198) slightly provocative   \r\n\"... if we agreed, that would break existing implementations ... !?\"    \r\nshould have been written as    \r\n\"... if we agreed, that would break user expected behavior of existing implementations ... !?\"",
          "createdAt": "2021-03-29T11:56:24Z",
          "updatedAt": "2021-03-29T11:56:24Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy to close this issue.",
          "createdAt": "2021-03-29T15:01:04Z",
          "updatedAt": "2021-03-29T15:01:04Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWU4NDMyOTYxMTk=",
      "title": "bracket notation",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/92",
      "state": "OPEN",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also addressing Glyn's point \r\n\r\n> 3. \"script\" expressions (`()`) - I'd hope we could offer minimal support for these without too much contention.\r\n\r\nfrom #78 here, obviously common agreement exists about the \"bracket child operator\", selecting a child value\r\n* either from a JSON object by `\"name\"`\r\n* or from a JSON array by `index`.\r\n\r\nSo in `$..[<expr>]` the result of expression `<expr>` will be interpreted as a member name or element index depending on the parent value type. While accepting this important statement, let's have a look at @danielaparker's JSON example in [#88](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/88#issuecomment-808522662): \r\n\r\n```\r\n{\r\n  \"firstName\": \"John\",\r\n  \"address\"  : {\r\n    \"city\" : \"Nara\",\r\n  }\r\n}\r\n```\r\nApplying following queries gives us\r\n\r\n| expression | result |\r\n|:--:|:--:|\r\n|`$.firstName`| `[\"John\"]` |\r\n|`$['firstName']`| `[\"John\"]` |\r\n|`$[@.firstName] === $['John']`| `[]` |\r\n|`$.address.city`| `[\"Nara\"]` |\r\n|`$['address']['city']`| `[\"Nara\"]` |\r\n|`$['address.city']`| `[]` |\r\n|`$[@.address.city] === $['Nara']`| `[]` |\r\n\r\naccording to the *member name* or *element index* interpretation principle.\r\n\r\nIn general any query expression ala `$.x[@.a.b.c]` means:\r\n\r\n\"Find *member name* or *element index* of JSON value named `\"x\"` as the value of its descendant node location `'@.a.b.c'`\". \r\n\r\nFrom my point of view it is of very low practical use to bury *member name* or *element index* of any JSON value deep down in its subtree.\r\n\r\nMy `[@.length-1]` index arithmetic is also generally commented of being of low practical use. \r\n\r\nUsing root value symbol `$` in `$.x[$.id]` meaning *member name* or *element index* referencing might be of some practical use, but potentially leads to security issues.\r\n\r\nAs a consequence of this I propose to completely dispense use of `$` and `@` in other expressions than filter expressions.\r\n",
      "createdAt": "2021-03-29T11:55:05Z",
      "updatedAt": "2021-04-09T09:23:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... leaving out the parenthesis in `[()]` above, was intended here for better readability only ...",
          "createdAt": "2021-03-29T12:18:09Z",
          "updatedAt": "2021-03-29T12:18:09Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> As a consequence of this I propose to completely dispense use of `$` and `@` in other expressions than filter expressions.\r\n\r\n+1",
          "createdAt": "2021-03-29T14:59:11Z",
          "updatedAt": "2021-03-29T14:59:11Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A few things.  First,\r\n\r\n> ... leaving out the parenthesis in [()] above, was intended here for better readability only ...\r\n\r\nI don't think we should shortcut notation in our discussions.  Doing so will end up with shortcutted notation becoming actual notation.  Please use the full notation intended.\r\n\r\nSecond, I think there are multiple syntaxes being discussed;\r\n\r\n- Numeric index: `$[0]`\r\n- Named index: `$['foo']`\r\n- Path-as-index: `$[@.address.city]` or `$['@.address.city']` or `$['address.city']`\r\n- Index-selection query: `[(@.length-1)]` or `$.x[($.id)]`\r\n\r\nThese should each have their own issues.  Since the first two are pretty basic and agreed upon, let's focus on the last two.  We can keep this one for the path-as-index (we should edit the title).  I'll create a new issue for the latter.",
          "createdAt": "2021-03-29T18:14:38Z",
          "updatedAt": "2021-03-29T18:15:03Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "You are right with demanding always complete syntax.\r\n\r\nMy points were:\r\n* No discussion about `$[0]`, `$['foo']`, `$['address.city']`\r\n* Disallow use of `$` and `@`: `$[(@.address.city)]`, `[(@.length-1)]`, `$.x[($.id)]`\r\n\r\nI don't think, we need another issue for bracket notation ...",
          "createdAt": "2021-03-29T19:50:38Z",
          "updatedAt": "2021-03-29T19:50:38Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> No discussion about $[0], $['foo'], $['address.city'] - @goessner \n\nWhat does `$['address.city']` return for these Arguments?\n\n```json\n{ \"address\": { \"city\": \"Dallas\" } }\n\n{ \"address.city\": \"Austin\" }\n\n{\n  \"address\": { \"city\": \"Dallas\" },\n  \"address.city\": \"Austin\"\n}\n```\n\nMy point is to say that the dot syntax as an index bears discussion.  We don't have agreement on it.\n\nThe ~door~ dotted syntax itself, as a string, is a valid key, so it creates ambiguity that shouldn't be left to implementations to resolve.\n\nI think a way around this would to use a `@`-path without quotes (also note the lack of `()`):  `$[@.address.city]`.  This indicates that the index is a path that needs to be evaluated to obtain the correct value.",
          "createdAt": "2021-03-30T03:41:38Z",
          "updatedAt": "2021-03-30T07:31:48Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> What does `$['address.city']` return for these Arguments?\r\n> \r\n> ```json\r\n> { \"address\": { \"city\": \"Dallas\" } }\r\n> \r\n> { \"address.city\": \"Austin\" }\r\n> \r\n> {\r\n>   \"address\": { \"city\": \"Dallas\" },\r\n>   \"address.city\": \"Austin\"\r\n> }\r\n> ```\r\n> \r\n\r\nEmpty nodelist, \"Austin\", \"Austin\".\r\n\r\n> My point is to say that the dot syntax as an index bears discussion. We don't have agreement on it.\r\n\r\nSo far the agreement appears to be that there is no such special syntax.",
          "createdAt": "2021-03-30T04:13:39Z",
          "updatedAt": "2021-03-30T04:13:39Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "@gregsdennis:\r\n> What does `$['address.city']` return for these Arguments?   \r\n> ...   \r\n> My point is to say that the dot syntax as an index bears discussion. We don't have agreement on it.\r\n\r\nBut  `['address.city']` is merely a string. Even `['..']` is valid and no \"dot syntax\". I think everyone agrees here.\r\n\r\n> The door syntax itself, as a string, is a valid key, ...\r\n\r\nWhat is a \"door syntax\" ?\r\n\r\n> I think a way around this would to use a `@`-path without quotes (also note the lack of `()`): `$[@.address.city]`. This indicates that the index is a path that needs to be evaluated to obtain the correct value.\r\n\r\nLetting the lack of `()` aside, this is exactly the point I want to focus the usefulness aspect at. Take \r\n```\r\n{ \r\n  \"key\": \"secret\",\r\n  \"proxy\": \"key\",\r\n  \"sub\": { \"hidden\":\"key\" }\r\n}\r\n```\r\nResult of both `$[(@.proxy)]` and `$[(@.sub.hidden)]` will be `\"secret\"`. But why would anyone cumbersome reference a value in the same parent on the same level or below. Everybody would simply write `$['key']`. A little more use value might exist with `$.obj[($.proxy)]` and\r\n```\r\n{  \"proxy\": \"key\",\r\n   \"obj\":  { \r\n     \"key\": \"secret\",\r\n   }\r\n}\r\n```\r\nBut then come with `$[($..key[($..key[($..key[])])])]` security concerns, which outweighs the little use by far.\r\n\r\nExcept that referencing trick I see no other use case of `[($.<path>)]` let alone `[(@.<path>)]`.\r\n\r\nEven index arithmetic ala `[(@.length-5)]` is of little use. \r\n\r\n@danielaparker writes in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/57#issuecomment-792043346\r\n> The only example of a `\"[()]\"` expression that I've ever seen is the one in the original JSONPath article, \r\n> ```\r\n> $.store.book[(@.length-1)].title\r\n> ```\r\n> and I believe it was Glyn that noted it can be rewritten without using expressions. My sense is that this construct wouldn't be missed.\r\n\r\nSo I pragmatically propose to disallow the use of `$` and `@` with bracket notation with `[()]` or without `[]` parenthesis, as long as no striking use case unexpectedly comes up. This applies to unions also.\r\n\r\nTo be clear:  filter expressions are a completely other beast and need to be discussed in the following.\r\n",
          "createdAt": "2021-03-30T07:28:30Z",
          "updatedAt": "2021-03-30T07:28:30Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> But `['address.city']` is merely a string. Even `['..']` is valid and no \"dot syntax\". I think everyone agrees here.\n\n@danielaparker & @bettio haven't commented here.  Of those who have been involved, I'd expect one of them to disagree.\n\n> What is a \"door syntax\" ?\n\nSorry. Autocorrect.  Dotted syntax. I've fixed it.\n\n> Result of both $[(@.proxy)] and $[(@.sub.hidden)] will be \"secret\". But why would anyone cumbersome reference a value in the same parent on the same level or below.\n\nSee #93 where I explain the usefulness of this syntax.  I also suggest we take conversation of this syntax to that issue and focus on `['address.city']` here.\n",
          "createdAt": "2021-03-30T07:39:16Z",
          "updatedAt": "2021-03-30T07:39:16Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Letting the lack of () aside... - @goessner \n\nOmitting the `()` was done on purpose to differentiate from the `[()]` syntax (again, see #93 for that).\n\nYou never address the syntax `$[@.address.city]` that I mentioned.  You instead went on to address `$[(@.address.city)]` which is _not_ under discussion here (see #93).\n\nThis syntax would be equivalent to just having `$.address.city`, so it's true that there's no immediate benefit.  The power comes when you combine it with unions.\n\nGiven the data\n\n```json\n{\n  \"name\": \"Greg\",\n  \"address\": {\n    \"city\": \"Auckland\"\n  }\n}\n```\n\nThe union path `$['name',@.address.city] would yield `[\"Greg\", \"Auckland\"]`.  There's not another way to do this.",
          "createdAt": "2021-03-30T08:21:12Z",
          "updatedAt": "2021-03-30T08:21:43Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Ahh ... I see ... this would be different indeed, a complete other thing.\r\n\r\nSo this must be allowed also for single bracket expressions\r\n```\r\n$[@.address.city] === $.address.city\r\n```\r\nwhen accepting the singularization principle. Consequently we would have to allow then constructs like `$[@.address[(@.proxyCity)]]`, thus introducing a new level of complexity.\r\n\r\nI think I made my point sufficiently precise. Others should decide regarding use of `$` and `@` inside of bracket expressions.\r\n",
          "createdAt": "2021-03-30T08:51:16Z",
          "updatedAt": "2021-03-30T08:51:16Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Consequently we would have to allow then constructs like `$[@.address[(@.proxyCity)]]`, thus introducing a new level of complexity.\n\nI think we've already discussed allowing this level of complexity elsewhere for `[?()]`.  How is this different?",
          "createdAt": "2021-03-30T09:12:46Z",
          "updatedAt": "2021-03-30T09:12:46Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... but now we have three different syntaxes ...\r\n* `[@.<path>]` or  `[$.<path>]`\r\n* `[(expr($,@))]`\r\n* `[?(expr($,@))]`\r\n\r\nwhich can be combined arbitrarily, where `@` has different meaning each. And yes, `[?()]` is still to be defined.\r\n\r\nOf course we can add that to the spec. I simply would like to discuss effort to benefit ratio before.",
          "createdAt": "2021-03-30T10:29:51Z",
          "updatedAt": "2021-03-30T10:29:51Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I simply would like to discuss effort to benefit ratio before.\r\n\r\nAgreed. And I'm concerned about the end user complexity/benefit ratio too as I've mentioned elsewhere. My personal preference is to focus on the core/common features or at least to get them nailed down first.",
          "createdAt": "2021-03-31T09:55:23Z",
          "updatedAt": "2021-03-31T09:55:23Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Worth mentioning: a [StackOverflow question](https://stackoverflow.com/q/67017189/878701) just came in regarding nested query expressions.",
          "createdAt": "2021-04-09T09:23:46Z",
          "updatedAt": "2021-04-09T09:23:54Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU4NDM3MTc2ODQ=",
      "title": "\"Index-selection query\" in bracket notation",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/93",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This discussion branches off of #88 primarily but the idea has also been discussed elsewhere (#17 & #57).\n\nThis issue covers the parenthetical bracket notation without the `?`, e.g. `$[(<expr>)]`.  Specifically, what is `<expr>` and what does this syntax do?\n\nThere have been many references to confusion and questions of usefulness regarding this syntax.  But I think this is a syntax that is underutilized due to lack of understanding.\n\n## Explanation by way of JSON Schema\n\nIn JSON Schema, there have been many discussions around the idea of comparing instance data against other instance data.  You can perform a search for \"$data\" on the schema spec site to read up on this, but I'll summarize.\n\nSuppose we have these instances:\n\n```json\n// valid\n{ \"value\": 5, \"lower-bound\": 3 }\n\n// invalid\n{ \"value\": 5, \"lower-bound\": 10 }\n```\n\nWith Schema in its current state, we can't validate these.  That's what the proposed `$data` keyword was supposed to solve.  It would provide a mechanism to reference other data for use in other keywords.  In this example, it could use the value in `lower-bound` for the `minimum` keyword.\n\nIt was never adopted, however, because no one could figure out how to make it work within the existing mechanisms of JSON Schema. (Beside the point.)\n\n(It's also similar to how `discriminator` works in the OpenAPI 3.1 specification.)\n\n## Back to JSON Path\n\nI think this operation is quite useful in that it allows the path author to use data within the Argument.\n\nLet's look at an example path: `$.x[($.id)]`.\n\nThis, to me, says select the value at `$.id`.  So long as this value contains a valid index, this should evaluate.  We have different cases.\n\n(Sorry, I can't make a pretty table as I'm on mobile.)\n\n- `{ \"id\": 2, \"x\": [ 5, 10, 15 ] }` -> `[15]`\n- `{ \u201did\": \"foo\", \"x\": { \"foo\": 10, \"bar\": 15 } }` -> `[10]`\n\nMaybe even this could be supported, though we run into \"interpretation\" issues of converting a string into something more meaningful to us.\n\n- `{ \"id\": \"0:1\", \"x\": [ 5, 10, 15 ] }` -> `[5, 10]`\n\nI don't think that it make sense for `$.id` to contain a union, only a single index.\n\nI think that if people understood this functionality better, it might get more usage.  Path authors could devise some fairly complex queries that couldn't otherwise be built.  I think this syntax _with this function_ is worth including.\n\nNote that I'm also setting aside the more common `$[(@.length-1)]` because we don't have a clear direction on \"inherent\" properties or functions.  As I've defined it here, this expression would look for a `length` key and expect a number as its value then subtract one from that to get the index to select.\n\n---\n\nYou may have noticed that I didn't put a `@` in that path above. This is because it results in a narrower set of cases.  I'd like to explore that now to prove my point.\n\n`$.x[@.id]` would look for an `id` key in the value at `$.x`, which means that it would expect `$.x` to be an object.  It doesn't make sense for the value at `$.x.id` to be a number because objects can't index this way.\n\nHowever if `$.x.id` is a string, then we could select the value of that key under `$.x` without any problem.",
      "createdAt": "2021-03-29T19:21:55Z",
      "updatedAt": "2021-03-31T19:16:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/92#issuecomment-809983852 is meant to be an answer here also ...",
          "createdAt": "2021-03-30T07:36:36Z",
          "updatedAt": "2021-03-30T07:36:36Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> `$[($..key[($..key[($..key[])])])]` - @goessner #92\r\n\r\nI'm not sure that this really is a concern for the spec. We are deciding function, and this syntax adds functionality that can't otherwise be achieved.\r\n\r\nAs noted in #25, I think some concerns are worth mentioning, but ultimately it's up to the implementation to decide what's best for the environment in which it runs.",
          "createdAt": "2021-03-30T07:40:13Z",
          "updatedAt": "2021-03-30T21:59:20Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/92#issuecomment-809983852 is meant to be an answer here also ...\n\nYour answer doesn't address the functionality I laid out in the opening comment.",
          "createdAt": "2021-03-30T08:07:15Z",
          "updatedAt": "2021-03-30T08:07:15Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "@gregsdennis : After reading your comment above again, I cannot see another striking use case beside \"internal referencing\", I commented also in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/92#issuecomment-809983852.\r\n\r\nRegarding ...\r\n```\r\n// invalid\r\n{ \"value\": 5, \"lower-bound\": 10 }\r\n```\r\n... JSONPath is meant for selection, not for validation and plausibility checks.\r\n\r\nIf we once allow the use of `$` and `@` with `[()]` we will have everything, which will be allowed in filters then ...\r\n\r\n* Arithmetic operators\r\n* Logical operators\r\n* Nesting\r\n* Possibly functions\r\n\r\n... but ...\r\n\r\n* only number or string indices must result in order to make sense.\r\n* `@` will have another meaning compared to filters. This will confuse users.\r\n\r\nand from my point of view for the single use case of  \"internal referencing\". Long time JSONPath users should decide now about significance of this or possibly other use cases.\r\n",
          "createdAt": "2021-03-30T08:34:46Z",
          "updatedAt": "2021-03-30T08:34:46Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> JSONPath is meant for selection, not for validation and plausibility checks.\n\nI wasn't saying that Path _is_ for validation. I'm using an example from the JSON Schema spec work (where I've been very active for the past seven years) to illustrate the usefulness of a similar feature here, where we _select_ data.  I'm fully aware of what JSON Path does.\n\n> only number or string indices must result in order to make sense.\n\nYes.  That's okay.  If the value isn't a number or a string, then the result is an empty nodelist.  Authors will understand the limitations here.\n\n> `@` will have another meaning compared to filters. This will confuse users.\n\nNo, it won't confuse users.\n\nThis is okay, too, since it has a different _context_.  The meaning is similar enough between the two contexts that it makes sense to reuse the operator.\n\nIn the context of `[?()]`, which iterates over the children of the current node, the `@` represents each child.\n\nIn the context of `[()]`, _there is no iteration of the current node_, so the `@` can only mean the current node itself.\n\n> I cannot see another striking use case beside \"internal referencing\"\n\nThat's it. The entire feature.  There's nothing more to it.  But it opens up selection mechanisms that can't otherwise be achieved.\n\n> If we once allow the use of $ and @ with [()] we will have everything\n\nYes. And we want everything.  I want an author to be able to say \"select the node before the index indicated by the value in `$.foo`.\"  That would be `$[($.foo-1)]`.  If `$.foo` doesn't contain a number, then the expression doesn't make sense and no nodes are returned.\n\n---\n\nWe agree that `$[(@.length-1)]` is useless and redundant.\n\nThis proposal redefines and expands the `[()]` syntax.\n\nIf it makes you feel better, we can have some other symbol to signify this, like `#`, e.g. `$[#()]`.  But I think this is an important capability that authors would love to have.",
          "createdAt": "2021-03-30T09:09:03Z",
          "updatedAt": "2021-03-30T09:09:03Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think that it make sense for `$.id` to contain a union, only a single index.\r\n\r\nWhy not? I agree it might not be very useful, but to disallow it seems a bit arbitrary.",
          "createdAt": "2021-03-30T10:28:07Z",
          "updatedAt": "2021-03-30T10:28:07Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> We agree that `$[(@.length-1)]` is useless and redundant.\r\n\r\nPossibly it isn't. Users may request to get the array index in the middle, say by ...\r\n```\r\narr[(floor(length(@)/2))]\r\n```\r\n Index arithmetic can get quite complex rapidly and may include string concatenation for dynamically define object member names.\r\n\r\nWhy not start simple (from users point of view) and add these complex stuff later to JSONPath 2.0, when such use cases come up? \r\n",
          "createdAt": "2021-03-30T10:52:02Z",
          "updatedAt": "2021-03-30T10:52:02Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I don't think that it make sense for `$.id` to contain a union, only a single index.\r\n> \r\n> Why not? I agree it might not be very useful, but to disallow it seems a bit arbitrary.\r\n\r\nThe idea is to allow this format as an index which can be further combined with other indices in a union, e.g. `$[(@.id),'foo']`.\r\n\r\nIt doesn't make sense to me to have an index be part of a union when that index can itself be a union.",
          "createdAt": "2021-03-30T11:26:30Z",
          "updatedAt": "2021-03-30T20:49:34Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "As a summery following can go into a bracket selector\r\n\r\n* `[<number literal>]` &ndash; array element access\r\n* `[<string literal>]` &ndash; object member access\r\n* `[*]` &ndash; wildcard \r\n* `[<start>:<end>:<step>]` &ndash; array slice access \r\n* `[@.<subpath>]` &ndash; same as `$.<path>.<subpath>`. Path continuing. Useful with unions.\r\n* `[(expr($,@))]` &ndash; Expression syntax equivalent to filter expression syntax.\r\n\r\nNote, that `@` with bracket selector always addresses the current JSON value.\r\n\r\nIt is still to be defined, what type of bracket selector expression results `(expr($,@))` are acceptable. Possible types are\r\n\r\n* number\r\n* string\r\n* array slice expression\r\n* array to be interpeted as union\r\n\r\nAll valid bracket selectors can be used in unions. ",
          "createdAt": "2021-03-31T08:41:12Z",
          "updatedAt": "2021-03-31T08:41:12Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > I don't think that it make sense for `$.id` to contain a union, only a single index.\r\n> > \r\n> > \r\n> > Why not? I agree it might not be very useful, but to disallow it seems a bit arbitrary.\r\n> \r\n> The idea is to allow this format as an index which can be further combined with other indices in a union, e.g. `$[(@.id),'foo']`.\r\n> \r\n> It doesn't make sense to me to have an index be part of a union when that index can itself be a union.\r\n\r\nIf we replaced the index expression with its value, then unions could sensibly be part of another union. E.g. in `$[(@.id),'foo']`, if `(@.id)` was the union `'bar','baz'`, then the larger union would be `$['bar','baz','foo']`.",
          "createdAt": "2021-03-31T09:49:53Z",
          "updatedAt": "2021-03-31T09:49:53Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> As a summery following can go into a bracket selector\r\n\r\nWhat about filters?",
          "createdAt": "2021-03-31T09:50:29Z",
          "updatedAt": "2021-03-31T09:50:29Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Filters are special &ndash; more iterators than accessors / selectors.\r\n\r\nSomewhere I read a proposal to possibly use other delimiters to make that visually clearer. I would like to discuss filters in a separate issue.",
          "createdAt": "2021-03-31T10:15:55Z",
          "updatedAt": "2021-03-31T10:15:55Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just listing this here as yet another example of a JSON technology using external data within its format.  This bolsters the argument for us to have similar functionality, which I'm proposing for `[()]`.\n\n[JSON Logic](https://gregsdennis.github.io/json-everything/usage/json-logic.html#the-syntax) supports a `var` operator that can pull values from the input data.",
          "createdAt": "2021-03-31T19:16:37Z",
          "updatedAt": "2021-03-31T19:16:37Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU4ODg3MTAxMjc=",
      "title": "ER - Provide syntax for returning a specific number of filtered elements",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/95",
      "state": "OPEN",
      "author": "mkredpoint",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "A gentleman by the username of gregsdennis on Stack Overflow suggested I raise this issue here for consideration into the specification:\r\n\r\nhttps://stackoverflow.com/questions/67477431/json-path-is-there-a-way-to-only-return-a-specific-number-of-filtered-elements/67477600\r\n\r\nGiven an object like this:\r\n\r\n`    { \"store\": {\r\n    \"book\": [ \r\n      { \"category\": \"reference\",\r\n        \"author\": \"Nigel Rees\",\r\n        \"title\": \"Sayings of the Century\",\r\n        \"price\": 8.95\r\n      },\r\n      { \"category\": \"fiction\",\r\n        \"author\": \"Evelyn Waugh\",\r\n        \"title\": \"Sword of Honour\",\r\n        \"price\": 12.99\r\n      },\r\n      { \"category\": \"fiction\",\r\n        \"author\": \"Herman Melville\",\r\n        \"title\": \"Moby Dick\",\r\n        \"isbn\": \"0-553-21311-3\",\r\n        \"price\": 8.99\r\n      },\r\n      { \"category\": \"fiction\",\r\n        \"author\": \"J. R. R. Tolkien\",\r\n        \"title\": \"The Lord of the Rings\",\r\n        \"isbn\": \"0-395-19395-8\",\r\n        \"price\": 22.99\r\n      }\r\n    ],\r\n    \"bicycle\": {\r\n      \"color\": \"red\",\r\n      \"price\": 19.95\r\n    }\r\n  }\r\n}`\r\n\r\nand running a JSON path expression like so:\r\n\r\n`$..book[?(@.price<10)]`\r\n\r\nWill return 2 objects:\r\n\r\n`[\r\n   {\r\n      \"category\" : \"reference\",\r\n      \"author\" : \"Nigel Rees\",\r\n      \"title\" : \"Sayings of the Century\",\r\n      \"price\" : 8.95\r\n   },\r\n   {\r\n      \"category\" : \"fiction\",\r\n      \"author\" : \"Herman Melville\",\r\n      \"title\" : \"Moby Dick\",\r\n      \"isbn\" : \"0-553-21311-3\",\r\n      \"price\" : 8.99\r\n   }\r\n]`\r\n\r\nit would be great if JSON Path also provide syntax for returning the first or last 'n' items of the filtered array\r\n\r\ne.g. if I only wanted maximum 1 item from the result of the filtering operation:\r\n\r\n`$..book[?(@.price<10)]{1}`\r\n\r\n",
      "createdAt": "2021-05-11T21:23:25Z",
      "updatedAt": "2021-11-11T05:00:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "This could also be used in a form of pagination (offset/length), but that could be a local API and not a feature of JSONPath.",
          "createdAt": "2021-11-09T20:54:26Z",
          "updatedAt": "2021-11-09T20:54:26Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think having a syntax for it is valuable.  Individual libraries implementing this independently doesn't serve uniformity.",
          "createdAt": "2021-11-10T03:09:09Z",
          "updatedAt": "2021-11-10T03:09:09Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree such a feature has _some_ value, but I'm not convinced it has _enough_ value to warrant adding complexity to the spec.",
          "createdAt": "2021-11-10T03:19:03Z",
          "updatedAt": "2021-11-10T03:19:03Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough.  I think this should remain open and perhaps labeled as a `v2`/`future` feature.",
          "createdAt": "2021-11-11T05:00:28Z",
          "updatedAt": "2021-11-11T05:00:28Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU4ODk4NDE0NTM=",
      "title": "XPath references and comparisons",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/96",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "How much do we want to reference XPath within the spec?  I understand that XPath is the inspiration (and in the tagline that @goessner used in his blog post: \"XPath for JSON\"), but I wonder if much of this can be left out of the spec.\r\n\r\nThe argument for this is that we're defining JSONPath.  It shouldn't assume any understanding of XPath or any other technology.  It's not the job of the specification to convince readers to use it.  It's the job of the specification to _define_ the technology.\r\n\r\nI'm perfectly happy moving this into an external \"Understanding JSONPath\" website at some point.",
      "createdAt": "2021-05-12T08:53:07Z",
      "updatedAt": "2021-11-11T05:01:43Z",
      "closedAt": "2021-11-10T05:15:47Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I seem to remember that last time we discussed this we agreed to move the introductory comparison with XPath to an appendix, with the possible exception of the overview table (but that could be duplicated).",
          "createdAt": "2021-05-12T08:55:03Z",
          "updatedAt": "2021-05-12T08:55:03Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed by #131, #132",
          "createdAt": "2021-11-10T05:15:47Z",
          "updatedAt": "2021-11-10T05:15:47Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "The XPath inclusion was moved into an appendix.",
          "createdAt": "2021-11-11T05:01:43Z",
          "updatedAt": "2021-11-11T05:01:43Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU5MjE1MDYyMTE=",
      "title": "Partial determinism of the descendant selector (..)",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/103",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [
        "has PR"
      ],
      "body": "At today's meeting, I agreed to submit a PR to float the idea of partial determinism for the descendants operator, even though the consensus seems to be against any determinism for that operator. Given the descendants operator PR https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/102 isn't yet merged, I'll start with an issue to capture discussion and avoid rebasing effort.\r\n\r\nWe probably don't want to _force_ any determinism on implementations, so the idea is to provide a recommendation for implementations which want to provide partial determinism and use \"SHOULD\" language so the recommendation is optional. Then implementations which opt in will agree on the ordering recommentations.\r\n\r\nThe benefits of partial determinism are:\r\n* improved predictability and interoperation\r\n* relative ease for JSONPath users writing tests, as there are fewer possible outputs.\r\n\r\nIn PR https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/102 there are no constraints on the non-determinism of the descendants operator:\r\n> The `descendant-selector` is inspired by ECMAScript for XML (E4X). It selects the node and all its descendants.\r\n\r\nWe agreed in issue https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/60 to allow non-determinism in the order in which objects are iterated and the same should be true when the descendants operator encounters an object. But there are other details of the ordering which could be tied down:\r\n* arrays SHOULD be visited in array order\r\n* nodes SHOULD be visited strictly before their descendants (so-called _pre-order_ traversal).\r\n\r\n(_Post-order_ traversal, in which nodes are visited strictly after their descendants, would be an equally valid alternative.)\r\n\r\nOne of the reasons given at today's meeting for allowing full non-determinism was for parallel processing, so it would be interesting to discuss what constraints the above rules produce on parallel processing. The order of collection of the results seems to be more significant than whether or not parallel processing is used.",
      "createdAt": "2021-06-15T15:13:00Z",
      "updatedAt": "2021-11-11T08:35:17Z",
      "closedAt": "2021-11-10T10:45:13Z",
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "My preference is _pre-order_ traversal (node then descendants).",
          "createdAt": "2021-06-22T11:22:12Z",
          "updatedAt": "2021-06-27T06:04:14Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Except that I don't know what's \"SHOULD\" about that, I agree with these partial ordering guidelines.\r\n\r\nIf we want to introduce different compliance levels, that is fine, but it SHOULD :-) not be coupled to using the term SHOULD vs. MUST.\r\n\"Full compliance requires...\"\r\nvs. \"For conditional compliance, at least...\"",
          "createdAt": "2021-07-23T14:40:17Z",
          "updatedAt": "2021-07-23T14:40:17Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I probably misunderstood [RFC 2119](https://datatracker.ietf.org/doc/html/rfc2119), or applied it atypically. I am comfortable with using @cabo's compliance level language instead.",
          "createdAt": "2021-07-23T15:22:56Z",
          "updatedAt": "2021-07-23T15:22:56Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "We need to be careful here that we don't optimize for tests.  It seems to be a focus of this discussion that we want to make verification of output in the test suite easier.\n\nRather, we need to focus on supportability and interoperability.  If that aligns with running the test, that's good.  But don't let making running the tests easier at the cost of making things significantly more difficult for implementors.\n\nIt's non-trivial, but also not very complex, to verify unordered sets of nodes in output.",
          "createdAt": "2021-07-23T21:58:26Z",
          "updatedAt": "2021-07-23T21:58:26Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "More significant than complications for the JSONPath test suite is the\namount of non-determinism that tests of code which uses JSONPath will have\nto accommodate.\n\nOn Fri, 23 Jul 2021 at 22:58, Greg Dennis ***@***.***> wrote:\n\n> We need to be careful here that we don't optimize for tests. It seems to\n> be a focus of this discussion that we want to make verification of output\n> in the test suite easier.\n>\n> Rather, we need to focus on supportability and interoperability. If that\n> aligns with running the test, that's good. But don't let making running the\n> tests easier at the cost of making things significantly more difficult for\n> implementors.\n>\n> It's non-trivial, but also not very complex, to verify unordered sets of\n> nodes in output.\n>\n> \u2014\n> You are receiving this because you were assigned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/103#issuecomment-885934149>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2NMGQ3XYRKQODEWNGDTZHQY3ANCNFSM46XPPL6Q>\n> .\n>\n",
          "createdAt": "2021-07-24T05:52:10Z",
          "updatedAt": "2021-07-24T05:52:10Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I recommend checking out the language around interoperability in 8259. Something like that might work here.",
          "createdAt": "2021-07-26T18:51:25Z",
          "updatedAt": "2021-07-26T18:51:25Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm having a hard time judging the consensus, or lack of it, here. Regardless of the detailed language, please could interested parties indicate which of these options they favour:\r\n\r\nA.  Don't tie down the non-determinism of `..` at all\r\nB. Require `..` to visit arrays in array order and visit nodes before their descendants\r\nC. Some other option involving B with the option of A or A with the option of B, using some kind of language TBD.\r\n\r\n/cc @goessner ",
          "createdAt": "2021-07-30T13:48:32Z",
          "updatedAt": "2021-07-30T13:48:32Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> I recommend checking out the language around interoperability in 8259. Something like that might work here.\n\nI\u2019m not sure you actually mean that, but for me that would be about the worst result we could arrive at.\n\n8259 was worked on in a politicized context, which simply didn\u2019t allow us to clean it up.  There barely was the courage to finally say that interchanging JSON implies UTF-8, which was at least some progress.\nBut there was no way to clarify the data model issues, and this is why JSON in practice essentially has been reduced to I-JSON, which is not bad at all, but really different from what JSON originally promised to be.\n\nI\u2019d prefer if we don\u2019t need an I-JSONPath document to clean up the interoperability issues left in JSONPath-base.\n\nGiven that we have JSON and I-JSON, it may be useful to acknowledge (or violently reject! \u2014 we get to choose) the emergence of multiple levels/classes of interoperability with JSONPath, too.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-07-30T15:55:23Z",
          "updatedAt": "2021-07-30T15:55:23Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> B. Require .. to visit arrays in array order and visit nodes before their descendants\r\n\r\nI would vote for this option, but in the same time we have slices with negative steps, which naturally do sort of \"backwards\" iteration in Python. [Here is an example](https://cburgmer.github.io/json-path-comparison/results/array_slice_with_negative_step.html) - while there's no clear consensus, we see that _all_ implementations with \"python-compatible\" slices return values in reverse order, no exceptions.\r\n\r\nIf we determine order of array items visiting (thus determining the order of selected nodes in output), shouldn't we also take into consideration the effect of selectors, and if yes - then should the order of union items affect the order of visit?\r\n\r\nWe can consider part of selectors as \"order neutral\" and others are \"order affecting\", with affecting selectors overriding natural order. At first glance I see slices and unions as order-affecting selectors.",
          "createdAt": "2021-09-09T10:48:47Z",
          "updatedAt": "2021-09-09T11:02:27Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@remorhaz I don't follow. The ordering of `..` is not affected by other selectors (e.g. involving negative array steps or unions).",
          "createdAt": "2021-09-09T11:03:35Z",
          "updatedAt": "2021-09-09T11:03:35Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The ordering of .. is not affected by other selectors (e.g. involving negative array steps or unions).\r\n\r\nThis is not absolutely clear for me. Let us have the following structure:\r\n```json\r\n[\r\n  [\r\n    [1, 2, 3, 4],\r\n    [5, 6, 7, 8]\r\n  ]\r\n]\r\n```\r\nAnd we apply `$..[::-1]` query. At first we apply `..` selector to the root node, and it returns following nodes:\r\n\r\n1. `$[0]`: `[[1, 2, 3, 4], [5, 6, 7, 8]]`\r\n2. `$[0][0]`: `[1, 2, 3, 4]`\r\n3. `$[0][0][0]`: `1`\r\n4. `$[0][0][1]`: `2`\r\n5. `$[0][0][2]`: `3`\r\n6. `$[0][0][3]`: `4`\r\n7.  `$[0][1]`: `[5, 6, 7, 8]`\r\n8. `$[0][1][0]`: `5`\r\n9. `$[0][1][1]`: `6`\r\n10. `$[0][1][2]`: `7`\r\n11. `$[0][1][3]`: `8`\r\n\r\nThen we apply `[::-1]` selector to each these nodes. Applying slice to number will return empty node list, so I consider only arrays below:\r\n\r\n`$[0]`: `[[1, 2, 3, 4], [5, 6, 7, 8]]`\r\n1. `$[0][1]`: `[5, 6, 7, 8]`\r\n2. `$[0][0]`: `[1, 2, 3, 4]`\r\n\r\n`$[0][0]`: `[1, 2, 3, 4]`\r\n1. `$[0][0][3]`: `4`\r\n2. `$[0][0][2]`: `3`\r\n3. `$[0][0][1]`: `2`\r\n4. `$[0][0][0]`: `1`\r\n\r\n`$[0][1]`: `[5, 6, 7, 8]`\r\n1. `$[0][1][3]`: `8`\r\n2. `$[0][1][2]`: `7`\r\n3. `$[0][1][1]`: `6`\r\n4. `$[0][1][0]`: `5`\r\n\r\nThe resulting node list is:\r\n1. `$[0][1]`: `[5, 6, 7, 8]`\r\n2. `$[0][0]`: `[1, 2, 3, 4]`\r\n3. `$[0][0][3]`: `4`\r\n4. `$[0][0][2]`: `3`\r\n5. `$[0][0][1]`: `2`\r\n6. `$[0][0][0]`: `1`\r\n7. `$[0][1][3]`: `8`\r\n8. `$[0][1][2]`: `7`\r\n9. `$[0][1][1]`: `6`\r\n10. `$[0][1][0]`: `5`\r\n\r\nI didn't notice any problems following both \"natural order\" while applying `..` and \"reversed order\" while applying `[::-1]`, because they never apply simultaneously. Please show me if I missed something in my reasoning.",
          "createdAt": "2021-09-09T11:55:02Z",
          "updatedAt": "2021-09-09T14:04:42Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The idea of determinism in arrays itself seems important to me. For example, let some service provides array of some data in some garanteed order that is important for end user, and and another service wants to use JSONPath to filter them on some fancy condition.\r\n\r\nIf JSONPath provides determined order of results, then it's at least possible to solve the problem with a single query. If no - we'll have no easy way to do it. We will need to extract from JSON original order somehow (with alternative tool or manual parsing), and then use it to rebuild original order of filtered items. It will be much more convenient to receive results in a determined order.",
          "createdAt": "2021-09-09T12:56:03Z",
          "updatedAt": "2021-09-09T12:56:03Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The main aspect of JSON that leads to non-determinism is the fact that no\nspecification makes any guarantee that the order of Members in an Object\ncarries any meaning. RFC8259, last para of Section 4\n<https://datatracker.ietf.org/doc/html/rfc8259#section-4>,  explicitly\ncautions against relying on this.\n\nOn the other hand, order in arrays is explicitly significant and I would be\nshocked if application of array-based selectors did not produce identical\nresults in all implementations.\n\nOr am I missing something obvious?\n\nOn Thu, Sep 9, 2021 at 5:56 AM Edward Surov ***@***.***>\nwrote:\n\n> The idea of determinism in arrays itself seems important to me. For\n> example, let some service provides array of some data in some garanteed\n> order that is important for end user, and and another service wants to use\n> JSONPath to filter them on some fancy condition.\n>\n> If JSONPath provides determined order of results, then it's at least\n> possible to solve the problem with a single query. If no - we'll have no\n> easy way to do it. We will need to extract from JSON original order somehow\n> (with alternative tool or manual parsing), and then use it to rebuild\n> original order of filtered items. It will be much more convenient to\n> receive results in a determined order.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/103#issuecomment-916066134>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJE4BWYATVFBIEWAYLWDUBCVG5ANCNFSM46XPPL6Q>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-09-09T18:40:03Z",
          "updatedAt": "2021-09-09T18:40:03Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I think we agree that array order should be preserved and that object order is not guaranteed, but I'd like this issue to focus specifically on the ordering of `..`.",
          "createdAt": "2021-09-09T18:44:10Z",
          "updatedAt": "2021-09-09T18:44:10Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Added text indicating node-first / children-second ordering.",
          "createdAt": "2021-11-11T05:03:22Z",
          "updatedAt": "2021-11-11T05:03:22Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "... and preserving array order.\n\nOn Thu, 11 Nov 2021, 05:03 Greg Dennis, ***@***.***> wrote:\n\n> Added text indicating node-first / children-second ordering.\n>\n> \u2014\n> You are receiving this because you modified the open/close state.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/103#issuecomment-965992017>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2K7BWKGFWQAZT3KVP3ULNFCLANCNFSM46XPPL6Q>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-11-11T07:44:31Z",
          "updatedAt": "2021-11-11T07:44:31Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure. That too.  But I don't think that was ever in question.",
          "createdAt": "2021-11-11T08:35:17Z",
          "updatedAt": "2021-11-11T08:35:17Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU5NDc0ODA1MjY=",
      "title": "filtering w/o child selection",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/109",
      "state": "OPEN",
      "author": "grzegorz-herman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "First of all, thanks for the standardization efforts!\r\n\r\nUnless I am missing something, the current draft (https://datatracker.ietf.org/doc/html/draft-ietf-jsonpath-base-01) allows filtering only in the context of child selection. I understand the semantics of `[?(<predicate>)]` as follows:\r\n\r\n* we have a current list of *items* (as produced by selectors earlier on the path),\r\n* for each of the items, we examine its *subitems* - elements if it is an array, values if it is an object, none otherwise,\r\n* we evaluate `<predicate>` on each subitem (with the special selector `@` denoting the subitem),\r\n* the resulting list consists of those *subitems* for which the predicate evaluates to (something) true.\r\n\r\nThe problem I see is that there seems absolutely no way to filter the current list of *items*. In some situations, one can work around it, but sometimes not. Assume I have a value\r\n```\r\n{\r\n  \"a\": { \"v\": true, \"w\": true },\r\n  \"b\": { \"v\": false, \"w\": true },\r\n  \"c\": { \"v\": true, \"w\": false },\r\n  \"d\": { \"v\": true, \"w\": true }\r\n}\r\n```\r\nand I would like to select those of subobjects with keys \"a\", \"b\" or \"c\" (but not \"d\") whose element \"v\" is true (i.e., the resulting list should contain `{ \"v\": true, \"w\": true }` and `{ \"v\": true, \"w\": false }`). I cannot apply the filtering at the top level, as it would include the key \"d\", I cannot apply it one level below as it would have to include \"w\", and there are no other levels.\r\n\r\nImagine that we had an independent filtering selector, say `{<predicate>}`, with the semantics of evaluating `<predicate>` on each current *item* (with `@` denoting the item) and leaving those which satisfy it (note: I am not proposing this exact syntax here, just the semantics). Then I could intuitively solve the example above with `$['a','b','c']{@.v}`.\r\n\r\n(as a side note, with the above the syntax `[?(<predicate>)]` would become equivalent to `[*]{<predicate>}`)\r\n\r\nSome implementations (jayway IIRC) actually \u201csolve\u201d the problem above by applying the filtering predicate in `[?(...)]` to *items or subitems*, apparently depending on whether the items are arrays or not. IMO following this path in the standard is a bad idea, as it can quickly become confusing (what if the list contains a mixture of arrays, objects, and primitives?).\r\n\r\nPlease, consider adding an independent filtering selector to the standard!\r\n\r\n(as another side note, binding the \u201ccurrent item\u201d `@` is currently also attached to filtering, do you think it could be worthwhile to make it independent as well?)",
      "createdAt": "2021-07-19T09:57:14Z",
      "updatedAt": "2021-09-09T21:32:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "You can already do this in the existing syntax:\n\n```\n$['a','b','c'][?(@.v)]\n```\n\nThis first selects the nodes under `a`, `b`, and `c`.  Then from that resulting set, all the values which have `v = true`. It produces the following nodes:\n\n- `$.a`\n- `$.c`\n\nThe one thing we _don't_ have a syntax for is negative selection, e.g. selecting everything _except_ `d`.  Interestingly [this SO question](https://stackoverflow.com/q/68436665/878701) recently popped up asking for something similar.",
          "createdAt": "2021-07-19T10:42:32Z",
          "updatedAt": "2021-07-19T10:55:28Z"
        },
        {
          "author": "grzegorz-herman",
          "authorAssociation": "NONE",
          "body": "@gregsdennis, IMO what you suggest might work only by accident (or deliberate extension of the semantics by some implementations), but according to the wording of the current draft it should not. Please correct my reasoning in the following:\r\n* \u201ca selector acts on each of the nodes in its input nodelist and concatenates the resultant nodelists to form the result nodelist of the selector\u201d (3.4, third paragraph) - we will thus be working with nodelists (not to be confused with arrays);\r\n* \u201cThe root selector \"$\" [...] produces as output a list consisting of one node: the argument itself.\u201d (3.4, first paragraph) - the first nodelist has one element, the node with the whole document;\r\n* \u201cA union [...] selects the concatenation of the lists (in the order of the selectors) of nodes selected by the union elements.\u201d (3.5.8.2). The nodelists for each of the indices \"a\", \"b\" and \"c\" each consist of a single entry (the appropriate subobject of the root), and thus the nodelist after this selector contains these three subobjects;\r\n* \u201cDuring iteration process each array element or object member is visited and its value -- accessible via symbol \"@\" -- [...] is tested against a boolean expression\u201d (3.5.9.1, second paragraph) - for each of the three nodes in the current nodelist (root subobjects keyed by \"a\", \"b\" and \"c\"), the items bound to `@` by the filter are the *values* in the node, which are all booleans; none of them contains a member named \"v\", and thus the resulting nodelist is empty.\r\n",
          "createdAt": "2021-07-19T11:05:29Z",
          "updatedAt": "2021-07-19T11:05:29Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think you're right. Mine would return nothing.\n\nWhat you're looking for is more along the lines of\n\n```\n$[?(@.v)]\n```\n\nexcept that it omits `$.d`.\n\nWe _have_ discussed allowing `@` to have access to the key value.  There's a proposal somewhere for a function like `key(@)` within an expression to capture a key when iterating over objects.  We didn't go into that deeply because we decided to postpone defining functions for now.\n\n_If_ such a thing were to be supported, you could do\n\n```\n$[?(key(@) != 'd' && @.v)]\n```",
          "createdAt": "2021-07-19T11:15:32Z",
          "updatedAt": "2021-07-19T19:59:42Z"
        },
        {
          "author": "grzegorz-herman",
          "authorAssociation": "NONE",
          "body": "Thanks for the answer. Yes, the examples in the draft (Table 6) have the function `index` which seems to be doing that. However, from the point of view of pure semantics, this solution feels more like a workaround: why should I use some special function to filter on the key, when there is a dedicated \u201ccore\u201d syntax for selecting subobjects by key.\r\n\r\nAnd then, even such key-accessing function would not allow to write a path with the desired semantics of \u201cselect the whole (root) object *if* it satisfies the given predicate\u201d, as there would be no place where the initial singleton nodelist could be made into an array to be filtered.\r\n\r\nPlease note, that I am not looking for a solution to any specific problem. My actual use case needs a special JSONPath implementation anyway, so I have simply extended what is currently in the draft by independent filtering (using the `{<predicate>}` syntax). I am just very much into programming languages, and I hope my somewhat \u201cpurist\u201d remarks might help to make the standard even better.\r\n\r\nBy the way, I would be interested to learn how much the standardization effort here is (only) aimed at codifying what the existing implementations are doing, or, in another terms, how strong the requirement of backwards compatibility with *status quo* is. I see some possibilities for streamlining the semantics, but things could potentially break here and there, so I am uncertain if it even makes sense to share those here.",
          "createdAt": "2021-07-19T20:35:50Z",
          "updatedAt": "2021-07-19T20:35:50Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "You'd probably be interested in reviewing our [charter](https://datatracker.ietf.org/wg/jsonpath/about/) and that there's an existing project to [compare various implementations' levels of support](https://cburgmer.github.io/json-path-comparison/).\r\n\r\nIn summary, we are interested in not breaking existing implementations as much as possible, but that's secondary to creating a query language that makes sense.  For example, @goessner's original blog post mentions that expressions are to support the syntax of the environment in which that they're run (e.g. Javascript, Python, etc.).  However we determined that this doesn't support interoperability well, so we have to define our own syntax for expressions.",
          "createdAt": "2021-07-20T00:31:44Z",
          "updatedAt": "2021-07-20T00:31:44Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "@grzegorz-herman :  You are correctly pointing to a certain insufficiency of JSONPath here.\r\n\r\nI would like to elaborate here a little more. Both arguments ...\r\n\r\n```json\r\n{\r\n    \"a\": 1,\r\n    \"b\": 2,\r\n    \"c\": 3\r\n}\r\n```\r\n```json\r\n[\r\n    1,\r\n    2,\r\n    3\r\n]\r\n```\r\nwill select against the query `$[?(@)]` the identical value list `[1,2,3]`, different node lists though.\r\nSo this conforms to the spec ...\r\n\r\n>  During iteration process **each** array element or object member is\r\n   visited and its **value** -- accessible via symbol \"@\" -- or one of its\r\n   descendants -- uniquely defined by a relative path -- is tested\r\n   against a boolean expression \"boolean-expr\".\r\n\r\nSo it is vitally important for `@` to give us each *value* in order to build a relative path as in `@.v` above.\r\n\r\nNote that this has nothing to do with the fact, that we are iterating over the root node. The enability to filter during iteration against the index is inherent.\r\n```json\r\n{\r\n    \"obj\": {\r\n        \"a\": 1,\r\n        \"b\": 2,\r\n        \"c\": 3\r\n    }\r\n}\r\n```\r\nalso won't work via `$.obj[?(@ != 'd')]` or `$[?(@[*] != 'd')]` (useless anyway).\r\n\r\nWe simply have no mechanism yet to get the node-index during iteration. \r\n\r\nImagine, we had the symbol `\u00a7` for giving us the node-index instead of the node value during iteration, we could write `$.obj[?(\u00a7 != 'd')]` but not `$[?(\u00a7[*] != 'd')]` even if `\u00a7` would be so smart to resolve correctly, if it occurs at the start of a relative path. Also we probably might need to have a complement function `value` then. So I see no use value in introducing a new syntax element here.\r\n\r\n@grzegorz-herman:  In this context I do not understand ...\r\n\r\n> ... why should I use some special function to filter on the key, when there is a dedicated \u201ccore\u201d syntax for selecting subobjects by key?\r\n\r\n... as `@` is unable to be resolved to its index (key).\r\n\r\nHaving functions like `index` in our expression language seems to get increased importance through discussions like this. `$.obj[?(index(@) != 'd')]` would obviously do what we want.\r\n\r\n... do I miss out here something ?\r\n\r\nThanks\r\n\r\n--  \r\nsg",
          "createdAt": "2021-07-26T13:47:00Z",
          "updatedAt": "2021-07-26T13:47:00Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> Assume I have a value\r\n> \r\n> ```\r\n> {\r\n>   \"a\": { \"v\": true, \"w\": true },\r\n>   \"b\": { \"v\": false, \"w\": true },\r\n>   \"c\": { \"v\": true, \"w\": false },\r\n>   \"d\": { \"v\": true, \"w\": true }\r\n> }\r\n> ```\r\n> \r\n> and I would like to select those of subobjects with keys \"a\", \"b\" or \"c\" (but not \"d\") whose element \"v\" is true (i.e., the resulting list should contain `{ \"v\": true, \"w\": true }` and `{ \"v\": true, \"w\": false }`). I cannot apply the filtering at the top level, as it would include the key \"d\", I cannot apply it one level below as it would have to include \"w\", and there are no other levels.\r\n> \r\nIt may be interesting to compare how this requirement would be met in [JSONiq](https://www.jsoniq.org/), an ISO/IEC approved, OASIS standard. In the JSONiq syntax, one way would be:\r\n```\r\nlet $data := {\r\n  \"a\": { \"v\": true, \"w\": true },\r\n  \"b\": { \"v\": false, \"w\": true },\r\n  \"c\": { \"v\": true, \"w\": false },\r\n  \"d\": { \"v\": true, \"w\": true }\r\n}\r\n\r\nfor $key in jn:keys($data),\r\n    $x in $data($key)\r\nwhere ($key eq \"a\" or $key eq \"b\" or $key eq \"c\") and $x.\"v\" eq true\r\nreturn $x\r\n```\r\nOutput:\r\n```\r\n{\r\n  \"v\": true,\r\n  \"w\": true\r\n}\r\n{\r\n  \"v\": true,\r\n  \"w\": false\r\n}\r\n```",
          "createdAt": "2021-09-06T03:40:42Z",
          "updatedAt": "2021-09-06T03:44:39Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... interesting ...\r\n\r\n`@key` would be another syntax approach equivalent to function `key(@)` then.",
          "createdAt": "2021-09-08T09:55:39Z",
          "updatedAt": "2021-09-08T09:55:39Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I prefer the function syntax. It opens the door for other functions.",
          "createdAt": "2021-09-08T10:14:11Z",
          "updatedAt": "2021-09-08T10:14:11Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> I think I prefer the function syntax. It opens the door for other functions.\r\n\r\n@gregsdennis , I don't think it does, open the door for other functions. This is based on prior experience with supporting functions in two JSONPath implementations (C++ and C#), one allowing for custom user defined functions, and also on prior experience with two JMESPath implementations (C++ and C#) with built in functions as per the [JMESPath Specification](https://jmespath.org/specification.html#built-in-functions).\r\n\r\nI had earlier suggested `key(@)` [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/57#issuecomment-792857872), without fully thinking it through, but I no longer think it's a good idea. The difficulty is what that requires for the arguments passed to functions. Support for `key(@)` as a general function would require arguments to come in pairs, either `path-value` pairs or minimally `key-value` pairs. And of course not all function arguments are associated with paths. That makes for a messy function interface, departing from prior experience, prior experience suggest that functions should operate on values only. \r\n\r\nOf course, an implementation could support `key(@)`, but I think it would be as a special case, using internal details unavailable to say, a user taking advantage of an extension function interface.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-08T11:48:20Z",
          "updatedAt": "2021-09-08T12:00:07Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think I prefer the function syntax. It opens the door for other functions.\r\n\r\nIntroducing functions also brings permanent temptation to add new functions to the list; it's not bad in itself, but it requires a good versioning strategy for JSONPath. And user-defined functions can cause interoperability problems. We should think twice before opening this door.\r\n\r\nOn the other hand, introducing \"current index\" symbol binds the operation to current context. With functions we can build queries like `$.a.b[?(key(@.c.d)==\"e\")]`, but such query can be easily replaced by `$.a.b[?(@.c[\"e\"].d)]` - so we probably don't need to detect index in arbitrary context.\r\n",
          "createdAt": "2021-09-08T16:41:09Z",
          "updatedAt": "2021-09-08T16:41:09Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And if we use, for example , `#` as current index symbol, we also can make it possible to access whole path. For example (given path `a->b->c->d`):\r\n\r\n- `#[1, 3]` selects `c` and `a`;\r\n- `#[0]` is equivalent of `#` and selects `d`\r\n- `#[0:2]` selects `d` and `c`, and so on.\r\n\r\nThat can be quite a powerful syntax.",
          "createdAt": "2021-09-08T16:49:43Z",
          "updatedAt": "2021-09-08T16:49:43Z"
        },
        {
          "author": "grzegorz-herman",
          "authorAssociation": "NONE",
          "body": "The discussion seems to focus more and more on accessing the current key/index. I just wanted to point out that, while such access would indeed solve the example problem, the real intent/question of this issue is different: should JSONPath have a filtering construct operating on the \u201ccurrent list of values\u201d, not tied to child selection. I hope this question does not get lost. Thanks!",
          "createdAt": "2021-09-08T18:36:39Z",
          "updatedAt": "2021-09-08T18:36:39Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> should JSONPath have a filtering construct operating on the \u201ccurrent list of values\u201d\r\n\r\nI've re-read your inital post:\r\n>  I would like to select those of subobjects with keys \"a\", \"b\" or \"c\" (but not \"d\") whose element \"v\" is true\r\n\r\nIn fact, we may be lacking an _intersection_ operation over unions. Some possible examples of this:\r\n\r\n1. `$['a', 'b', 'c']#[?(@.v == true)]` - operator applies over two (or more) separate unions;\r\n2. `$['a', 'b', 'c' # ?(@.v == true)]` - operator applies over two (or more) groups of selectors within a single union.\r\n\r\nIn both cases `#` (symbol is random) acts like an intersection operator over nodelists and result of its application is list of nodes that exists in all nodelists.\r\n\r\nI don't know if these examples look more \"intuitive\" than semantics of \"alternative filtering\" originally proposed by @grzegorz-herman or not. As for me personally, concept of intersection is more natural. If we're working with sets, why not use classic set operations?\r\n\r\nP.S.:\r\n> Some implementations (jayway IIRC) actually \u201csolve\u201d the problem above by applying the filtering predicate in [?(...)] to items or subitems, apparently depending on whether the items are arrays or not.\r\n\r\nAnd so does mine PHP implementation (which I've tried to implement as close as possible to JayWay's), but I think that it's absolutely ugly.\r\n",
          "createdAt": "2021-09-08T19:14:08Z",
          "updatedAt": "2021-09-08T19:18:07Z"
        },
        {
          "author": "grzegorz-herman",
          "authorAssociation": "NONE",
          "body": "@remorhaz:\r\n> In fact, we may be lacking an _intersection_ operation over unions. Some possible examples of this:\r\n> \r\n> 1. `$['a', 'b', 'c']#[?(@.v == true)]` - operator applies over two (or more) separate unions;\r\n> 2. `$['a', 'b', 'c' # ?(@.v == true)]` - operator applies over two (or more) groups of selectors within a single union.\r\n\r\nI find the second version somewhat weird: on the left-hand side of the intersection operator we have _indices_, while on the right \u2013 a predicate on _values_.\r\n\r\nYou can view the first as either an intersection of two unions, or as a regular child selection (`['a', 'b', 'c']`) followed by the filtering I am suggesting (`#[?(@.v == true)]`, in my non-syntax simply `{@.v == true}`). The latter has the advantage of being able to have additional selector in between, e.g. `$['a','b'].g{@.v == true}`.\r\n\r\n> > Some implementations (jayway IIRC) actually \u201csolve\u201d the problem above by applying the filtering predicate in [?(...)] to items or subitems, apparently depending on whether the items are arrays or not.\r\n> \r\n> And so does mine PHP implementation (which I've tried to implement as close as possible to JayWay's), but I think that it's absolutely ugly.\r\n\r\nI wholeheartedly agree!",
          "createdAt": "2021-09-08T20:06:51Z",
          "updatedAt": "2021-09-08T20:06:51Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I find the second version somewhat weird: on the left-hand side of the intersection operator we have indices, while on the right \u2013 a predicate on values.\r\n\r\nUnion (at least on the level of idea) is just a combination of selectors, it allows you to mix _any_ predicates, like this: `$['a', ?(@.v == true), 'b']`.\r\n\r\n**Update:** I've looked over draft and ensured that union is defined like this:\r\n> Union selector \"[<sel1>,<sel2>,...,<selN>]\", holding a comma delimited list of index, index wild card, array slice, and filter selectors.",
          "createdAt": "2021-09-09T06:32:26Z",
          "updatedAt": "2021-09-09T08:38:18Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And yes, you're right in that your `{...}` syntax is full equivalent of my first variant `#[...]` technically; the only difference is that my `#` works as binary operator \"intersect\" over unons (or their parts) that are already defined in syntax, and you define completely new selector; but how to name it? How to define it's input node list?",
          "createdAt": "2021-09-09T08:33:03Z",
          "updatedAt": "2021-09-09T08:33:03Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@remorhaz , Possibly follow XPath 2 and later approach to support [union and intersect operators](https://www.w3.org/TR/xpath-31/#combining_seq)? Union (\"|\") to combine the nodes returned by two or more paths, intersect to return the nodes common to both paths? And allow these operators to be grouped with left and right parentheses?\r\n\r\nIt could be argued that this is a natural evolution of JSONPath, much as XPath 1 evolved. It could also be argued that that's not JSONPath anymore.\r\n",
          "createdAt": "2021-09-09T16:31:08Z",
          "updatedAt": "2021-09-09T16:31:08Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@danielaparker, yes, the \"problem\" is that union syntax evolved naturally to `[..., ...]` in JSONPath - where `,` works like `|` in XPath and there's no grouping. I would like to find the way not to break this paradygm.\r\n\r\nIn fact, we can place all this grammar into `union-entry`. We can make two entries:\r\n\r\n- \"nested union\" entry `(.., ...)`;\r\n- binary `intersect` operator over entries.\r\n \r\nAnd get something like this:\r\n\r\n```\r\n$['a', ('b', 'c') intersect ?(@.val == true)]\r\n```\r\n\r\nThat could be translated to following functions:\r\n```\r\nunion(\r\n  index('a'),\r\n  intersection(\r\n    union(\r\n      index('b'),\r\n      index('c'),\r\n    ),\r\n    filter(@val == true),\r\n)\r\n```\r\n\r\nOf course this syntax has tons of pitfalls, but it follows XPath way in general. But we also can follow another way:\r\n\r\n```\r\n$['a', {['b', 'c'], ?(@.val == true)}]\r\n```\r\n\r\nIn other words, if we defined union like `[..., ...]`, then why not follow the naturally evolved pattern and define intersection like `{..., ...}`? And I see no problems in nesting these structures.\r\n\r\nIn this case, @grzegorz-herman 's problem salvation will be written like this:\r\n\r\n```\r\n${['a', 'b', 'c'], ?(@.val == true)}\r\n```\r\n\r\nWhat would you say?",
          "createdAt": "2021-09-09T18:06:11Z",
          "updatedAt": "2021-09-09T18:10:09Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, 9 Sep 2021, 19:06 Edward Surov, ***@***.***> wrote:\n\n> @danielaparker <https://github.com/danielaparker>, yes, the \"problem\" is\n> that union syntax evolved naturally to [..., ...] in JSONPath - where ,\n> works like | in XPath and there's no grouping. I would like to find the\n> way not to break this paradygm.\n>\n> In fact, we can place all this grammar into union-entry. We can make two\n> entries:\n>\n>    - \"nested union\" entry (.., ...);\n>    - binary intersect operator over entries.\n>\n> And get something like this:\n>\n> $['a', ('b', 'c') intersect ***@***.*** == true)]\n>\n> That could be translated in a following functions:\n>\n> union(\n>   index('a'),\n>   intersection(\n>     union(\n>       index('b'),\n>       index('c'),\n>     ),\n>     ***@***.*** == true),\n> )\n>\n> Of course this syntax has tons of pitfalls, but it follows XPath way in\n> general. But we also can follow another way:\n>\n> $['a', {['b', 'c'], ***@***.*** == true)}]\n>\n> In other words, if we defined union like [..., ...], then why not follow\n> the naturally evolved pattern and define intersection like {..., ...}?\n> And I see no problems in nesting these structures.\n>\n> In this case, @grzegorz-herman <https://github.com/grzegorz-herman> 's\n> problem salvation will be written like this:\n>\n> ${['a', 'b', 'c'], ***@***.*** == true)}\n>\n> What would you say?\n>\n\nI personally find that syntax a little obscure.\n\nAlso, it would be good to know we are satisfying a usecase which can't\neasily be satisfied in another way.\n\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/109#issuecomment-916321875>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2IAXGXJD2YOV3SPWCLUBDZR5ANCNFSM5ATLPCKQ>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-09-09T18:30:59Z",
          "updatedAt": "2021-09-09T18:30:59Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> @danielaparker, yes, the \"problem\" is that union syntax evolved naturally to `[..., ...]` in JSONPath - where `,` works like `|` in XPath and there's no grouping. I would like to find the way not to break this paradygm.\r\n> \r\n> But we also can follow another way:\r\n> \r\n> ```\r\n> $['a', {['b', 'c'], ?(@.val == true)}]\r\n> ```\r\n> \r\n> In other words, if we defined union like `[..., ...]`, then why not follow the naturally evolved pattern and define intersection like `{..., ...}`? And I see no problems in nesting these structures.\r\n> \r\n> In this case, @grzegorz-herman 's problem salvation will be written like this:\r\n> \r\n> ```\r\n> ${['a', 'b', 'c'], ?(@.val == true)}\r\n> ```\r\nReading the first suggestion made me feel woozy :-) I thought the second was easier on the eyes. I don't love or hate the notation, and could probably get used to it. I'm not personally enthusiastic about `{..., ...}` for intersection, I think I would prefer `[[..., ...]]`. But I'm used to being a minority of one.\r\n",
          "createdAt": "2021-09-09T21:32:39Z",
          "updatedAt": "2021-09-09T21:32:39Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU5NTE2MTUyODQ=",
      "title": "Support arbitrarily structured filter predicates",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/110",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The filter syntax currently requires predicates to be expressed in (something close to) disjunctive normal form (OR of ANDs), but this is likely to be inconvenient when the intention of the filter is expressed in a different way (e.g. as an AND or ORs or as a nested predicate with ANDs and ORs at various levels).\r\n\r\nThe JSONPath comparison project doesn't yet test these more complex predicates, although some, possibly most, implementations allow them.\r\n\r\nThe standard could allow arbitrarily structured predicates via syntax along these lines:\r\n```\r\nfilter-selector ::= \"[?(\" boolean-expr \")]\"\r\n\r\nboolean-expr ::= logical-and-expr |\r\n                 logical-and-expr \"||\" boolean-expr\r\n\r\nlogical-and-expr ::= basic-filter |\r\n                     basic-filter \"&&\" logical-and-expr\r\n\r\nbasic-filter ::= \"!\" basic filter |\r\n                 \"(\" boolean-expr \")\" |\r\n                 comp-expr\r\n```\r\n\r\nFor example, this would allow filters such as:\r\n```\r\n?(@.b && (@.c || @.d))\r\n```\r\nand\r\n```\r\n?(@.b && (@.c || @.d && @.e))\r\n```\r\n(where the semantics could, in line with mathematical convention and many programming languages, define `&&` to bind more tightly than `||`).\r\n\r\nNote: the comparison project's [Proposal A](https://github.com/cburgmer/json-path-comparison/tree/master/proposals/Proposal_A) restricts the syntax so that brackets are _required_ instead of making `&&` bind more tightly than `||`. This is a clever approach but is probably not suitable for the standard because it is rather unconventional.",
      "createdAt": "2021-07-23T14:09:53Z",
      "updatedAt": "2021-08-07T00:54:37Z",
      "closedAt": "2021-08-07T00:54:37Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I don't have a problem with requiring parentheses instead of creating an elaborate precedence hierarchy (or at least partially instead of).\r\n\r\nI also don't have a problem with arbitrary nesting here.",
          "createdAt": "2021-07-23T14:36:59Z",
          "updatedAt": "2021-07-23T14:36:59Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> where the semantics could, in line with mathematical convention and many programming languages, define `&&` to bind more tightly than `||`\n\nFor clarity, this is because `&&` is a multiplicative operation whereas `||` is additive.  Standard order of operations then apply.\n\nI don't know any programming language where this is reversed.  I'm not opposed to requiring `()`, however.",
          "createdAt": "2021-07-23T21:49:23Z",
          "updatedAt": "2021-07-23T21:49:23Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "If the fact that `&&`binds more tightly than `||` must be made explicite in the ABNF, it should be done. Using pairs of parentheses should be arbitrary.",
          "createdAt": "2021-07-26T15:07:03Z",
          "updatedAt": "2021-07-26T15:07:03Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Is there a preferred way to specify operator precedence in ABNF? The examples I've seen use a textual ordered list which won't help parser generators...",
          "createdAt": "2021-07-27T06:42:18Z",
          "updatedAt": "2021-07-27T06:42:18Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "The [C# spec (pdf)](https://www.ecma-international.org/wp-content/uploads/ECMA-334_5th_edition_december_2017.pdf) doesn't use ANBF, but it is pretty clear by using prose and a table.  See section 12.4.2.\r\n\r\n> When an expression contains multiple operators, the precedence of the operators controls the order in which the individual operators are evaluated. [_Note:_ For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the binary `+` operator. _end note_] The precedence of an operator is established by the definition of its associated grammar production. [_Note:_ For example, an additive-expression consists of a sequence of multiplicative-expressions separated by `+` or `-` operators, thus giving the `+` and `-` operators lower precedence than the `*`, `/`, and `%` operators. _end note_]\r\n> \r\n> [_Note:_ The following table summarizes all operators in order of precedence from highest to lowest:\r\n> \r\n> |Subclause|Category|Operators|\r\n> |---|---|---|\r\n> |\u00a712.7|Primary|`x.y f(x) a[x] x++ x-- new typeof default checked unchecked delegate`|\r\n> |\u00a712.8|Unary|`+ - ! ~ ++x --x (T)x await x`|\r\n> |\u00a712.9|Multiplicative|`* / %`|\r\n> |\u00a712.9|Additive|`+ -`|\r\n> |\u00a712.10|Shift|`<< >>`|\r\n> |\u00a712.11|Relational and<br>type-testing|`< > <= >= is as`|\r\n> |\u00a712.11|Equality|`== !=`|\r\n> |\u00a712.12|Logical AND|`&`|\r\n> |\u00a712.12|Logical XOR|`^`|\r\n> |\u00a712.12|Logical OR|`\\|`|\r\n> |\u00a712.13|Conditional AND|`&&`|\r\n> |\u00a712.13|Conditional OR|`\\|\\|`|\r\n> |\u00a712.14|Null coalescing|`??`|\r\n> |\u00a712.15|Conditional|`?:`|\r\n> |\u00a712.18<br>and<br>\u00a712.16|Assignment and<br>lambda expression|`= *= /= %= += -= <<= >>= &= ^= \\|= =>`|\r\n> \r\n> _end note_]\r\n\r\nThere's also a bit more about associativity, but I figured this was enough.",
          "createdAt": "2021-07-27T10:08:36Z",
          "updatedAt": "2021-07-27T10:08:52Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting. Does anyone know if ABNF parser generators infer operator\nprecedence from the structure of the productions?\n\nOn Tue, 27 Jul 2021, 11:08 Greg Dennis, ***@***.***> wrote:\n\n> The C# spec (pdf)\n> <https://www.ecma-international.org/wp-content/uploads/ECMA-334_5th_edition_december_2017.pdf>\n> doesn't use ANBF, but it is pretty clear by using prose and table. See\n> section 12.4.2.\n>\n> When an expression contains multiple operators, the precedence of the\n> operators controls the order in which the individual operators are\n> evaluated. [*Note:* For example, the expression x + y * z is evaluated as x\n> + (y * z) because the * operator has higher precedence than the binary +\n> operator. *end note*] The precedence of an operator is established by the\n> definition of its associated grammar production. [*Note:* For example, an\n> additive-expression consists of a sequence of multiplicative-expressions\n> separated by + or - operators, thus giving the + and - operators lower\n> precedence than the *, /, and % operators. *end note*]\n>\n> [*Note:* The following table summarizes all operators in order of\n> precedence from highest to lowest:\n> Subclause Category Operators\n> \u00a712.7 Primary x.y f(x) a[x] x++ x-- new typeof default checked unchecked\n> delegate\n> \u00a712.8 Unary + - ! ~ ++x --x (T)x await x\n> \u00a712.9 Multiplicative * / %\n> \u00a712.9 Additive + -\n> \u00a712.10 Shift << >>\n> \u00a712.11 Relational and\n> type-testing < > <= >= is as\n> \u00a712.11 Equality == !=\n> \u00a712.12 Logical AND &\n> \u00a712.12 Logical XOR ^\n> \u00a712.12 Logical OR |\n> \u00a712.13 Conditional AND &&\n> \u00a712.13 Conditional OR ||\n> \u00a712.14 Null coalescing ??\n> \u00a712.15 Conditional ?:\n> \u00a712.18\n> and\n> \u00a712.16 Assignment and\n> lambda expression = *= /= %= += -= <<= >>= &= ^= |= =>\n>\n> *end note*]\n>\n> There's also a bit more about associativity, but I figured this was enough.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/110#issuecomment-887385549>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2NKFVNLICN7IHHRZ4TTZ2AS5ANCNFSM5A4CRLWA>\n> .\n>\n",
          "createdAt": "2021-07-27T10:15:29Z",
          "updatedAt": "2021-07-27T10:15:29Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-07-27, at 12:15, Glyn Normington ***@***.***> wrote:\n> \n> Interesting. Does anyone know if ABNF parser generators infer operator\n> precedence from the structure of the productions?\n\nI would venture to say that is a near-universal property of BNF-based parser generators.\n\nStrictly speaking, BNF provides only a Boolean output: word is in language or it is not.  But in reality, people use BNF for parsing, and build the parse tree along the structure of the BNF productions that was used for matching.  That may be ambiguous even when the language created by the BNF isn\u2019t, and that\u2019s one reason why we have all these variants like LL(1) and LR(k) etc.  \n\nThe parse tree is then used to build an \u201cabstract syntax tree\u201d, ast, in many cases by attaching actions to the productions in the grammar.\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-07-27T10:52:13Z",
          "updatedAt": "2021-07-27T10:52:13Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU5NjAzNzA4MDg=",
      "title": "Generalise filter comparisons",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/112",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, filter comparison require a path on the left hand side and a constant expression on the right hand side.  This seems overly restrictive. We should generalise it to allow the opposite order as well as path to path comparisons and, for completeness, constant expression to constant expression comparisons.\r\n\r\nFor example, the following comparisons should be valid:\r\n```\r\n@.foo == 1\r\n1 == @.foo\r\n@.foo == @.bar\r\n1 == 1\r\n```",
      "createdAt": "2021-08-04T12:29:25Z",
      "updatedAt": "2021-08-10T09:13:15Z",
      "closedAt": "2021-08-10T09:13:15Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Should `=~` be symmetric, too?",
          "createdAt": "2021-08-04T12:35:01Z",
          "updatedAt": "2021-08-04T12:35:01Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Did you mean `~=` (which is what we use in the current draft)?\r\n\r\nI think not because its operands have distinct types and it's probably easier to police restrictions and give good diagnostics if we keep `~=` asymmetric. For instance, with the current syntax:\r\n```\r\n@.foo ~= @.bar\r\n```\r\ncan fail with an error such as \"@.bar needs to be a regular expression literal\", which is a bit easier to understand than something like \"one side of ~= needs to be a regular expression literal\".\r\n\r\nHaving said that, other generalisations of `~=` may be worth it, such as allowing a string literal (rather than only a path) on the left hand side, for consistency with the above syntax for the other comparison operators, but even that could be give rise to confusion, e.g.:\r\n```\r\n\"/.*/\" ~= /.*/\r\n```",
          "createdAt": "2021-08-04T12:49:15Z",
          "updatedAt": "2021-08-04T12:49:15Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Oops.  It really should be `=~`.\r\n\r\nPerl introduced `=~` as `string =~ regexp` (where regexp actually could be a substitute operator etc.).\r\nRuby generalized this to `regexp =~ string` and `string =~ regexp` (actually, even more general...).\r\nJava, JavaScript, Python, PowerShell don't have an operator at all; this is all handled using method calls.\r\n\r\nSo if we want to have syntax for regexp matching, we probably want to go with Perl's.\r\nWe also need to discuss whether we need syntax for regexp literals.\r\nBut this is maybe leading beyond this github issue.",
          "createdAt": "2021-08-04T13:07:07Z",
          "updatedAt": "2021-08-04T13:08:42Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "When witing `$[?(1==1])` the current node represented by `@` will be selected. So resulting in the same as `$[*]`.\r\n\r\nIs this really, what we want?",
          "createdAt": "2021-08-04T13:28:58Z",
          "updatedAt": "2021-08-04T13:28:58Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Anything else we might want?\r\n\r\n(I'm not sure we can write a syntax that only lets \"meaningful\" expressions through.)",
          "createdAt": "2021-08-04T13:31:03Z",
          "updatedAt": "2021-08-04T13:31:03Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Convinced ... you made the point.",
          "createdAt": "2021-08-04T13:38:14Z",
          "updatedAt": "2021-08-04T13:38:14Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU5NjAzOTk3NzQ=",
      "title": "Operator precedence table",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/113",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Introducing an operator precedence table will help us comunicate what we are trying to achieve precedence-wise in the ABNF syntax.\r\n\r\n_Originally posted by @cabo in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/111#issuecomment-892618964_",
      "createdAt": "2021-08-04T12:52:12Z",
      "updatedAt": "2021-08-10T09:13:15Z",
      "closedAt": "2021-08-10T09:13:15Z",
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is a first version ... taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\r\n\r\n| Precedence | Operator type | Syntax | Comment |\r\n|:--:|:--:|:--:|:--:|\r\n|  6  | Grouping | `(...)` |  | \r\n|  5  | Logical NOT | `!` |  | \r\n|  4  | Less Than<br>Greater Than<br>Less Than Or Equal<br>Greater Than Or Equal | `<`<br>`>`<br>`<=`<br>`>=` | Relation | \r\n|  3  | Equal To<br>Not Equal To | `==`<br>`!=` | Comparison | \r\n|  2  | Logical AND | `&&` |  | \r\n|  1  | Logical OR | `\\|\\|` |  | \r\n",
          "createdAt": "2021-08-04T13:22:17Z",
          "updatedAt": "2021-08-04T13:22:17Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for that @goessner!\r\n\r\nI suggest we combine the third and fourth rows and give `==` and `!=` the same precedence as the other comparison operators as I don't think there is a situation where their relative precedence is necessary.\r\n\r\nAlso, having a separate row for `==` and `!=` gives the impression we want to entertain expressions such as:\r\n```\r\n@.foo < 2 == @.bar\r\n```\r\nand\r\n```\r\n1 < 2 == 2 < 3\r\n```\r\nwhich I'd prefer to avoid",
          "createdAt": "2021-08-04T13:44:00Z",
          "updatedAt": "2021-08-04T13:44:00Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes ... so ...\r\n\r\n| Precedence | Operator type | Syntax | Comment |\r\n|:--:|:--:|:--:|:--:|\r\n|  5  | Grouping | `(...)` |  | \r\n|  4  | Logical NOT | `!` |  | \r\n|  3  | Equal To<br>Not Equal To<br>Less Than<br>Greater Than<br>Less Than Or Equal<br>Greater Than Or Equal | `==`<br>`!=`<br>`<`<br>`>`<br>`<=`<br>`>=` | Comparison | \r\n|  2  | Logical AND | `&&` |  | \r\n|  1  | Logical OR | `\\|\\|` |  | \r\n",
          "createdAt": "2021-08-04T15:46:54Z",
          "updatedAt": "2021-08-04T15:46:54Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWU5NjA0MjQ1MDM=",
      "title": "regex comparison operator should be =~",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/114",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Perl introduced `=~` as `string =~ regexp` (where regexp actually could be a substitute operator etc.).\r\nRuby generalized this to `regexp =~ string` and `string =~ regexp`.\r\n(Java, JavaScript, Python, PowerShell don't have an operator at all; this is all handled using method calls.)\r\n\r\nSo if we want to have syntax for regexp matching, we probably want to go with Perl's.\r\n\r\n_Originally posted by @cabo in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/112#issuecomment-892642185_",
      "createdAt": "2021-08-04T13:09:14Z",
      "updatedAt": "2021-08-10T09:13:15Z",
      "closedAt": "2021-08-10T09:13:15Z",
      "comments": []
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU5ODI4OTk1NzY=",
      "title": "Normalization",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/117",
      "state": "OPEN",
      "author": "cburgmer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When looking up object member names (dot selector or index selector) normalization of strings becomes an issue. See https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization for an introduction on normalization in Unicode. \r\n\r\nAs indicated with one test in the comparison project (https://cburgmer.github.io/json-path-comparison/#bracket_notation_with_NFC_path_on_NFD_key) it seems though that there is consensus not to respect equivalent code points. The Raku implementation is the only one that matches the equivalent key, which seems to stem from the Raku runtime already normalizing strings upfront (if my manual tests are to be believed).\r\n\r\nIs this something we want to prescribe in a standard, or would we end up with advice possibly contradicting the implementation of JSON parsers? (A quick search turned up http://seriot.ch/parsing_json.php which complains about different implementation in parsers with respect to string normalization.)",
      "createdAt": "2021-08-30T15:08:46Z",
      "updatedAt": "2021-09-01T08:38:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe there's already a convention that bracketed syntax (`[1]` and `['foo']`) is the normalized syntax.\n\nSecondarily, where should these normalized paths be used/enforced?  Surely input should handle any form.  However output (i.e. paths to matches) should be normalized.",
          "createdAt": "2021-08-30T22:45:16Z",
          "updatedAt": "2021-08-30T22:45:16Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cburgmer, it's an interesting issue. \r\n\r\nI was interested in how XPath 3.1 handles normalization, discussed [here](https://www.w3.org/TR/xpath-functions-31/#character-terminology), and it appears to have very limited support, remarking that \"Unless explicitly stated, the `xs:string` values returned by the functions in this document are not normalized in the sense of [Character Model for the World Wide Web 1.0: Fundamentals](https://www.w3.org/TR/charmod/).\r\n\r\nXPath 3.1 does have an [fn:normalize-unicode](https://www.w3.org/TR/xpath-functions-31/#func-normalize-unicode) function, which applies unicode normalization to a string. It has a two argument overload that allows the caller to set the Normalization Form, with five different kinds of normalization. I suppose we could use such a function to compare string values in filter expressions.\r\n\r\nAs for looking up property values in a JSON object, I think many JSONPath implementations use functions provided by another library, such as `JsonElement.TryGetProperty` in `.Net`. And it seems from your test that they don't generally support normalization.\r\n\r\n",
          "createdAt": "2021-08-31T01:24:31Z",
          "updatedAt": "2021-08-31T01:24:31Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Wait, are we discussing _Unicode_ normalization or _Path_ normalization?  I think my comment may have been off-topic.",
          "createdAt": "2021-08-31T04:26:26Z",
          "updatedAt": "2021-08-31T04:26:26Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "When discussing normalisation of text in this context, it is useful to have read https://www.w3.org/TR/charmod-norm/\r\n\r\n(I'm assuming that we are not using the once popular model where processing entails text-normalising everything in sight first and then working with that, but that text normalisation occurs only as part of comparison.)\r\n\r\nIt seems that text comparison is relevant to JSONPath in two places:\r\n\r\n- indexing of JSON objects\r\n- expression language equality/equivalence\r\n\r\nDepending on your view what JSON objects are good for, indexing may have a normalisation requirement or you are only ever indexing with known vocabulary (which is then easy to pre-normalize).\r\n\r\nExpression language equivalence cannot ignore the problem as easily, or you won't find J\u00f6rg if you have a J\u00f6rg (sorry, this distinction doesn't seem to survive here).",
          "createdAt": "2021-08-31T06:35:23Z",
          "updatedAt": "2021-08-31T06:35:23Z"
        },
        {
          "author": "cburgmer",
          "authorAssociation": "NONE",
          "body": "I've added another test for filter expressions with string equality. It shows two implementations employ some form of normalization when checking for equality: https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_equals_string_in_NFC.html (see `Mot\\u00f6rhead` and `Moto\\u0308rhead`), while (again) consensus seems to be to not normalize.",
          "createdAt": "2021-08-31T14:54:04Z",
          "updatedAt": "2021-08-31T15:00:35Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I'm relieved that the consensus appears to be to use byte string comparison.\r\n(I'm too dense to find out which ones are the implementations that do employ some normalization.)\r\n\r\nThat does not mean, though, that we couldn't **add** a separate operator for normalizing comparison.\r\n",
          "createdAt": "2021-08-31T15:44:39Z",
          "updatedAt": "2021-08-31T15:44:39Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> I've added another test for filter expressions with string equality ... consensus seems to be to not normalize.\r\n\r\nAs a practical matter, I think that the issue would most likely be felt in this context, rather than with key lookup. Keys are usually chosen judiciously so as not to cause problems.\r\n\r\nFor JSONPath implementations in interpreted languages such as JavaScript, Python or PHP, and whose filter expressions are these languages, they already have functions that return the Unicode Normalization Form of strings, see e.g. [JavaScript String.prototype.normalize](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize), [Python unicodedata.normalize](https://docs.python.org/3.6/library/unicodedata.html#unicodedata.normalize), and [PHP normalizer.normalize](https://www.php.net/manual/en/normalizer.normalize.php).\r\n\r\nPerhaps other implementations that implement their own expression evaluators could support a function like XPath's [fn:normalize-unicode](https://www.w3.org/TR/xpath-functions-31/#func-normalize-unicode).\r\n\r\nFor another comparison, I looked at [JMESPath](https://jmespath.org/specification.html), and it specifically states that \"All string related functions are defined on the basis of Unicode code points; they do not take normalization into account.\" There is a community developed JMESPath extension library that  supports other functions, but I don't think any of these provide normalization functionality.",
          "createdAt": "2021-08-31T16:55:41Z",
          "updatedAt": "2021-08-31T20:10:05Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "For one more comparison, I looked at [JSONiq](https://www.jsoniq.org/docs/JSONiq/webhelp/index.html#:~:text=As%20a%20matter%20of%20fact,information%20cleaning%2C%20and%20so%20on), an ISO/IEC approved, OASIS standard. JSONiq supports the XPath and XQuery function [fn:normalize-unicode](https://www.w3.org/TR/xpath-functions-30/#func-normalize-unicode).",
          "createdAt": "2021-08-31T17:07:56Z",
          "updatedAt": "2021-08-31T17:07:56Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to cite JSON RFC-8259, section [8.3](https://datatracker.ietf.org/doc/html/rfc8259#section-8.3):\r\n\r\n> 8.3.  String Comparison\r\n>\r\n> Software implementations are typically required to test names of object members for equality.  Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings.  For example, implementations that compare strings with escaped characters unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not equal.\r\n\r\nSo, JSON considers strings equal if they consist of same sequences of Unicode code units. In fact that means that valid JSON object can have two property keys that will become equal if normalized. If we enforce normalization in JSONPath, we cannot address each of those properties separately.",
          "createdAt": "2021-09-01T08:38:32Z",
          "updatedAt": "2021-09-01T08:38:32Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU5ODg3NzU2NDY=",
      "title": "key missing vs key present with null",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/118",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A new [StackOverflow question](https://stackoverflow.com/q/69069083/878701) highlights the need to define whether these two cases are the same or different:\r\n\r\n- a key missing\r\n- a key present but with `null` as a value\r\n\r\nI would expect that Javascript would handle these cases differently, but .Net generally wouldn't (it seems Newtonsoft has some special handling for this).\r\n\r\nPosed in a more direct, testable way, given the data\r\n\r\n```json\r\n[\r\n  {\r\n      \"id\": 2\r\n  }\r\n]\r\n```\r\n\r\nwould\r\n\r\n```\r\n$[?(@.foo==null)]\r\n```\r\n\r\nreturn any results?\r\n\r\n(related to #64 and #47)",
      "createdAt": "2021-09-06T05:14:17Z",
      "updatedAt": "2021-09-24T16:52:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cburgmer",
          "authorAssociation": "NONE",
          "body": "I think the corresponding test in the comparison project is https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_equals_null.html. Currently no consensus exists.",
          "createdAt": "2021-09-06T06:45:49Z",
          "updatedAt": "2021-09-06T06:45:49Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "I think this is related to [\\#74](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/74). Or, what does the left hand side of `@.foo==null` mean? It means different things in different implementations. \r\n\r\nFor JSONPath implementations in interpreted languages such as JavaScript, Python or PHP, and whose filter expressions are these languages, `@.foo` in the case of no match may mean `undefined`, `null`, `false`, or a type error. \r\n\r\nIn Javascript, `@.foo` in the case of no match means `undefined`. So in Goessner Javascript, we have:\r\n\r\n`$[?(@.foo==null)]` returns `[  { \"id\": 2 }]`\r\n`$[?(@.foo==false)]` returns `[  { \"id\": 2 }]`\r\n`$[?(@.foo===null)]` returns `false`\r\n`$[?(@.foo===false)]` returns `false`\r\n`$[?(@.foo===undefined)]` returns `[  { \"id\": 2 }]`\r\n\r\nFor implementations such as Jayway, jsoncons, and JsonCons.JsonPath, where `@.foo` means a JSONPath expression that returns a single JSON value (rather than an array of values), it depends on what the implementation specifies `@.foo` to evaluate to when there is no match. For some, it's `null`, for others `false`, and for others it's a type error.  In Jayway, by default it's a type error, and the item being evaluated is omitted from the results (Jayway has an option to evaluate to a null value instead.) \r\n\r\nIn [JMESPath](https://jmespath.org/), for comparison, evaluating an object with a missing key is specified to return a null value, so \r\n```\r\n[?foo==null]\r\n```\r\nreturns\r\n```\r\n[  { \"id\": 2 }]\r\n```\r\n\r\nIn [JSONiq](https://www.jsoniq.org/), for another comparison, evaluating an object with a missing key results in an empty sequence, viz.\r\n```\r\nlet $doc := [\r\n  {\r\n      \"id\": 2\r\n  }\r\n]\r\n\r\nfor $x in $doc[]\r\nwhere $x.\"foo\" eq null\r\n\r\nreturn $x\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-06T12:12:28Z",
          "updatedAt": "2021-09-06T16:13:57Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, it does relate to that as well!  I interpret literals as JSON values.",
          "createdAt": "2021-09-06T12:56:06Z",
          "updatedAt": "2021-09-06T12:56:54Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> Yes, it does relate to that as well! I interpret literals as JSON values.\r\n\r\nThat and https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/64#issuecomment-831755108",
          "createdAt": "2021-09-06T14:17:15Z",
          "updatedAt": "2021-09-06T15:46:34Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> > Yes, it does relate to that as well! I interpret literals as JSON values.\r\n> \r\n> That and [#64 (comment)](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/64#issuecomment-831755108)\r\n\r\nIn any case, it's impossible to talk about what \r\n```\r\n?(@.foo==null)\r\n```\r\nmeans without first defining what `@.foo` means (including when `foo` is missing), and what `==` means. Different implementations define them differently, the draft doesn't currently define them at all.\r\n\r\nDaniel",
          "createdAt": "2021-09-07T11:32:09Z",
          "updatedAt": "2021-09-07T12:18:04Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielaparker you're getting a little ahead of yourself. Operators and relative paths in expressions are discussed in other issues that deal with expressions themselves. These are quite well-defined in those issues.",
          "createdAt": "2021-09-07T20:01:29Z",
          "updatedAt": "2021-09-07T20:01:29Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@gregsdennis, just noting that the answer to this issue you raised follows immediately once the meaning of `@.foo` and `==` have been defined. Nothing more. ",
          "createdAt": "2021-09-07T21:26:10Z",
          "updatedAt": "2021-09-07T21:26:10Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> @gregsdennis, just noting that the answer to this issue you raised follows immediately once the meaning of `@.foo` and `==` have been defined. Nothing more.\r\n\r\nIndeed, so the discussion here should inform the decisions we make for empty `@.foo` and for `==`.",
          "createdAt": "2021-09-08T05:50:30Z",
          "updatedAt": "2021-09-08T05:50:30Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "The latest draft seems to be pretty clear about that.\r\n\r\nhttps://ietf-wg-jsonpath.github.io/draft-ietf-jsonpath-base/draft-ietf-jsonpath-base.html#name-filter-selector\r\n\r\n> A member or element value by itself is falsy only, if it does not exist. Otherwise it is truthy, resulting in its value. To be more specific explicit comparisons are necessary. This existence test -- as an exception of the general rule -- also works with complex values.\r\n\r\nProblem here is, that JSON lacks  `undefined ` value (from JavaScript). So we decided to use standalone path expressions in filters as existence tests\r\n\r\n* `[?@foo]` ... selected, if member `foo` exists.\r\n*  `[?(!@foo)]` ... selected, if member `foo` does not exists.\r\n*  but `[?(!!@foo)]` ... selected, if value of  `foo` is truthy.\r\n* `[?(@foo == null)]` ... selected only, if member exactly has that value.\r\n*  `[?(!@foo == true)]` ... not allowed with comparison, rather use  `[?(@foo != true)]`.\r\n\r\nUsing new `in` operator also allows test for existence now as with `[?('foo' in @)]`.\r\n\r\nMost of discussions were done in this pull request\r\n\r\nhttps://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/111\r\n\r\nAm I missing something here?\r\n\r\n-- sg\r\n",
          "createdAt": "2021-09-08T09:40:34Z",
          "updatedAt": "2021-09-08T09:40:34Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> The latest draft seems to be pretty clear about that.\r\n> \r\n> https://ietf-wg-jsonpath.github.io/draft-ietf-jsonpath-base/draft-ietf-jsonpath-base.html#name-filter-selector\r\n> \r\n> Most of discussions were done in this pull request\r\n> \r\n> #111\r\n> \r\n> Am I missing something here?\r\n> \r\nWhat's missing, and what's missing generally in the draft, is any survey and analysis of prior experience in the great physical tarpit that is JSONPath. And if the purpose of this IETF effort really is to standardize existing practice, I think that's important. Of course, if that's not the purpose, than it doesn't matter, but everybody says that's the purpose.\r\n\r\nIt's not that the rules you've sketched here cannot be motivated by some prior experience, see e.g my analysis [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/119#issuecomment-919628694). 11 of 42 implementations, including two that may be considered important,  do follow this rule:\r\n\r\n[?(@.foo)] ... selected, if member foo exists.\r\n\r\nBut Goessner Javascript doesn't follow that rule. Nor do a significant number of others. \r\n\r\nIf the draft really is about standardizing existing behaviour, it seems to me that it needs to justify its choices with reference to prior experience.  Not just with what \"we\" (a handful of people) \"agreed\".\r\n",
          "createdAt": "2021-09-15T18:46:33Z",
          "updatedAt": "2021-09-15T18:53:27Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "hmm ... in my original proposal I included (as already someone mentioned):\r\n\r\n```\r\n//book[isbn]   | $..book[?(@.isbn)]   |  filter all books with isbn number |\r\n```\r\nIt seems to be, this was of no significant relevance for existing implementations.",
          "createdAt": "2021-09-16T07:26:19Z",
          "updatedAt": "2021-09-16T07:26:19Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@goessner would your implementation match on `isbn: null`?",
          "createdAt": "2021-09-16T08:25:15Z",
          "updatedAt": "2021-09-16T08:25:15Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "of course it would ... as I reused the Javascript engine for simplicity then.",
          "createdAt": "2021-09-16T10:00:26Z",
          "updatedAt": "2021-09-16T10:00:26Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@goessner, maybe I've misunderstood Greg's question, but  I think you meant to reply \"of course it wouldn't\". Using Goessner Javascript, and given the JSON document\r\n```\r\n{\r\n    \"store\": {\r\n        \"book\": [\r\n            {\r\n                \"isbn\" : null\r\n            }\r\n    ]\r\n  }\r\n}\r\n``` \r\nthe query\r\n```\r\n$..[?(@.isbn)]\r\n```\r\nreturns nothing. This is what we expect from JavaScript, and is consistent with the results reported [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/119#issuecomment-919628694).\r\n\r\nJayway (Java), on other other hand, returns \r\n```\r\n[\r\n   {\r\n      \"isbn\" : null\r\n   }\r\n]\r\n```",
          "createdAt": "2021-09-16T13:40:06Z",
          "updatedAt": "2021-09-16T14:54:52Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> hmm ... in my original proposal I included (as already someone mentioned):\r\n> \r\n> ```\r\n> //book[isbn]   | $..book[?(@.isbn)]   |  filter all books with isbn number |\r\n> ```\r\n> \r\n> It seems to be, this was of no significant relevance for existing implementations.\r\n\r\nI don't think any of the JSONPath implementations that use a dynamic language for evaluation, whether JavaScript,  PHP, Python, Ruby or Lua, evaluate `?(@.isbn)` that way. They all evaluate `@.isbn` first and then apply \"not falsey\" rules of one sort or another to the result. It's the textbook way for interpreting an expression. That's a lot of implementations, including the original.\r\n\r\nOn the other hand a significant number of (not all) implementations that implemented their own expression evaluators do evaluate  `?(@.isbn)` that way, including Jayway JsonPath. It's messier to implement it this way because it's not following the textbook evaluation patterns. Jayway does it by treating `@.isbn` as a recoverable error if isbn is missing, and handling that error to allow other terms being evaluated to continue. \r\n\r\n  ",
          "createdAt": "2021-09-16T14:32:21Z",
          "updatedAt": "2021-09-16T15:19:19Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\r\n> If the draft really is about standardizing existing behaviour, it seems to me that it needs to justify its choices with reference to prior experience. Not just with what \"we\" (a handful of people) \"agreed\".\r\n\r\nThe charter is quite specific:\r\n\r\n> The WG will develop a standards-track JSONPath specification that\r\nis technically sound and complete, based on the common semantics\r\nand other aspects of existing implementations. Where there are\r\ndifferences, the working group will analyze those differences and\r\nmake choices that rough consensus considers technically best, with\r\nan aim toward minimizing disruption among the different JSONPath\r\nimplementations.\r\n\r\nSince we do have those differences here, we are asked to consider what is \"technically best\", but \"with an aim toward minimizing disruption\".  This seems clear to me, and I think our charter writers did a very good job here.\r\n",
          "createdAt": "2021-09-16T15:00:20Z",
          "updatedAt": "2021-09-16T15:00:20Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> Since we do have those differences here, we are asked to consider what is \"technically best\", but \"with an aim toward minimizing disruption\". This seems clear to me, and I think our charter writers did a very good job here.\r\n\r\nI think it's hard to make a case that the draft is doing much to minimize disruption.\r\n\r\nOn the one hand, it's becoming incompatible with all of the implementations that use a dynamic language such as Javascript, PHP, Python, Ruby or Lua for evaluating expressions. For users of such implementations, having an expression language in their familiar language, with all of the functions that that language provides, is part of the appeal of these implementations. The users of these implementations all have a `normalize-unicode` function equivalent for comparing strings, and much else. These users don't care about interoperability, they care about familiarity and expressiveness.\r\n\r\nOn the other hand, the WG is sketching out an expression language that is different from the expression languages that were developed by other implementations mostly following Jayway Java. These expression languages specified `@.relative-path` as a JSONPath expression, with rules for \"ExecuteSingle\" to produce a single value for use in comparisons. `@.` means something different in the draft, where it's not a JSONPath expression. But Jayway Java is integrated into legacy Java enterprise software, and cannot change.\r\n\r\nIt seems to me that the draft is departing from both streams of JSONPath that evolved from the original article. I don't see anything in the draft that suggests that the editors consider prior experience important. There is no text in the draft that discusses the important implementations, and which features were motivated by one, which from another, and which are new or refinements.\r\n\r\nAnyway, I realize that nobody here is interested in this topic, no doubt for the obvious reason :-) \r\n",
          "createdAt": "2021-09-16T19:47:52Z",
          "updatedAt": "2021-09-16T20:14:11Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Daniel wrote:\n> I don't see anything in the draft that suggests that the editors consider\nprior experience important. There is no text in the draft that discusses\nthe important implementations,\n> and which features were motivated by one, which from another, and which\nare new or refinements.\n\nI consider prior experience to be very important and I'm sure Stefan does\ntoo. However, I am not sure to what extent the spec should reference\nparticular implementations since such references will not necessarily stand\nthe test of time. Perhaps an appendix is the way to do it, in which case,\nplease feel free to submit a PR to help lead the way forward. Editors need\nnot be the only authors.\n\n>\n\n> Anyway, I realize that nobody here is interested in this topic, no doubt\nfor the obvious reason :-)\n\nNot so.\n\nOn Thu, 16 Sept 2021 at 20:48, Daniel Parker ***@***.***>\nwrote:\n\n> Since we do have those differences here, we are asked to consider what is\n> \"technically best\", but \"with an aim toward minimizing disruption\". This\n> seems clear to me, and I think our charter writers did a very good job here.\n>\n> I think it's hard to make a case that the draft is doing much to minimize\n> disruption.\n>\n> On the one hand, it's becoming incompatible with all of the\n> implementations that use a dynamic language such as Javascript, PHP,\n> Python, Ruby or Lua for evaluating expressions. For users of such\n> implementations, having an expression language in their familiar language,\n> with all of the functions that that language provides, is part of the\n> appeal of these implementations.\n>\n> On the other hand, the WG is sketching out an expression language that is\n> different from the expression languages that were developed by other\n> implementations mostly following Jayway. These expression languages\n> specified @.relative-path as a JSONPath expression, with rules for\n> \"ExecuteSingle\" to produce a single value for use in comparisons. @.\n> means something different in the draft, where it's not a JSONPath\n> expression.\n>\n> It seems to me that the draft is departing from both streams of JSONPath\n> that evolved from the original article. I don't see anything in the draft\n> that suggests that the editors consider prior experience important. There\n> is no text in the draft that discusses the important implementations, and\n> which features were motivated by one, which from another, and which are new\n> or refinements.\n>\n> Anyway, I realize that nobody here is interested in this topic, no doubt\n> for the obvious reason :-)\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/118#issuecomment-921196950>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2OMWFKBT5DNTHL3FULUCJCXHANCNFSM5DPUZ5FA>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-09-16T20:38:48Z",
          "updatedAt": "2021-09-16T20:38:48Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that such references do not belong in the main text of the spec. An appendix is okay. I'd I had my way, if have a separate companion doc that summarized individual decisions and the reasoning behind them.  Such a document would be a natural place to include references to behaviors in existing implementations.",
          "createdAt": "2021-09-17T00:46:57Z",
          "updatedAt": "2021-09-17T00:47:10Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@glyn wrote\r\n\r\n> Perhaps an appendix is the way to do it, in which case, please feel free to submit a PR to help lead the way forward. \r\n\r\nIf the purpose of the WG is to standardize existing behavior, as they say it is, I think it's up to the authors to justify how their choices relate to prior experience.  \r\n\r\nFor example, there is plenty of prior experience with specifying filter expressions, starting with Jayway, the second most important and influential implementation after Goessner. Jayway, for example, has answers to all the questions like https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/118, https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/119 and https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/123. But the WG take on expressions appears to be inconsistent with that prior experience in significant respects. I think the authors should explain why. That is, if the authors really mean it when they say that their intent is to standardize existing behavior.",
          "createdAt": "2021-09-24T12:52:41Z",
          "updatedAt": "2021-09-24T14:06:18Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\n\nSent from mobile, sorry for terse\n\n> On 24. Sep 2021, at 14:53, Daniel Parker ***@***.***> wrote:\n> \n> If the purpose of the WG is to standardize existing behavior\n\nIt\u2019s not. Please reread the charter. \n\nRFC 2418 talks more about the role of authors (ie to implement the directions of the WG), and I\u2019m certain the authors will do that. If the WG wants to have a big rationale section to document their decisions beyond what feels natural for the authors, all I can say is \u201csend text\u201d\u2026",
          "createdAt": "2021-09-24T16:24:33Z",
          "updatedAt": "2021-09-24T16:24:33Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> Sent from mobile, sorry for terse\r\n> On 24. Sep 2021, at 14:53, Daniel Parker ***@***.***> wrote: If the purpose of the WG is to standardize existing behavior\r\n> It\u2019s not. \r\n\r\nThanks for the clarification.",
          "createdAt": "2021-09-24T16:52:21Z",
          "updatedAt": "2021-09-24T16:52:21Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU5OTI5MDg5NTI=",
      "title": "Semantics of @.foo as a standalone expression (truthiness)",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/119",
      "state": "OPEN",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently we have `$[?(@.foo)]` (I'm just going to use `@.foo` for brevity) to represent \"the item is an object and contains a `foo` property.\"  It also seems that some implementations evaluate the truthiness of the value of the `foo` property, if it exists, while others that accept the syntax interpret it to strictly consider existence.\r\n\r\nRelated comparison results:\r\n- [Filter Expression On Object](https://cburgmer.github.io/json-path-comparison/results/filter_expression_on_object.html)\r\n- [Filter Expression Without a Value](https://cburgmer.github.io/json-path-comparison/results/filter_expression_without_value.html)\r\n\r\nThere has also been an [email thread](https://mailarchive.ietf.org/arch/msg/jsonpath/yJEZ1bbdFt19qRAeHEoMqtB6jRg/) floating around discussing truthiness, but I wanted something a bit easier to read through than emails.\r\n\r\nOne aspect that I don't think has been considered in the email thread is the ability to consider strict existence.  On StackOverflow, [this](https://stackoverflow.com/questions/69069083/write-a-jsonpath-query-for-a-null-property-with-newtonsoft-json-net) and [this](https://stackoverflow.com/questions/69120789/how-to-get-the-result-which-has-not-the-property-with-jpath-in-the-newtonsoft) question both have asked about Newtonsoft's (.Net) support for this syntax, and the second seems to be asking specifically about detecting the _absense_ of a property as opposed to its presence with a `null` value.\r\n\r\nI think strict existence detection is an important feature to support, and if we move to have this syntax operate on truthiness, I fear we won't be able to support it.\r\n\r\nImportantly, I would suggest that regardless of the decision we make here, `!@.foo` should return the inverse set.\r\n",
      "createdAt": "2021-09-10T05:45:38Z",
      "updatedAt": "2021-09-15T09:54:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> `!@.foo` should return the inverse set.\r\n\r\nYes! `@.foo` should always be `true` or `false` and `!@.foo` should always be the negation of `@.foo`.\r\n\r\nI would prefer:\r\n* `@.foo` always to denote strict existence of the key `foo` in the object `@` (and be `false` in other cases, e.g. when `@` is not an object).\r\n* there to be no implicit conversion of values to booleans and therefore no need for the concepts of truthy and falsy in the spec.",
          "createdAt": "2021-09-10T06:37:41Z",
          "updatedAt": "2021-09-10T06:37:41Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\r\n> Yes! `@.foo` should always be `true` or `false` \r\n\r\nYou lost me here.\r\n\r\n`@.foo.bar` doesn't work any longer if `@.foo` is defined that way.\r\n\r\n> and `!@.foo` should always be the negation of `@.foo`.\r\n\r\nThat is one of the places where @.foo could be used in a context that expects a Boolean value, as is `$[?(@.foo)]`.\r\nI think you are saying that there should be an implicit conversion of the range of @.foo (which I called a nodelist before, but we don't need to stick with that) to Boolean.\r\n\r\nAnd then you are outlining what that conversion should look like:\r\n\r\n> * `@.foo` always to denote strict existence of the key `foo` in the object `@` (and be `false` in other cases, e.g. when `@` is not an object).\r\n\r\nWhich means that I don't understand this:\r\n\r\n> * there to be no implicit conversion of values to booleans and therefore no need for the concepts of truthy and falsy in the spec.\r\n\r\n\r\n",
          "createdAt": "2021-09-10T06:50:29Z",
          "updatedAt": "2021-09-10T06:50:29Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`@.foo` as itself just provides some node list (either empty or not). Then we can:\r\n\r\n- Use it in filter directly or with logical operator, like `$[?(@.foo)]`, or `$[?(@.foo and @.bar == 1)]`, or `$[?(!@.foo)]`. In this cases it's check for existence (non-emptiness of node list).\r\n- Use it in filter as a part of comparison, like `$[?(@.foo == true)]`. Comparison evaluates to `true` only if both of his part exist and provide equal value.\r\n\r\n> ...one of the places where `@.foo` could be used in a context that expects a Boolean value, as is `$[?(@.foo)]`.\r\n\r\nThere are indeed contexts that require casting to boolean, like \"filter root\" or \"logic operator argument\" (but not \"comparison operator argument\"). And node list casts to `false` if it's empty and to `true` otherwise - I see it like this.",
          "createdAt": "2021-09-10T07:05:12Z",
          "updatedAt": "2021-09-10T07:05:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "@remorhaz and what you propose seems to mesh with \"Proposal A\" in the comparison results.\r\n",
          "createdAt": "2021-09-10T07:07:08Z",
          "updatedAt": "2021-09-10T07:07:08Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\r\n> * Use it in filter as a part of comparison, like `$[?(@.foo == true)]`. Comparison evaluates to `true` only if both of his part exist and provide equal value.\r\n\r\nWhat is the semantics of `$[?(@.foo != true)]`?\r\nIs that the same as `$[?(!(@.foo == true))]`?",
          "createdAt": "2021-09-10T07:09:11Z",
          "updatedAt": "2021-09-10T07:09:11Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry @cabo: I was using `@.foo` in the same way as the OP:\r\n\r\n> Currently we have `$[?(@.foo)]` (I'm just going to use `@.foo` for brevity) to represent \"the item is an object and contains a foo property.\" It also seems that some implementations evaluate the truthiness of the value of the foo property, if it exists, while others that accept the syntax interpret it to strictly consider existence.\r\n\r\nI prefer the latter interpretation. To be clearer, I would be happy to see the syntax in the current draft amended to something like:\r\n```\r\nexist-expr   = *neg_op (root-selector / \"@\") 1*(dot-selector / (\"[\" quoted-member-name \"]\"))\r\n```\r\nThus attempts to use other expressions (such as `@` and `$[0]`) as existence tests would be syntactically invalid.",
          "createdAt": "2021-09-10T07:26:26Z",
          "updatedAt": "2021-09-10T07:26:26Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Thus attempts to use other expressions (such as @ and $[0]) as existence tests would be syntactically invalid.\r\n\r\nWhat rationale is behind forbidding to test existance of `$`-based paths? We can have complex filters like this: `$.a[?(@.foo == true and $.b)]` that selects `$.a` elements with `\"foo\": true` or nothing if `$.b` doesn't exist.",
          "createdAt": "2021-09-10T07:41:14Z",
          "updatedAt": "2021-09-10T07:41:14Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue has expanded into more than what was intended.  So let me clarify my intents:\r\n\r\n- By `@.foo` in expressions, I mean to include any path as used in the context of an expression, be it `@.foo`, `@.foo.bar`, `@[0]`, `$.foo`, or any other path.  I'm not asking whether these are valid in the context of an expression.  I would expect from previous conversations and what's in the spec currently that we agree that they are.\r\n- We've also previously discussed that such paths within expressions must return a single value.  This is not up for discussion here.\r\n- I only intend to discuss the usage of a path in an expression when it is not part of an equality or other comparison.  Specifically, when the only operators, if any, that operate on the path are boolean operators (i.e. `!`, `&&`, and `||`).\r\n- The result set is defined in the current incarnation of the spec to be a nodelist.  This was added out of a need to define it separately from any other JSON array, and it really only applies when discussing the theory behind the spec.  Implementations can design their internal mechanisms however they want so long as the output is what is prescribed by the specification.  This is not up for discussion.\r\n\r\nWith that in mind, let's continue the discussion at hand, please.\r\n\r\nI'm asking about considering the results of such expressions as \"truthy.\"  It was my opinion (upon opening the issue) that by considering the result set to be truthy, we restrict our ability to check for strict existence.\r\n\r\nMulling this over for a bit now, I see three options.\r\n\r\n1. Consider paths in expressions as truthy.  This means that we need to define a way to query for strict existence.  We could introduce a function such as `exists(@.foo)` to handle this, but function syntax has been deferred a few times because we haven't defined a sufficient foundation to discuss them.  This seems to also be in line with many existing implementations, though no clear consensus exists.\r\n2. Consider paths in expressions as a strict check for existence.  This means that truthy queries be more complex to include the full intent of truthiness.  This raises questions around what that looks like.  Do we consider `@.foo == true` to be sufficient to express truthiness?  We already decided that `==` and kin don't perform type conversions, so that seems to be off the table.  But that means a user would have to list out all of the \"truthiness\" possibilities.  This gets very messy very quickly, which leads us to the last option.\r\n3. Add a separate operator set for truthy comparisons vs strict comparisons.  This moves us more toward a Javascript operator set instead of the C operator set we've decided on so far.  The nuances of this are less widely known, which means it becomes harder to adopt JSON Path.\r\n\r\nConsidering the implications of these options has led me to believe that the first one is actually most viable.  We just need to define how to specify strict existence.  I rather like the function, but, as I said, we haven't defined them yet.\r\n\r\n---\r\n\r\nAs an alternative to all of this, I would be happy to have the specification require the implementation to provide an option to consider such expressions as either truthy or strict existence, and then define what each means.  This would mean a little more work for implementers, but I am one, and I can tell you that I don't mind.  It's our end users that we need to consider most.",
          "createdAt": "2021-09-10T11:11:36Z",
          "updatedAt": "2021-09-10T11:52:13Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What I was speaking about before was exactly option 2.\r\n\r\n> @remorhaz and what you propose seems to mesh with \"Proposal A\" in the comparison results.\r\n\r\n@cabo, I agree, but sort of this way it was directly defined in first @goessner 's examples:\r\n\r\n```\r\n$..book[?(@.isbn)] : Filter all books with isbn number.\r\n```\r\n\r\n\"Sort of\", because most obvious iterpretation of \"with isbn\" is \"in which isbn property exists\"; there were no details like \"with non-null isbn\" or \"with isbn that evaluates to true\". Of course this can be argued, but at least original implementation and JayWay's interpreted path as existence check.",
          "createdAt": "2021-09-10T12:48:42Z",
          "updatedAt": "2021-09-10T13:03:54Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> * I only intend to discuss the usage of a path in an expression when it is not part of an equality or other comparison.  Specifically, when the only operators, if any, that operate on the path are boolean operators (i.e. `!`, `&&`, and `||`).\r\n\r\nThis was what I meant with \"in a context where a Boolean is expected\".  So we are still talking about implicit conversions of query results to Boolean.\r\n\r\n> 2. Consider paths in expressions as a strict check for existence.  \r\n\r\nThis.\r\n\r\n> This means that truthy queries be more complex to include the full intent of truthiness.  \r\n\r\nYou are presupposing that we need another implicit conversion to Boolean, called \"truthy\".\r\nI haven't seen evidence that we need that.\r\n\r\n> This raises questions around what that looks like.  Do we consider `@.foo == true` to be sufficient to express truthiness?  \r\n\r\nOf course not (`== true` is the exact opposite of \"truthy\").  There is an implicit conversion of a query result to a JSON value involved here that we should discuss separately.\r\n\r\n> We already decided that `==` and kin don't perform type conversions, so that seems to be off the table.  But that means a user would have to list out all of the \"truthiness\" possibilities.  This gets very messy very quickly, which leads us to the last option.\r\n\r\nAgain, where is the evidence that \"truthy\" makes sense?  And which of the many ways of defining it?\r\n\r\n> 3. Add a separate operator set for truthy comparisons vs strict comparisons.  This moves us more toward a Javascript operator set instead of the C operator set we've decided on so far.  The nuances of this are less widely known, which means it becomes harder to adopt JSON Path.\r\n\r\nMore likely, an explicit coercion from a JSON value to a Boolean along the \"truthy\" lines would be indicated.\r\n\r\n`truthy(@.foo)` if we must.\r\nBut leaving this out is better.",
          "createdAt": "2021-09-10T13:05:21Z",
          "updatedAt": "2021-09-10T13:06:33Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I do like Glyn's syntax\r\n```\r\nexist-expr   = *neg_op (root-selector / \"@\") 1*(dot-selector / (\"[\" quoted-member-name \"]\"))\r\n```\r\nIn fact it already includes the root-selector `$`. But considering an argument\r\n```\r\n[ { a:2 } ]\r\n```\r\nwe obviously need to support queries with array element existence checks as in\r\n\r\n`$[?(@.a && $[1])]`\r\n\r\nAnd ... don't we already have, beside those implicit existence tests above, with\r\n\r\n`'foo' in @`\r\n\r\nan explicit existence test instead of inventing an `exist()` function? ",
          "createdAt": "2021-09-10T14:12:33Z",
          "updatedAt": "2021-09-10T14:12:33Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> `@.foo` should always be `true` or `false` and `!@.foo` should always be the negation of `@.foo`.\r\n> \r\n> I would prefer:\r\n> \r\n> * `@.foo` always to denote strict existence of the key `foo` in the object `@` (and be `false` in other cases, e.g. when `@` is not an object).\r\n> * there to be no implicit conversion of values to booleans and therefore no need for the concepts of truthy and falsy in the spec.\r\n\r\nI believe that would be well defined. The only issue with it is that it would be inconsistent with almost all (I added \"almost\" because I haven't studied all of them), so \"almost all\", existing implementations.\r\n\r\nDaniel",
          "createdAt": "2021-09-10T14:41:16Z",
          "updatedAt": "2021-09-10T14:42:08Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "@danielaparker:  So no `@.foo.bar` and no `@.foo == 17`?",
          "createdAt": "2021-09-10T14:47:50Z",
          "updatedAt": "2021-09-10T14:47:50Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So no `@.foo.bar` and no `@.foo == 17`?\r\n\r\nBut why? Because of \"`@.foo` is always boolean\" in @glyn 's phrase?",
          "createdAt": "2021-09-10T14:54:51Z",
          "updatedAt": "2021-09-10T14:54:51Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> @danielaparker: So no `@.foo.bar` and no `@.foo == 17`?\r\n\r\nConsider the JSON document\r\n```\r\n[{\"foo\" : \"baz\"}]\r\n```\r\nGlyn's rule (assuming I've understood it correctly) would imply that\r\n```\r\n$[?(@.bar == false)]\r\n```\r\nwould produce\r\n```\r\n[{\"foo\" : \"baz\"}]\r\n```\r\nI don't know of any extant implementation that does so.",
          "createdAt": "2021-09-10T15:03:42Z",
          "updatedAt": "2021-09-10T15:03:59Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Please note my syntax fragment only applied to `exist-expr` and didn't limit the terms of comparisons etc.",
          "createdAt": "2021-09-10T15:15:30Z",
          "updatedAt": "2021-09-10T15:15:30Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> Please note my syntax fragment only applied to `exist-expr` and didn't limit the terms of comparisons etc.\r\n\r\nBut if the evaluation of `@.bar` by itself should differ from when it appears in a binary expression, that would also be different from \"almost all\" existing implementations. \r\n\r\nI think \"almost all\" existing implementations take one of three approaches to evaluating an object with a missing key:\r\n\r\n- Return a valid JSON value, generally null. Truthiness rules will produce false when testing a single value. The equality operator will evaluate to true when comparing with the JSON value `null`.  \r\n- Return a special non JSON value, in JavaScript this is `undefined` Truthiness rules will produce false when testing a single value. The (strict) equality operator will evaluate to false when comparing with any JSON value. The equality operator will evaluate to true when comparing with the special value itself, e.g. `undefined` in JavaScript. \r\n- Treat a missing property in an object as a runtime type error. Then the question is how the implementation handles the type error. It can get complicated.    \r\n\r\nJayway JsonPath is an example of the third approach, and it handles this type error differently depending on where in the path it occurs. Evaluating `$.bar`, with missing 'bar', it will throw a `PathNotFound` exception with the message \"Missing property in path\". Evaluating `$[?(@.bar || @.foo )]` with missing `bar` and present `foo`, it will branch to some code that ignores the `@.bar` part so that the other parts of the path evaluation can still be examined.  \r\n\r\n",
          "createdAt": "2021-09-10T15:50:28Z",
          "updatedAt": "2021-09-10T18:28:18Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> But if the evaluation of @.bar by itself should differ from when it appears in a binary expression, that would also be different from \"almost all\" existing implementations.\r\n\r\nThanks for the reality check. I don't like truthy and falsey, but it looks like we are stuck with them.",
          "createdAt": "2021-09-10T15:59:36Z",
          "updatedAt": "2021-09-10T15:59:36Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Please remember, that JSONPath is about selecting nodes. In the following cases of non-existence of object member `foo`  we simply do not need to return its value:\r\n\r\n1. `$.foo` ... the resulting node-list is empty.\r\n2. `$.foo.bar` ... the resulting node-list is empty.\r\n3. `$[?(@foo)]` ...  the resulting node-list is empty.\r\n4.  `$[?(!@foo)]` ... current `@` is in the node-list.\r\n\r\nOnly temporary boolean values are needed with boolean expressions\r\n\r\n5.  `$[?(!!@foo)]` ...  the resulting node-list is empty.\r\n6.  `$[?(!@foo || @bar && $.baz)]` ...  the resulting node-list is empty or contains `@`\r\n\r\nBut now with direct comparisons we need to convert its non-existence to a (boolean ?) value.\r\n\r\n7.  `$[?(@foo==false)]` ... the resulting node-list is empty ... regardless of the right side\r\n8.  `$[?(@foo!=false)]` ... hmm ... to be defined.\r\n9. `$[?!(@foo==false)]` ... current `@` is in the node-list.\r\n\r\nBTW: This is, where I like the mental node-list approach. I don't need to specify the selection process result as values or normalized pathes, despite the fact, that it will be one of them.\r\n\r\nA JSON value `undefined` would be of help here ... but since that value in above cases is not exposed to the outer world, it is up to the implementation to represent it internally somehow specifically. This seems to conform to @danielaparker's case 2 above.\r\n\r\nThe spec requires to only treat syntax errors. No 'type not found' message is required or even recommended. It is up to the implementations to handle such cases.",
          "createdAt": "2021-09-10T17:18:20Z",
          "updatedAt": "2021-09-10T17:18:20Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> The spec requires to only treat syntax errors. No 'type not found' message is required or even recommended. It is up to the implementations to handle such cases.\r\n\r\nIt still behooves the specification, for each expression operator, to identify the runtime type errors that may occur, and how the response should be handled. For example, if the ordering operators `<`, `<=`, `>`, and `>=` were specified to be only valid for numbers, as in JMESPath, then other types would entail a type error. Possible responses could be to take out just the element currently being evaluated from the result set (as JMESPath specifies for this case), or to abort evaluation and return an entirely empty collection to the user.  \r\n\r\n",
          "createdAt": "2021-09-10T20:17:37Z",
          "updatedAt": "2021-09-10T20:33:17Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated my library to use strict existence.  You can play with it at [json-everything.net/json-path](https://json-everything.net/json-path).\r\n\r\nHere's an example:\r\n\r\nPath\r\n```\r\n$[?(!@.name || @.name == 'abc')]\r\n```\r\n\r\nData\r\n```json\r\n[\r\n  {\r\n      \"id\": 1,\r\n      \"name\": \"abc\"\r\n  },\r\n  {\r\n      \"id\": 2\r\n  },\r\n  {\r\n      \"id\": 3,\r\n      \"name\": null\r\n  },\r\n  {\r\n      \"id\": 4,\r\n      \"name\": \"def\"\r\n  }\r\n]\r\n```\r\n\r\nResponse\r\n```\r\n[\r\n    {\"id\":1,\"name\":\"abc\"},\r\n    {\"id\":2}\r\n]\r\n```\r\n\r\nNote that the third item (id: 3) is not selected.  If we use truthiness, then this would be selected and there would be no way to select either the second or third item without selecting the other.",
          "createdAt": "2021-09-11T07:51:38Z",
          "updatedAt": "2021-09-11T22:34:49Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Great.  So with Greg's implementation, we now have two different implicit conversions:\r\n\r\n- using the result of a query expression in a Boolean context (?(), !, &&/||): empty node sets \u2794 false, non-empty \u2794 true\r\n- using the result of a query expression in a comparison (and I expect anywhere else): retrieve the value at \"the node\"\r\n\r\nI think we don't have a full grasp of the second alternative.  What if the query expression would have been `$..foo` (and there is more than one node in the nodeset)?\r\nWhat does it mean to compare an empty nodeset to anything?  Do we get `a == b` \u2263 `!( a != b)`?",
          "createdAt": "2021-09-11T08:17:40Z",
          "updatedAt": "2021-09-11T08:17:40Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Meta-comment: Obviously, I'd prefer to get rid of the implicit conversion (e.g., always use something like `exist(@.name)` as an explicit existence test).\r\nBut we want to support current practice here. \r\nI think we need to decide what current practice we can cover and what goes beyond what we can do.\r\nI think Greg's list of\r\n\r\n- [Filter Expression On Object](https://cburgmer.github.io/json-path-comparison/results/filter_expression_on_object.html)\r\n- [Filter Expression Without a Value](https://cburgmer.github.io/json-path-comparison/results/filter_expression_without_value.html)\r\n\r\nand the \"Proposal A\" in there is a very good start.\r\n",
          "createdAt": "2021-09-11T08:22:19Z",
          "updatedAt": "2021-09-11T08:22:19Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't mean for my library to be an indicator of what we should do. I thought it would be good to have something to play around with.  It's still in a 0.* version, so I don't mind changing behavior. I plan on keeping it in line with the spec or experimental based on our discussions.",
          "createdAt": "2021-09-11T09:33:02Z",
          "updatedAt": "2021-09-11T09:33:02Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> If we use truthiness, then this would be selected and there would be no way to select either the second or third item without selecting the other.\r\n\r\n@gregsdennis , On a minor note, the statement \"If we use truthiness, then this would be selected\" is a non sequitur. Whether `{\"id\": 3, \"name\": null}` is selected depends on the rules the language designer chooses for determining whether an expression is `falsey` or `truthy`.  Different languages have adopted different rules. Different JSONPath implementations have adopted different rules, or have inherited them from dynamic languages that they use for evaluating expressions. You can of course have a view about what those rules ought to be. \r\n\r\nIf I understand your main point, you want `@.name` to mean something different than \"evaluate the expression \"@.name\" and then check whether the resulting value may be considered true or false\", as it does generally in dynamic languages such as Javascript. You want it to mean \"does `@` contain `name`\".\r\n\r\nI was interested in the case of document\r\n```\r\n[{\"name\": false}]\r\n```\r\nwith query\r\n```\r\n$[?(@.name)]\r\n```\r\nYour implementation returns\r\n```\r\n{\"name\":false}\r\n```\r\n\r\nI compared with a couple of implementations. Goessner Javascript returns no results, as I'd expect. But surprisingly (to me), Jayway returns the same result as yours. After seeing that, I had to go back and edit and tone down some of my original comments about your main point :-) \r\n\r\nI couldn't find a Christoph Burgmer's comparision that specifically covers this case. But [this one](https://cburgmer.github.io/json-path-comparison/results/filter_expression_without_value.html)  covers the `$[?(!@.name)]` case. This case suggest that six out of 42 implementations (including Jayway) behave the same as your's.  The number may be higher for `$[?(@.name)]`, as many implements can't handle the '!'. I don't agree with that result, because I don't think it's interesting to invent ways of evaluating expressions that are different from our dynamic languages and the textbooks. But it seems that some JSONPath implementations have taken this approach, and it warrants further investigation.\r\n\r\nBest regards,\r\nDaniel\r\n\r\n",
          "createdAt": "2021-09-12T15:48:28Z",
          "updatedAt": "2021-09-12T23:39:38Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you found a bug in my implementation.  I definitely don't intend to select `name : false`.  I'll fix it later tonight and redeploy.",
          "createdAt": "2021-09-12T23:50:49Z",
          "updatedAt": "2021-09-12T23:50:49Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> I think you found a bug in my implementation. I definitely don't intend to select `name : false`. I'll fix it later tonight and redeploy.\r\n\r\nI think that result is consistent with how you've defined what `@.name` means. I expected it. What I didn't expect was that at least six implementations, including the important Jayway, have the same behaviour. I've submitted a pull request to the JSONPath Comparisons to get a more accurate count. ",
          "createdAt": "2021-09-13T00:06:11Z",
          "updatedAt": "2021-09-13T01:21:42Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83e\udd14 Well, that was not my intent.  I wanted `!@.name` to select an item _only_ if `name` doesn't exist.  This means a user would be forced to write `@.name == false` to match your case.\r\n\r\nI guess this is an option we can throw into the mix.  Suppose that we make `@.foo` attempt to return a value such that if the value is missing, it results in an internal \"undefined.\"  Given that concept, we have these three options:\r\n\r\n1. **`@.foo` is fully truthy.**  Evaluation of `@.foo` resulting in \"undefined,\" `null`, `false`, `0`, `\"\"`, `{}, or `[]` doesn't match; any other value does match.\r\n2. **`@.foo` is a pure existence test.**  Evaluation of `@.foo` resulting in \"undefined\" doesn't match; any value at all does match.  (what I intended)\r\n3. **`@.foo` operates as a query.**  Evaluation of `@.foo` resulting in \"undefined\" (because of existence) or `false` (because of boolean) doesn't match; any other value does match.  (what mine currently does)\r\n\r\nThe last option has the added benefit that `@.foo` would always operate as a query, whether it was by itself (e.g. `$[?(@.foo)]`) or part of a comparison (e.g. `$[?(@.foo == 2)]`).  In contrast, the first two options would give `@.foo` different meanings depending upon context.\r\n\r\nHonesly, I think any of these options are reasonable, as long as we define which we mean so that implementations can be consistent.  It wouldn't hurt to have a series of tests around this specific behavior, either.",
          "createdAt": "2021-09-13T04:58:59Z",
          "updatedAt": "2021-09-13T05:16:09Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": ">>>I was interested in the case of document `[{\"name\": false}]` \r\nwith query `$[?(@.name)]`  Your implementation returns `{\"name\":false}`\r\n\r\n> > I definitely don't intend to select `name : false`. \r\n> \r\n> I think that result is consistent with how you've defined what `@.name` means. I expected it. What I didn't expect was that at least six implementations, including the important Jayway, have the same behaviour. I've submitted a pull request to the JSONPath Comparisons to get a more accurate count.\r\n\r\nAnd [here](https://cburgmer.github.io/json-path-comparison/results/filter_expression_without_value.html) we have the results. \r\n\r\nTo summarize: 12 of 42 implementations will return `{\"name\":false}`. These include the Jayway implementation, which is probably second to Goessner as far as importance for JSONPath. Unsurprisingly, they exclude the implementations including Goessner JavaScript that use a \"real\" dynamic language such as JavaScript for evaluating expressions. \r\n\r\nPersonally, I don't agree with the 12, because I don't think it's interesting to invent ad hoc ways of evaluating expressions that are different from our dynamic languages and the textbooks. ",
          "createdAt": "2021-09-13T12:36:40Z",
          "updatedAt": "2021-09-15T02:23:17Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> > But if the evaluation of @.bar by itself should differ from when it appears in a binary expression, that would also be different from \"almost all\" existing implementations.\r\n> \r\n> Thanks for the reality check. I don't like truthy and falsey, but it looks like we are stuck with them.\r\n\r\n@glyn, It appears from [these results](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/119#issuecomment-918148025) that my remark that you're replying to is wrong. In fact 12 of 42 implementations do evaluate `@.bar` by itself differently than when it appears in a binary expression.",
          "createdAt": "2021-09-14T00:06:41Z",
          "updatedAt": "2021-09-15T02:23:49Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "The table below shows the \"falsey\" conditions for each of 42 implementations covered in the JSONPath Comparisons, inferred from [this query](https://cburgmer.github.io/json-path-comparison/results/filter_expression_without_value.html). In this test the selector `$[?(@.key)]` is applied to a JSON array containing an assortment of objects with a single name value pair. Important implementations are labelled in boldface.\r\n\r\nThe column labelled \"n/a\" is checked if the implementation is unable to evaluate `$[?(@.key)]`, or if it returns no results. The column labelled \"Key exists\" is checked if the implementation returns all objects that have a name \"key\". The remaining columns correspond to \"falsey\" conditions on values.\r\n\r\nFifteen implementations are unable to evaluate `$[?(@.key)]`, or return no results. Eleven return all objects that have a name \"key\", regardless of value. One returns all objects that have a name \"key\", unless the value is null. The remaining 15 return results that satisfy \"not false\" conditions on values that range from simple (not false, or neither false or null), to weird (excluding if values are strings or negative numbers).\r\n\r\nTwelve implementations evaluating  `$[?(@.key)]` will select `{\"key\":false}`. Eleven do so because they select all objects that have name \"key\" regardless of value, and one (Clojure) does so because it only refuses values of `null`. \r\n\r\nImplementation|n/a|Key exists|null|false|false, null|false, null, \"\", [], {}|false, null, \"\", [], {}, 0|false, null, string, [], {} , 0|false, null, 0, \"\"|false, null, 0, negative number|false, null, 0, \"\"|false, null, 0, \"\", []|\r\n--------------|-----------|-------|--------------|-------------|--------------------|----------------------------|------------------------------|----------------------------------|------------------------|----------------------------|---------------------------|-------------------------------|\r\nBash (JSONPath.sh)                    |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nC (json-glib)                         |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nDart (json_path)                      |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nElixir (ExJsonPath)                   |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nGolang (github.com-ohler55-ojg)       |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nGolang (github.com-oliveagle-jsonpath)|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nHaskell (jsonpath)                    |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nKotlin (com.nfeld.jsonpathkt)         |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nPython (jsonpath-ng)                  |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nPython (jsonpath-rw)                  |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nRaku (JSON-Path)                      |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nRust (jsonpath)                       |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nPHP (Goessner)                        |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nPerl (JSON-Path)                      |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\ndotNET (JsonPathLib)                  |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nElixir (warpath)                              |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nErlang (ejsonpath)                            |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nGolang (github.com-vmware-labs-yaml-jsonpath) |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nJava (com.github.jsurfer)                     |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\n__Java (com.jayway.jsonpath)__                    |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nObjective-C (SMJJSONPath)                     |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nPHP (remorhaz-jsonpath)                       |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nRust (jsonpath_lib)                           |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nScala (jsonpath)                              |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\n__dotNET (Json.NET)__                             |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\ndotNET (JsonPath.Net)                         |&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nClojure (json-path)                   |&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nPHP (galbar-jsonpath)                         |&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;| \r\ndotNET (Manatee.Json)                         |&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nRuby (jsonpath)                               |&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;| \r\nCpp (jsoncons)                                |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;| \r\ndotNET (JsonCons.JsonPath)                    |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;| \r\nGolang (github.com-spyzhov-ajson)    |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;| \r\nPython (jsonpath)                    |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;| \r\nGolang (github.com-PaesslerAG-jsonpath) |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nGolang (github.com-bhmj-jsonslice)             |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|\r\nGolang (github.com-bhmj-jsonslice)             |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|\r\n__JavaScript (Goessner)__                   |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|    \r\nJavaScript (brunerd)                    |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|\r\nJavaScript (jsonpath)                   |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|\r\nJavaScript (jsonpath-plus)              |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|&nbsp;|\r\nPHP (softcreatr-jsonpath)               |&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|\r\n",
          "createdAt": "2021-09-15T01:36:32Z",
          "updatedAt": "2021-09-15T09:54:48Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "I_kwDOEIqrgc47glav",
      "title": "`regex-expr` and `contain-expr` are missing lhs",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/120",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "While this may be a bit premature as long as we don't know what the rhs of contain-expr should be, it is missing its lhs.\r\n\r\n```\r\ncontain-expr = in-op container\r\nin-op        = \" in \"                                 ; in operator\r\n```\r\n\r\n*What* is in the container?",
      "createdAt": "2021-09-16T16:20:13Z",
      "updatedAt": "2021-11-02T12:42:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Oh, and the same with `regex-expr`:\r\n\r\n```\r\nregex-expr   = regex-op regex\r\n```\r\n",
          "createdAt": "2021-09-16T16:21:59Z",
          "updatedAt": "2021-09-16T16:21:59Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Well ... good point. Starting with these examples:\r\n```\r\n@.color in [\"red\",\"green\",\"blue\"]\r\n@.color in $.colors\r\n$.color in @.colors\r\n\"color\" in @.colors\r\n\"color\" in @\r\n@.index in [2,4,7]\r\n@.index in $.indices\r\n$.index in @.indices\r\n42 in @.indices\r\n42 in @\r\n```\r\n* lhs is restricted to a primitive value (possibly only number and string). lhs holding a complex value will fail, i.e. no selection occurs.\r\n* rhs must be resolved to a complex value (array or object).  rhs holding a simple value will fail, i.e. no selection occurs.\r\n\r\nGiven this we have something like this ...\r\n```\r\ncontain-expr = (rel-path-val / json-path / number / string-literal) in-op container\r\ncontainer =  (rel-path-val / json-path / array-literal)\r\n```\r\n... as a starting proposal.\r\n",
          "createdAt": "2021-09-17T08:57:19Z",
          "updatedAt": "2021-09-17T08:57:19Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "(From 2012-09-17 interim:)\r\nSo we would have syntax for array literals composed of primitive values only (subset of JSON array literals); other JSON array literals cause a syntax error.  (Empty array literals should be allowed to simplify code generation.)\r\nA LHS evaluating to a complex value would not match.\r\nThe path on the RHS may also yield an array, we would match against every single element of that like we would match against a literal array.\r\nExample: `\"color\" in @.colors`\r\n\r\ntending towards consensus on:\r\n`@.color in $.colors`\r\nif $.colors is an array of structured values, @.color is a single structured value?\r\n\u2794 only match primitive values from the LHS (counterintuitive!?)\r\n`@.color` = [128, 255, 17] \u2794 no selection \r\neven if `$.color` = [[128, 255, 17], [1, 2, 3]]\r\n(we cannot avoid structured data to turn up in a query, but we don't match)\r\nAvoid deep equals!  (We already avoid it in simple comparisons.)\r\n",
          "createdAt": "2021-09-17T10:03:24Z",
          "updatedAt": "2021-09-17T10:06:20Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "Reminder: lhs of `regex-op` ...\r\n\r\nFrom\r\n```\r\nregex-expr   =   regex-op regex\r\n```\r\nto\r\n```\r\nregex-expr   = rel-path / json-path /                 ; path to string value\r\n                      string-literal\r\n                      regex-op regex\r\n```\r\nas a proposal.\r\n",
          "createdAt": "2021-11-02T12:42:17Z",
          "updatedAt": "2021-11-02T12:42:17Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "I_kwDOEIqrgc47gmVw",
      "title": "blank space in ABNF",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/121",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "task"
      ],
      "body": "From the document:\r\n\r\n> Task (T1): This, besides slice-index, is currently one of only two\r\n> places in the document that mentions whitespace.  Whitespace needs\r\n> to be handled throughout the ABNF syntax.  Room Consensus at the\r\n> 2021-06-15 interim was that JSONPath generally is generous with\r\n> allowing insignificant whitespace throughout.  Minimizing the impact\r\n> of the many whitespace insertion points by choosing a rule name such\r\n> as \"S\" was mentioned.  Some conventions will probably help with\r\n> minimizing the number of places where S needs to be inserted.\r\n\r\n(whitespace is now generally called blank space, but that doesn't change the work to be done.)\r\n",
      "createdAt": "2021-09-16T16:24:38Z",
      "updatedAt": "2021-11-09T20:50:53Z",
      "closedAt": "2021-11-09T20:50:53Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed by #131 and #132 ",
          "createdAt": "2021-11-09T20:50:52Z",
          "updatedAt": "2021-11-09T20:50:52Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "I_kwDOEIqrgc47jjwk",
      "title": "Nodeslists on RHS of in-op",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/122",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "(Spin-off from #120:)\r\n\r\nDiscuss:\r\n`@.color in $..allowed_color`\r\nWe make sure that the paths on the LHS only yield a single node; the paths on the RHS may yield multiple nodes and the nodelist is examined like a JSON array would be.\r\n\\[How do we distinguish these cases?]\r\n\u2794 disallow paths that can yield multiple nodes on the in-op RHS as well.",
      "createdAt": "2021-09-17T10:04:11Z",
      "updatedAt": "2021-11-11T05:18:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "well ... treating a nodelist as an array, may lead after resolving to something like ...\r\n\r\n```\r\n'red' in [[\"red\",\"green\"],[\"red\",\"blue\"]]\r\n```\r\nSince lhs value is tested to be contained in the rhs array ... no deep search is done ... result is `false`.",
          "createdAt": "2021-11-10T09:36:42Z",
          "updatedAt": "2021-11-10T09:36:42Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I'd rather say that the nodelist is a nodelist, and an array is a (JSON) array.  So \"in\" could have different semantics, e.g., by returning the disjunction of matching the values of the nodes.",
          "createdAt": "2021-11-10T11:07:37Z",
          "updatedAt": "2021-11-10T11:07:37Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> So \"in\" could have different semantics\r\n\r\nIn what scenarios would you want to treat a nodelist different than an array?\r\n\r\nI tend to agree with the opening comment.",
          "createdAt": "2021-11-11T05:18:44Z",
          "updatedAt": "2021-11-11T05:18:44Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "I_kwDOEIqrgc47jost",
      "title": "Is absent equal to absent?",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/123",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "If yes,\r\n\r\n`@.doesnotexist != @.alsodoesnotexist` \r\n\r\nis false.\r\n\r\nNeed to discuss impact on >, >=, etc.\r\n\r\nSee also:\r\nhttps://notes.ietf.org/notes-ietf-interim-2021-jsonpath-03-jsonpath",
      "createdAt": "2021-09-17T10:26:28Z",
      "updatedAt": "2021-09-27T00:28:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cburgmer",
          "authorAssociation": "NONE",
          "body": "I've extended the query which compares two paths via equals to include absent keys: https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_equals_with_path_and_path.html. No consensus, not even a majority at this point.",
          "createdAt": "2021-09-17T14:03:05Z",
          "updatedAt": "2021-09-17T14:03:05Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "... which is not necessarily a problem: I gives us more leeway to nail down something sane (if we want to).\r\n",
          "createdAt": "2021-09-17T14:26:17Z",
          "updatedAt": "2021-09-17T14:26:17Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... with JavaScript ...\r\n```js\r\nconst o = {};\r\no.a === o.b;  // true\r\n```\r\ndue to ` undefined === undefined`.",
          "createdAt": "2021-09-20T14:16:18Z",
          "updatedAt": "2021-09-20T14:16:18Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> I've extended the query which compares two paths via equals to include absent keys: https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_equals_with_path_and_path.html. No consensus, not even a majority at this point.\r\n\r\nIsolating the empty key behavior, I think the results are consistent with what we understand about the implementations. By my count, 12 implementations select the `{}` item. It depends on whether the implementation returns a value (such as `undefined`) for an absent key, or whether it handles it as a recoverable error. The Javascript ones that return `undefined` for an absent key select `{}`, as would be expected. Jayway, which handles an absent key as a recoverable error that takes out the term, does not select `{}`, again as expected.     \r\n\r\n~~None select `{\"key1\": null}` or `{\"key2\": null}`~~. I think it would be interesting to add `{\"key1\": false}` to the document. \r\n",
          "createdAt": "2021-09-24T11:16:58Z",
          "updatedAt": "2021-09-24T20:14:11Z"
        },
        {
          "author": "cburgmer",
          "authorAssociation": "NONE",
          "body": "> I think it would be interesting to add {\"key1\": false} to the document.\r\n\r\nDone :)",
          "createdAt": "2021-09-24T18:32:07Z",
          "updatedAt": "2021-09-24T18:32:07Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I would like to add here, just to ensure that it's documented, that C# recently added `x is {}` as an expression equivalent to `x != null`.\n\nTherefore returning `{}` could be quite confusing for some users.",
          "createdAt": "2021-09-24T21:18:41Z",
          "updatedAt": "2021-09-24T21:18:41Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "> > I think it would be interesting to add {\"key1\": false} to the document.\r\n> \r\n> Done :)\r\n\r\nOkay, from the data (checked cells correspond to selected values), it appears that twelve of 42 implementations consider absent is equal to absent (column 2), while one, PHP (galbar-jsonpath), considers `false` is equal to absent (column 5), and absent to `false` (column 6),  but not absent to absent (column 2).\r\n\r\nThe ones that consider absent is equal to absent do so for different reasons. Cpp (jsoncons) and dotNET (JsonCons.JsonPath)\r\nevaluate absent to be `null`, and `null` is equal to `null`. The JavaScript implementations evaluate absent to be `undefined`,\r\nand `undefined`  is equal to `undefined`. Three of the JavaScript implementations also show `null` equal to `absent` and `absent` equal to `null`, no doubt because of conversion when comparing `undefined` and `null`.\r\n\r\nImplementation              |{}         |{\"key1\" : null}|{\"key2\" : null}|{\"key1\" : false}|{\"key2\" : false}|\r\n----------------------------|-----------|---------------|---------------|----------------|----------------|\r\nClojure (json-path)         |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|&nbsp;|<em>&#x2713;</em>|\r\nCpp (jsoncons)              |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|&nbsp;|&nbsp;|\r\ndotNET (JsonCons.JsonPath)  |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|&nbsp;|&nbsp;|\r\ndotNET (JsonPathLib)        |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\ndotNET (Manatee.Json)       |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nElixir (warpath)            |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|&nbsp;|&nbsp;|\r\nErlang (ejsonpath)          |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nJavaScript (brunerd)        |<em>&#x2713;</em>|&nbsp;|&nbsp;|&nbsp;|&nbsp;|\r\nJavaScript (Goessner)       |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|&nbsp;|&nbsp;|\r\nJavaScript (jsonpath)       |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|&nbsp;|&nbsp;|\r\nJavaScript (jsonpath-plus)  |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|&nbsp;|&nbsp;|\r\nRuby (jsonpath)             |<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|<em>&#x2713;</em>|\r\nPHP (galbar-jsonpath)       |&nbsp;|&nbsp;|&nbsp;|<em>&#x2713;</em>|<em>&#x2713;</em>|\r\n\r\nWe can deduce that the remaining 30 of 42 implementations do _not_ consider absent equal to absent. Again, the reasons vary. \r\n\r\n15 implementations either fail or return an empty collection. While there is more going on in this test than \"absent equal to absent\", the number 15 lines up with the number in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/119#issuecomment-919628694 that fail when attempting to evaluate an absent member. So for these, it looks like absent is always an unrecoverable error.\r\n\r\nWhen Jayway evaluates `$[?(@.key1==@.key2)]` with absent `key1` and absent `key2`, it considers the first absence a recoverable error, and it will branch to some code that ignores this comparison, so this comparison selects nothing. That applies to all comparators,  `<`, `>`, `>=`, `<=`.\r\n\r\n",
          "createdAt": "2021-09-24T21:20:52Z",
          "updatedAt": "2021-09-27T00:28:43Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "I_kwDOEIqrgc48ceo5",
      "title": "JsonInclude Processing Extension",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/124",
      "state": "OPEN",
      "author": "greenbergjosh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "I have added, what I will call, JsonInclude support to the the json-everything library.  At Greg's suggestion, I am opening this issue to see if there is interest in the community to create a formal spec for this functionality (which I will explain below).  I am also happy to share the code with anyone who is interested.\r\n\r\nThe fundamental goal for JsonInclude is to allow one json document to point to others such that a JsonPath expression can seamlessly jump between documents.\r\n\r\nFor example, consider a server hosting a number of Json documents.  For illustration, imagine the server running at http://example.com, and exposing documents by integer key, such as http://example.com/10, which will return the Json document with key 10.\r\n\r\nNow, consider a document, http://example.com/10 with the contents:\r\n{ \"a\": { \"b\": \"@@http://example.com/11\" } }\r\nAnd, a second document, http://example.com/11 with the contents:\r\n{ \"c\": { \"d\": \"Hello\" } }\r\n\r\nGiven the following code:\r\n\r\nusing var instance = await JsonDocument.ParseAsync(await httpClient.GetStreamAsync(\r\n\t\t\t\t\"http://example.com/10\"));\r\nvar path = JsonPath.Parse(\"$.a.b.c.d\");\r\nvar results = path.Evaluate(instance.RootElement);\r\n\r\nThe results variable will contain the PathMatch for \"Hello\".\r\n\r\nThis is, of course, the simplest example.  At present, my implementation supports the following functionality.\r\n1. Caching.  Once a remote document is loaded, it will not be loaded again.\r\n2. Arbitrary user-defined resolvers.  At present, there are implementations for the following resolvers:\r\n   a. @@http pointing to root\r\n   b. @@http pointing to fragment using JsonPointer\r\n   c. @@http pointing to array of fragments using JsonPath\r\n   d. $ref= pointing to root\r\n   e. $ref= pointing to fragment using JsonPointer\r\n   f.  $ref= pointing to array of fragments using JsonPath\r\n   g. Additional resolvers can be added at will\r\n   h. Arbitrary user-defined retrievers to actually go and get the remote document. Presently, I have only implemented an http/s \r\n       retriever, but one could easily envision a retriever that gets the document from a database.\r\n\r\nAs an example of a different resolver, consider the JsonSchema style { \"$ref\": \"http://example.com/11\" }.  If we wanted to use this style resolver, our two example documents would appear as:\r\n\r\n/10:   { \"a\": { \"b\": {\"$ref\": \"@@http://example.com/11\" } } }\r\n\r\n/11:   { \"c\": { \"d\": \"Hello\" } }\r\n\r\nIn general, the code allows the user to easily define and register new resolvers with five or ten lines of code.  Registration of a new resolver looks like this:\r\n\r\nJsonPathInclude.Resolvers.Add((match) => (match.Value.ValueKind == JsonValueKind.String && match.Value.GetString().StartsWith(\"@@http://\")),\t(match, idx) => JsonPathInclude.StringRootResolver(match, idx));\r\n\r\nThe above code will resolve pointers to remote documents that are specified as string properties prefixed with @@.  Alternatively, or simultaneously, since one can register as many resolvers as desired, we can register a resolver for the $ref case.\r\n\r\nJsonPathInclude.Resolvers.Add((match) => match.Value.ValueKind == JsonValueKind.Object && match.Value.HasProperty(\"ref$\"),\r\n\t\t\t\t(match, idx) => JsonPathInclude.RefRootResolver(match, idx));\r\n\r\nIn addition to pointing to a remote document at its root, the code also supports using JsonPointer and JsonPath.  \r\n\r\nFor example, @@http://localhost:8002/11#/c points to the document /11, but chooses to include only the contents pointed to by the JsonPointer(\"/c\").\r\n\r\nLikewise, @@http://localhost:8002/11#$.c.d3[*], points to /11, but uses the JsonPath(\"$.c.d3[*]\") to find every matching node in /11 (not shown in the shortened example document above) and include those nodes as an array under the node in /10 containing this reference.  In this way, a document can reference any JsonPath addressable subset of nodes in any other document.  And, as always, a JsonPath expression will seamlessly jump across to that subset of nodes in the referenced document.\r\n\r\nIn summary, JsonInclude supports\r\n1. Seamless references between Json documents beneath technologies like JsonPath, thereby allowing JsonPath expressions to extend across a graph/network of related documents.  All features of JsonPath are supported - the JsonInclude library works below the level of JsonPath.\r\n2. Arbitrary user defined resolvers can be added so the format of the references can be anything the user chooses.  For example, I have shown all references as URLs, however, they could easily be nothing more than a UUID, which the resolver could convert to a URL or to any other string that the retriever can use to access the remote document.\r\n3. Arbitrary user defined retrievers\r\n4. Ability to point not only to a remote document root, but also to a specific node using JsonPointer, or to a specific subset of nodes using JsonPath.\r\n\r\nIf my explanation is unclear in any way, please let me know.  I hope others might find this feature to be useful and, if so, it would certainly be great to ultimately see it become a standard and find it's way into the json-everything library.  Regardless, if anyone would like the code, I would be happy to oblige.\r\n\r\nKind Regards.\r\n",
      "createdAt": "2021-10-02T16:22:26Z",
      "updatedAt": "2021-11-09T20:50:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for posting this @greenbergjosh!  I'd like to take this from a perspective of the feature as is pertains to JSON Path in general, excluding anything specific within my implementation.\r\n\r\nI really like this idea, and @greenbergjosh did some great work modifying my library to implement it.  I requested that he post this here as an example of a potential extension that has more to do with processing JSON data than it does the JSON Path syntax.\r\n\r\nFor this to work, no changes need to be made to the JSON Path syntax itself.  The magic is in node selection.\r\n\r\n### A minor correction\r\n\r\nThe `@@http` syntax was the initial proposal.  It was merely a string that could be replaced with the contents of the document to which the URI pointed.  It would be embedded in a JSON value like so:\r\n\r\n```json\r\n{\r\n  \"foo\": \"@@http://example.com/data\"\r\n}\r\n```\r\n\r\nThe selector would see the `@@` followed by a URI and recognize it as a reference to additional data.  It would locate said data and replace the `@@` string with the data and continue selection.\r\n\r\nI had proposed the \"object with a `$ref`\" syntax as an alternative based on how JSON Schema manages references.  I had intended for that to be a replacement to the `@@` key, but I don't think I was clear.  My opinion is that this feature should follow in step with JSON Schema and just have `{ \"$ref\": \"http://...\" }` be the indicator to fetch the specified data and continue selection.  The above example would then be modified to:\r\n\r\n```json\r\n{\r\n  \"foo\": { \"$ref\": \"http://example.com/data\" }\r\n}\r\n```\r\n\r\nIt's a bit more verbose, but because of that, it's also more explicit.\r\n\r\nOne interesting aspect of this solution is that the selector can be a bit smarter as well.  If the path contains `$ref`, then the selector just takes the value without dereferencing. so `$.foo['$ref']` would actually yield the URI `http://example.com/data`.\r\n\r\n(The really cool thing about doing this is interoperability with JSON Schema.  You could select nodes from a JSON Schema while dereferencing its built in references!)\r\n\r\n### Further notes on resolution\r\n\r\nIn supporting this reference mechanic, the JSON Schema spec contains language that specifically states that implementations are not required to fetch the data.  The values of `$ref` are actually URIs, not URLs.  The idea is that the implementation is not required to make network calls or look on the file system; it can instead have additional documents preloaded with URIs.  I think this is an important aspect that should be copied/borrowed.",
          "createdAt": "2021-10-02T22:45:40Z",
          "updatedAt": "2021-10-02T22:45:40Z"
        },
        {
          "author": "greenbergjosh",
          "authorAssociation": "NONE",
          "body": "It is likely worth mentioning the idea of cycle detection. I have not yet added this to my implementation, but it might be worth considering. I don\u2019t think all cycles are necessarily bad. Consider, parent.child[0].parents[*].name, which we might consider as returning the names of both parents of a child, having started from one parent. To avoid confusion, I am speaking of human parents and children in this example. Clearly, there is a cycle, but the result is still useful. For this reason, it might make sense to specify a max revisit count. As I see Greg focused here more on specification than implementation, I will comment that this may be an implementation detail.\r\n\r\nIt might make sense to consider a distinction between implicit and explicit cycles. For example, if I do $.a..f I may hit an include cycle and I have not explicitly requested it, so it would be implicit. On the other hand, if I do $.a.b.a.c, I have explicitly requested it, and it is clearly finite. So, perhaps one could allow explicit cycles but disallow implicit cycles that exceed some specified length. ",
          "createdAt": "2021-10-03T12:56:56Z",
          "updatedAt": "2021-10-03T13:07:23Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I've added this as an experimental option on https://json-everything.net/json-path.\r\n\r\nUsing the path\r\n\r\n```\r\n$..description\r\n```\r\n\r\non\r\n\r\n```json\r\n{\"$ref\": \"https://raw.githubusercontent.com/json-schema-org/JSON-Schema-Test-Suite/master/tests/draft6/const.json\"}\r\n```\r\n\r\nyields all of the descriptions from that file in the JSON Schema Test Suite.",
          "createdAt": "2021-10-05T22:21:50Z",
          "updatedAt": "2021-10-05T22:22:07Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks interesting, but what about authorization - where do we put user credentials or tokens? Into some external config?",
          "createdAt": "2021-10-06T11:31:54Z",
          "updatedAt": "2021-10-06T11:31:54Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Those are good questions, and they should be considered if we decide to add this to the spec.\n\nFor my experimental implementation, the referenced documents need to be publicly available on the network where the processor is running.",
          "createdAt": "2021-10-06T21:08:50Z",
          "updatedAt": "2021-10-06T22:14:24Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOEIqrgc49tRKh",
      "title": "Need to do blank space cleanup",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/126",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "task"
      ],
      "body": "- [ ] define a production `S`, replacing `ws`\r\n- [ ] go through ABNF and make sure blank space is allowed where it needs to be\r\n\r\n(Do not use the term \"whitespace\" any more.)\r\n\r\n* Task \"T1\" in the document\r\n* https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/125/files#r721614839\r\n",
      "createdAt": "2021-10-25T15:27:03Z",
      "updatedAt": "2021-11-09T20:50:00Z",
      "closedAt": "2021-11-09T20:49:59Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Closed by #131 and #132",
          "createdAt": "2021-11-09T20:49:59Z",
          "updatedAt": "2021-11-09T20:49:59Z"
        }
      ]
    },
    {
      "number": 127,
      "id": "I_kwDOEIqrgc49teMQ",
      "title": "Should we provide for structured types in containable?",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/127",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/125#discussion_r721614374",
      "createdAt": "2021-10-25T16:19:37Z",
      "updatedAt": "2021-11-03T09:02:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking a while about comparing structured types, I now see no problem to support equality of  them. I agree to handling them is straightforward:\r\n\r\n> Two structured types are equal, if they are equal on a per-node basis. \r\n\r\nalso see [The Abstract Equality Comparison Algorithm](https://262.ecma-international.org/5.1/#sec-11.9.3) ... not exactly, what we want though.\r\n\r\nWe need to be clear about order ... !\r\n```\r\n[1,2] == [1,2]\r\n{x:1,y:2} == {x:1,y:2}\r\n[1,2] == [2,1]  // ?\r\n{x:1,y:2} == {y:2,x:1} // ?\r\n[] == []\r\n{} == {}\r\n```\r\nContainables may be defined on exactly that comparison rule. \r\n\r\nI believe, we need to add objects here again.  Also we need to discuss subsets.\r\n\r\n### Array Examples:\r\n```\r\n1 in [1,2,3]             // primitive value lhs\r\n[1,2] in [1,2,3]         // structured value lhs\r\n[1,2] in [1,2,3,[1,2]] // subset\r\n[] in [1,2,3]             // empty array\r\n[] in [1,2,3,[]]          // empty array\r\n{} in [1,2,3,{}]          // empty object\r\n{x:1,y:2} in [{x:1,y:2}]\r\n```\r\n### Object Examples:\r\n```\r\n'x' in {x:1,y:2}\r\n['x','y'] in {x:1,y:2}\r\n{x:1} in {x:1,y:2}\r\n{z:3,x:1} in {x:1,y:2,z:3}\r\n{} in  {x:1,y:2}\r\n```\r\n\r\nOnce having agreement about handling that edge cases (maybe there are more), we might add it to the spec. \r\n\r\nBtw.: JavaScript resolves all comparisons above to `false`, since objects are equal only, if they are referencing the same object (no deep equals).",
          "createdAt": "2021-11-02T11:48:02Z",
          "updatedAt": "2021-11-02T11:48:02Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments inline.\n\nOn Tue, 2 Nov 2021 at 11:48, Stefan Goessner ***@***.***>\nwrote:\n\n> After thinking a while about comparing structured types, I now see no\n> problem to support equality of them. I agree to handling them is\n> straightforward:\n>\n> Two structured types are equal, if they are equal on a per-node basis.\n>\n> also see The Abstract Equality Comparison Algorithm\n> <https://262.ecma-international.org/5.1/#sec-11.9.3> ... not exactly,\n> what we want though.\n>\n> We need to be clear about order ... !\n>\n> [1,2] == [1,2]\n> {x:1,y:2} == {x:1,y:2}\n> [1,2] == [2,1]  // ?\n>\n> No. Arrays are ordered and equality tests should respect that ordering.\n\n>\n> {x:1,y:2} == {y:2,x:1} // ?\n>\n> Yes. Objects are unordered and equality tests should respect that lack of\nordering.\n\n>\n> [] == []\n> {} == {}\n>\n> Containables may be defined on exactly that comparison rule.\n>\n> I believe, we need to add objects here again. Also we need to discuss\n> subsets.\n> Array Examples:\n>\n> 1 in [1,2,3]             // primitive value lhs\n> [1,2] in [1,2,3]         // structured value lhs\n>\n> No. Conflating membership and subset violates the principle of least\nsurprise and so is likely to cause confusion. Also I am not aware of any\nprecedent for such conflation in mathematics or programming language\nsemantics.\n\n>\n> [1,2] in [1,2,3,[1,2]] // subset\n>\n> This doesn't add any value beyond the previous case. Better to discuss:\n\n[1,2] in [[1,2]] // structured value membership\n\nAlso, we need to discuss ordering of arrays. For example:\n\n[1,2] in [[2,1]]\n\nshould be false, if we agree that [1,2] != [2,1].\n\n>\n> [] in [1,2,3]             // empty array\n> [] in [1,2,3,[]]          // empty array\n> {} in [1,2,3,{}]          // empty object\n> {x:1,y:2} in [{x:1,y:2}]\n>\n> Object Examples:\n\nI don't think we should conflate membership and subset. Since \"in\" has a\nstronger connotation of membership than subset, I don't think we can easily\ndefine \"in\" with an object on the right hand side. Note also that there\nisn't yet a notation for a mathematical \"maplet\", but if we represented it\nas a pair, e.g. ('x',1), then we could test membership of objects thus:\n\n('x',1) in {x:1}\n\n(However, I don't think this is worth the cost of increased complexity of\nthe spec.)\n\n> 'x' in {x:1,y:2}\n> ['x','y'] in {x:1,y:2}\n> {x:1} in {x:1,y:2}\n> {z:3,x:1} in {x:1,y:2,z:3}\n> {} in  {x:1,y:2}\n>\n> Once having agreement about handling that edge cases (maybe there are\n> more), we might add it to the spec.\n>\n> Btw.: JavaScript resolves all comparisons above to false, since objects\n> are equal only, if they are referencing the same object (no deep equals).\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/127#issuecomment-957364968>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAXF2J2TDFR5P3LGOZ4QH3UJ7FX3ANCNFSM5GVV2MMA>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-11-03T08:27:57Z",
          "updatedAt": "2021-11-03T08:27:57Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I totally support a decision to:\r\n* not dealing with subsets\r\n* restrict the rhs to arrays only\r\n\r\nwith contain-expr's.\r\n",
          "createdAt": "2021-11-03T09:02:04Z",
          "updatedAt": "2021-11-03T09:02:04Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "I_kwDOEIqrgc4-kexi",
      "title": "In-line examples",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/136",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Apart from an appendix with examples, let's have in-line examples",
      "createdAt": "2021-11-10T12:14:59Z",
      "updatedAt": "2021-11-10T12:14:59Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ0NzI1Mzg2",
      "title": "fix headers",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/1",
      "state": "MERGED",
      "author": "morrme",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In case you still need this ! :wave: ",
      "createdAt": "2020-07-06T11:52:51Z",
      "updatedAt": "2020-07-06T12:22:55Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "b4902b38acbbd2bb9e7b3f1418ab614a384381d8",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "f604af8fe10924c3e6c49090279fb85534384576",
      "closedAt": "2020-07-06T12:22:54Z",
      "mergedAt": "2020-07-06T12:22:54Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "177f7816469d04f087918d8403fc5e73b8c084a0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMDI2MTYw",
          "commit": {
            "abbreviatedOid": "f604af8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, assuming this works!",
          "createdAt": "2020-07-06T12:22:47Z",
          "updatedAt": "2020-07-06T12:22:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODM1MDY0",
      "title": "Start to define syntax and semantics",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/4",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "Start to define syntax and semantics. This only goes as far as `$` but sets the scene for other subpaths to be added.\r\n\r\nAdd temporary warning about this not being ready for publication.\r\n\r\nAlso add a utility for generating HTML and text files from XML and for checking the XML and ABNF.\r\n\r\n",
      "createdAt": "2020-07-06T15:05:55Z",
      "updatedAt": "2020-07-09T10:24:02Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "177f7816469d04f087918d8403fc5e73b8c084a0",
      "headRepository": "glyn/internet-draft",
      "headRefName": "root",
      "headRefOid": "4273a1a72a158f50ec412a1a6feb1c1d7844ee8b",
      "closedAt": "2020-07-09T10:23:57Z",
      "mergedAt": "2020-07-09T10:23:57Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "76171157cd5b9ebd92f64a686532ffe25f203e83"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I've thought of some clarifications and other things that should be said initially, so changed this PR to draft while I work on it some more. I'd also like to be able to motivate things better to address the kinds of question that @remorhaz raised.",
          "createdAt": "2020-07-07T09:51:52Z",
          "updatedAt": "2020-07-07T09:51:52Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@remorhaz I've done some rework and aligned the syntax (such as it is) more closely with Proposal A. I've also started to talk about implementations. Please could you take a look and provide feedback. If it's helpful, here's a [rendered HTML version](https://glyn.github.io/internet-draft/).",
          "createdAt": "2020-07-07T16:00:03Z",
          "updatedAt": "2020-07-07T16:00:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMTg2OTE5",
          "commit": {
            "abbreviatedOid": "00dec08"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-06T15:34:21Z",
          "updatedAt": "2020-07-06T15:34:22Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "> A JSONPath is abstractly a sequence of matchers.\r\n\r\nThings getting not that simple if we support subpaths and/or nested filters, and we have [a consensus](https://cburgmer.github.io/json-path-comparison/results/filter_expression_with_subpaths.html) here.",
              "createdAt": "2020-07-06T15:34:22Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMTg4NzI5",
          "commit": {
            "abbreviatedOid": "00dec08"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-06T15:36:34Z",
          "updatedAt": "2020-07-06T15:36:34Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> correspondds\r\n\r\nA typo.",
              "createdAt": "2020-07-06T15:36:34Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMTkzNTc1",
          "commit": {
            "abbreviatedOid": "00dec08"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-06T15:42:23Z",
          "updatedAt": "2020-07-06T15:42:23Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@remorhaz I'm not sure I follow. If we take that example `$[?(@.address.city=='Berlin')]`, that will break down into two matchers:\r\n* `$` which matches the root document\r\n*  `[?(@.address.city=='Berlin')]` which filters the array to pick out the \"Berlin\" element.\r\n\r\nSome of the matchers will be defined in terms of others, but even so each JSONPath will correspond to a sequence of \"top-level\" matchers.",
              "createdAt": "2020-07-06T15:42:23Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMTk1ODY1",
          "commit": {
            "abbreviatedOid": "51ed857"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-06T15:45:04Z",
          "updatedAt": "2020-07-06T15:45:04Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Fixed, thanks.",
              "createdAt": "2020-07-06T15:45:04Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMjQxNjA3",
          "commit": {
            "abbreviatedOid": "51ed857"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-06T16:42:16Z",
          "updatedAt": "2020-07-06T16:42:16Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Well, if we don't speak about \"inner\" matchers here, then I agree with the definition.",
              "createdAt": "2020-07-06T16:42:16Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjAyMDU0",
          "commit": {
            "abbreviatedOid": "d13a5ac"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T10:09:55Z",
          "updatedAt": "2020-07-08T10:09:55Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "> when the list of matching nodes comprises a single node\r\n\r\nThis approach can cause many troubles, I think.\r\n\r\nLook, there are two cases:\r\n1. Query is able to match zero or one node. It is an _attribute_ of a query, and it can be calculated using just query text, without any JSON data: all matchers in chain should match one or zero nodes (like `.foo`) to tag query as \"single-matching\".\r\n2. Query is able to match arbitrary amount of nodes. It's an attribute of a query, too, and it's enough to have a single \"multi-matching\" matcher (like `*`) in chain to tag all the query as \"multi-matching\".\r\n\r\nBut on some JSON data multi-matching query will match exactly one node, which makes it possible to behave like single-matching query 1; I mean, node list with a single node can be reduced to a single node.\r\n\r\nQuery attributes can be used for analysis by client software to ensure that given query is garanteed to match either exactly one either none of nodes. Making the type of returned data dependent on input is dangerous and complicated: well, okay, we've got an array here - is this a single node that is an array or is this a list of matched nodes? I see no way to distinguish.\r\n\r\nI suggest not to mix \"naturally single-matching queries\" with \"occasionally single-matching queries\".",
              "createdAt": "2020-07-08T10:09:55Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjMwNTM1",
          "commit": {
            "abbreviatedOid": "d13a5ac"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T10:53:15Z",
          "updatedAt": "2020-07-08T10:53:15Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Intersting. Let's analyse this a bit. The nub of the problem seems to be:\r\n> Making the type of returned data dependent on input is dangerous and complicated: well, okay, we've got an array here - is this a single node that is an array or is this a list of matched nodes? I see no way to distinguish.\r\n\r\nThe output type isn't data (JSONPath or input document) dependent _for a given implementation_, but it would be implementation dependent.\r\n\r\nLet's look at both implementation options.\r\n\r\nFirstly, the preferred (SHOULD) approach of always returning a list of nodes or error. We can overlook the error case as that's unambiguous. If a single node matched, then the output would be a list comprising that node. There is no ambiguity. The \"outermost\" list always represents the fact the implementation is returning a list of nodes.\r\n\r\nSecondly, the non-preferred \"scalar\" approach of always returning a scalar or error. If a single node matched which contains a scalar value, that value is returned. Again, I don't think there is any ambiguity.\r\n",
              "createdAt": "2020-07-08T10:53:15Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODI4MDc5",
          "commit": {
            "abbreviatedOid": "d13a5ac"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T14:33:14Z",
          "updatedAt": "2020-07-08T14:33:14Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "But how should \"the non-preferred _scalar_ approach\" behave if query matches several nodes on concrete data? If it falls back on \"preferred approach\", the result can be ambiguous. If it doesn't, we should define the behavior better: it can return first node from list, or return an error, or whatever.",
              "createdAt": "2020-07-08T14:33:14Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODQyMTk5",
          "commit": {
            "abbreviatedOid": "d13a5ac"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T14:47:52Z",
          "updatedAt": "2020-07-08T14:47:53Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Ah, I missed the point: you want to allow \"single\" mode only for scalar values. That indeed removes ambiguity. But in the same time, the non-preferred approach still seems very wierd:\r\n\r\n- `$.foo` on `{\"foo\":\"bar\"}` returns `\"bar\"`.\r\n- `$.foo` on `{\"foo\":[\"bar\",\"baz\"]}` returns `[[\"bar\",\"baz\"]]` - isn't it weird? Or it should produce an error?\r\n\r\nWhat do you think about replacing \"non-preferred approach\" with optional _reduce_ operation on \"preferred approach\" results?",
              "createdAt": "2020-07-08T14:47:52Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODgwNjIy",
          "commit": {
            "abbreviatedOid": "d13a5ac"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:27:12Z",
          "updatedAt": "2020-07-08T15:27:12Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "> Ah, I missed the point: you want to allow \"single\" mode only for scalar values. That indeed removes ambiguity. But in the same time, the non-preferred approach still seems very wierd:\r\n> \r\n> * `$.foo` on `{\"foo\":\"bar\"}` returns `\"bar\"`.\r\n\r\nCorrect.\r\n\r\n> * `$.foo` on `{\"foo\":[\"bar\",\"baz\"]}` returns `[[\"bar\",\"baz\"]]` - isn't it weird? Or it should produce an error?\r\n\r\nIt should return an error since `[[\"bar\",\"baz\"]]` isn't a \"list of matching nodes comprises a single node whose value is [a] scalar value\".\r\n\r\n> \r\n> What do you think about replacing \"non-preferred approach\" with optional _reduce_ operation on \"preferred approach\" results?\r\n\r\nI like the idea of framing the behaviour in terms of _reduce_, but I'm not sure that would provide the \"escape route\" that I was aiming for. You see I don't personally think the non-preferred approach is a good option, but I suggest it so that implementations which behave this way today could become spec compliant without necessarily completely breaking all their users.\r\n\r\nIn fact, I put up the current non-preferred approach as a strawman for discussion and I'd be interested in others' opinions (@cburgmer, @gregsdennis, @Cleidiano, and other potential reviewers).\r\n\r\nAnother, more radical option, would be to drop the non-preferred approach altogether and leave it to implementations to define their behaviour _in terms of the standard_ should they choose to do so.\r\n\r\nAnother intermediate option would be to add some non-normative text explaining how to return a scalar in terms of the standard behaviour. I quite like that approach as it would at least help \"scalar implementations\" to adopt a similar approach.\r\n\r\nAvoiding a normative definition of scalar implementations would also get us out of the difficulty of covering that use case in a future compliance test suite.\r\n\r\n",
              "createdAt": "2020-07-08T15:27:12Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTE3Mzkw",
          "commit": {
            "abbreviatedOid": "d13a5ac"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T16:07:52Z",
          "updatedAt": "2020-07-08T16:07:52Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "> I like the idea of framing the behaviour in terms of reduce, but I'm not sure that would provide the \"escape route\" that I was aiming for.\r\n\r\nWell, it's a big question if existing implementations conform to this \"escape route\", anyway. Just try execute `$.store` [here](https://jsonpath.herokuapp.com/) on Goessner's example - and you'll get a single JSON object. Execute `$.store.book` - and get a single array (exactly what I've meant by \"ambiguous\"). As for me, I'd vote for the most radical option of dropping the non-preferred approach.\r\n\r\nReduction is a needful operation on practice, though: there are tons of cases when we may want to convert result to exactly one node or error. But I'm not sure if we should bother about such an operation in this document: given a list of nodes there's no problem to implement this behavior even if some implementation doesn't provide it out of box.",
              "createdAt": "2020-07-08T16:07:52Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTE5MjMy",
          "commit": {
            "abbreviatedOid": "d13a5ac"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T16:10:03Z",
          "updatedAt": "2020-07-08T16:10:03Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I agree. So let's drop it for now and add some _non-normative_ text later if there's any pressure to do so. I'll force push in a few minutes...",
              "createdAt": "2020-07-08T16:10:03Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTM5OTg3",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T16:33:21Z",
          "updatedAt": "2020-07-08T16:33:22Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "> MAY return an error or MAY return an empty list of matches\r\n\r\nWhat is the rationale behind letting the implementation to decide?",
              "createdAt": "2020-07-08T16:33:22Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTQ0Mzgz",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T16:39:04Z",
          "updatedAt": "2020-07-08T16:39:05Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "> matches the root node\r\n\r\nIf `$` is a matcher, then it can appear at any position in chain, `$[1]$`, for example. Maybe it's better to define `$` and `@` as _selectors_ and a JsonPath query as selector, followed by matchers sequence (possibly empty)?",
              "createdAt": "2020-07-08T16:39:05Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTQ4MzMz",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T16:44:16Z",
          "updatedAt": "2020-07-08T16:44:16Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I had in mind implementations, like my own, with an API consisting of:\r\n* a constructor function which takes a JSONPath string and returns a rich JSONPath type or a syntax error. This gets syntax errors out of the way \"early\" (i.e. before any JSON documents are encountered) and allows \"compilation\" of the JSONPath to be performed once before the compiled version is used, possibly many times, to search JSON documents.\r\n* a method on the JSONPath type which takes a _parsed_ form of a JSON document and which returns the search results or an error.\r\n\r\nBut you've identified a mistake there. Such implementations will _never_ encounter a syntactically invalid JSON document, so they needn't worry about how to handle syntax errors.\r\n\r\nSo I'm now leaning towards a stricter requirement:\r\n> If a syntactically invalid JSON document is provided, an implementation MUST return an error.\r\n\r\nWDYT?",
              "createdAt": "2020-07-08T16:44:16Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTUwNDU4",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T16:47:06Z",
          "updatedAt": "2020-07-08T16:47:06Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Yes, I was trying to avoid describing `$` as a matcher for the reason you point out. I guess saying that `$` _matches_ the root node gives the impression that `$` is a matcher (regardless of what the ABNF might say). Can you think of a better wording? If not, I'll try again...",
              "createdAt": "2020-07-08T16:47:06Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTUyODY0",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T16:50:10Z",
          "updatedAt": "2020-07-08T16:50:10Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "> Maybe it's better to define `$` and `@` as _selectors_ and a JsonPath query as selector, followed by matchers sequence (possibly empty)?\r\n\r\nI was trying to stick pretty closely to the Proposal A grammar. Also, we need to prevent `@` at the start of a JSONPatth. But your point is well made and will come in useful once we get to filters. Do we really need to do more right now?",
              "createdAt": "2020-07-08T16:50:10Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTYyNjEy",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T17:02:52Z",
          "updatedAt": "2020-07-08T17:02:52Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Yes, I think that's better.",
              "createdAt": "2020-07-08T17:02:52Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTY3NzAx",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T17:09:01Z",
          "updatedAt": "2020-07-08T17:09:02Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "> we need to prevent @ at the start of a JSONPath\r\n\r\nIn fact, we do not. Semantic of `@` is \"current node\", and current node at the start of JsonPath is obviously a root node, so there's no practical reason to avoid `@` at start.\r\n\r\nBut it's, I'd say, a brave movement and should be discussed more thoroughly. For now, I believe, it's enough to choose between \"sequence of matchers\" and \"selector followed by optional sequence of matchers\".",
              "createdAt": "2020-07-08T17:09:01Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDMwMjUx",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T09:10:04Z",
          "updatedAt": "2020-07-09T09:10:04Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Ok. I'm now wondering how strict to be about checking the JSON document syntax because it's not really the prime responsibility of a JSONPath implementation. In particular, I don't want to over-burden JSONPath implementations in languages which happen to have imperfect JSON parsing libraries. So how about we weaken the wording to:\r\n> If a syntactically invalid JSON document is provided, any implementation SHOULD return an error.\r\n\r\n?",
              "createdAt": "2020-07-09T09:10:04Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDMyNTk0",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T09:13:19Z",
          "updatedAt": "2020-07-09T09:13:20Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I'd like us to adopt an approach for the first version of the internet draft of avoiding new constructs whenever possible as that will increase the migration cost for existing implementations and users. So I think in this PR we should stick with `$` followed by a possibly empty sequence of matchers. I'll reword the above text to avoid calling `$` a matcher and use the \"selector\" terminology instead, which we can then piggy-back upon nicely when we come to filters. Let me draft that and push the change for your perusal.",
              "createdAt": "2020-07-09T09:13:19Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDQ1MDMx",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T09:29:10Z",
          "updatedAt": "2020-07-09T09:29:11Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Well, in fact many implementations will work without JSON text itself, using the result of JSON parsing as a structure; or even without JSON at all (yaml, for example). XML has DOM, that allows to isolate document structure from text source (and syntax); JSON lacks such tool.\r\n\r\nMaybe we should just define JSON data structure as a tree in terms of typed and (partially) ordered nodes, thus totally isolating JsonPath from JSON parsing issues; but for now SHOULD is fairly enough.",
              "createdAt": "2020-07-09T09:29:11Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDUzMTM0",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T09:39:52Z",
          "updatedAt": "2020-07-09T09:39:53Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "> avoiding new constructs whenever possible\r\n\r\nThat's not a problem - we can define selectors with the following grammar:\r\n\r\n```\r\nselector       = root_selector / other_selector\r\nroot_selector  = \"$\"\r\nother_selector = \"@\"\r\n```\r\n\r\nAnd then define queries like this, avoiding:\r\n\r\n```\r\nroot_path   = root_selector [ matcher_list ]\r\nfilter_path = selector [ matcher_list ]\r\n```\r\n\r\nIt's not the concrete grammar proposal, just showing an idea how to forbid `@` at the start of outer path.",
              "createdAt": "2020-07-09T09:39:52Z",
              "updatedAt": "2020-07-09T10:21:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDUzNjAz",
          "commit": {
            "abbreviatedOid": "fe247ec"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-09T09:40:30Z",
          "updatedAt": "2020-07-09T09:40:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1NDg2MjQ4",
          "commit": {
            "abbreviatedOid": "4273a1a"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T10:23:45Z",
          "updatedAt": "2020-07-09T10:23:46Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Thanks @remorhaz. I've used just what we need of this for the moment. I adopted the convention from the ABNF RFC of spelling compound grammar elements using \"-\" rather than \"_\".",
              "createdAt": "2020-07-09T10:23:46Z",
              "updatedAt": "2020-07-09T10:23:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2ODc1NjEy",
      "title": "dot child matcher",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/5",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "See [rendered HTML](https://glyn.github.io/internet-draft/) for ease of reading.\r\n\r\n@remorhaz: following on from the discussion in https://github.com/cburgmer/json-path-comparison/issues/42, would you care to take a crack at the grammar for `dot-child-name`? If you are up for this, please send a PR to https://github.com/glyn/internet-draft/tree/dot-child.",
      "createdAt": "2020-07-09T13:53:29Z",
      "updatedAt": "2020-07-28T10:23:08Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "a71a792ee9d594642fbeb1cee2fc9d7a0f2d899a",
      "headRepository": "glyn/internet-draft",
      "headRefName": "dot-child",
      "headRefOid": "3b19db008cd940f57f9565e9d05048045c9c1819",
      "closedAt": "2020-07-17T10:20:30Z",
      "mergedAt": "2020-07-17T10:20:30Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "efdd44b71b9cfb7abadf76bd6212266a2bea2c0b"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging complete with placeholder so that other work can be submitted as PRs.",
          "createdAt": "2020-07-17T10:20:24Z",
          "updatedAt": "2020-07-17T10:20:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQzODAw",
          "commit": {
            "abbreviatedOid": "3b19db0"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-17T10:19:30Z",
          "updatedAt": "2020-07-17T10:19:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4MjY5NDQ2",
      "title": "Minor README updates",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/6",
      "state": "MERGED",
      "author": "PeterEltgroth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@glyn Minor README updates to speed up setup for those marginally familiar with python and who haven't done C in years, like me. \r\n\r\nFor whatever reason, GitHub is not allowing me to tag a Reviewer.",
      "createdAt": "2020-07-13T13:49:19Z",
      "updatedAt": "2020-07-13T14:19:28Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "76171157cd5b9ebd92f64a686532ffe25f203e83",
      "headRepository": "PeterEltgroth/internet-draft",
      "headRefName": "master",
      "headRefOid": "1ee7b962fe08afb6d607ba74d9686ab5d6d2c283",
      "closedAt": "2020-07-13T14:19:28Z",
      "mergedAt": "2020-07-13T14:19:28Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "8c2617711387732d8304b43fc47eb725cc585249"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Mjk1NDA1",
          "commit": {
            "abbreviatedOid": "1ee7b96"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @PeterEltgroth! Definitely less cryptic now.",
          "createdAt": "2020-07-13T14:19:22Z",
          "updatedAt": "2020-07-13T14:19:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4MzQwMzg5",
      "title": "Tidy and improve README",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/7",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-13T15:47:27Z",
      "updatedAt": "2020-07-28T10:23:17Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "8c2617711387732d8304b43fc47eb725cc585249",
      "headRepository": "glyn/internet-draft",
      "headRefName": "tidy-README",
      "headRefOid": "8d95b32a0b10467f42aa2b4ffcaf0c1e9a7be74b",
      "closedAt": "2020-07-14T09:18:36Z",
      "mergedAt": "2020-07-14T09:18:36Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "a71a792ee9d594642fbeb1cee2fc9d7a0f2d899a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTQ5Njgy",
          "commit": {
            "abbreviatedOid": "8d95b32"
          },
          "author": "PeterEltgroth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T19:46:38Z",
          "updatedAt": "2020-07-13T19:46:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUxMDA0NzI5",
      "title": "union child and index matchers",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/10",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "Also define encoding of paths.\r\n\r\nAlso use JSON Path instead of JSONPath.\r\n\r\nSee [rendered HTML](https://glyn.github.io/internet-draft/) for ease of reading.",
      "createdAt": "2020-07-17T10:26:51Z",
      "updatedAt": "2020-07-28T10:24:10Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "efdd44b71b9cfb7abadf76bd6212266a2bea2c0b",
      "headRepository": "glyn/internet-draft",
      "headRefName": "union-child",
      "headRefOid": "62f9e727767bda26144bc9b58a0146a7fb6ada2b",
      "closedAt": "2020-07-28T10:20:45Z",
      "mergedAt": "2020-07-28T10:20:45Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "1cbdb234e56fbb839e156dad10e67b4da686d894"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDk1NTIx",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "Cleidiano",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-19T03:23:25Z",
          "updatedAt": "2020-07-19T03:23:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzAwNTgw",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T17:58:35Z",
          "updatedAt": "2020-07-21T17:58:36Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "> by at least one of the union\r\n\r\nIt is a question if union should \"merge\" union results or \"concatenate\" the results. We [have a consensus](https://cburgmer.github.io/json-path-comparison/results/union_with_numbers_in_decreasing_order.html) for reverse ordered indexes, that shows us that we should define the order of merge/concatenation; but the situation of fetching the same index twice (like `$[1,1]`) is still not investigated.\r\n\r\nBut this question can be discussed later.",
              "createdAt": "2020-07-21T17:58:35Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzA2NTA1",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T18:06:26Z",
          "updatedAt": "2020-07-21T18:06:26Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Maybe this one should refer to JSON string definition as of [RFC 8259.7](https://tools.ietf.org/html/rfc8259#section-7)? Otherwise we can get duplicated non-terminals if we allow JSON structures in filters.\r\n\r\nBut it's a complex question and probably should be discussed separately.",
              "createdAt": "2020-07-21T18:06:26Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzA3MzAz",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T18:07:26Z",
          "updatedAt": "2020-07-21T18:07:27Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Probably slash omitted after `5B`?",
              "createdAt": "2020-07-21T18:07:26Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzA4ODc0",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T18:09:37Z",
          "updatedAt": "2020-07-21T18:09:37Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "Probably \"as described\"?",
              "createdAt": "2020-07-21T18:09:37Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzEyNjg0",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T18:14:49Z",
          "updatedAt": "2020-07-21T18:14:50Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Maybe it's better to fully describe the unescaping process at the beginning of the section without splitting it with matching description? So that at first we describe how do we _get_ the key and then - how we _use_ the key.",
              "createdAt": "2020-07-21T18:14:49Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzE0ODE5",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T18:17:38Z",
          "updatedAt": "2020-07-21T18:17:39Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "Once again, maybe it's better to refer to JSON standard that [defines](https://tools.ietf.org/html/rfc8259#section-6) `int` non-terminal?",
              "createdAt": "2020-07-21T18:17:39Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzE5MTg4",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T18:23:10Z",
          "updatedAt": "2020-07-21T18:23:10Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "Maybe we should avoid defining index at all and rather consider it as a special case of a slice (when onbly start index is given)?",
              "createdAt": "2020-07-21T18:23:10Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzE5OTE0",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-21T18:24:08Z",
          "updatedAt": "2020-07-21T18:24:08Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "> It does not match\r\n\r\nMaybe `it MUST not match`?",
              "createdAt": "2020-07-21T18:24:08Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzIwNjIw",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-21T18:25:09Z",
          "updatedAt": "2020-07-21T18:25:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MDMwNDE5",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T11:07:29Z",
          "updatedAt": "2020-07-23T11:07:29Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "@remorhaz I suggest you raise an issue on this so we don't forget it.",
              "createdAt": "2020-07-23T11:07:29Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Mjc4ODM4",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T15:58:56Z",
          "updatedAt": "2020-07-23T15:58:56Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Nice catch.",
              "createdAt": "2020-07-23T15:58:56Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjgxNzAy",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T16:02:14Z",
          "updatedAt": "2020-07-23T16:02:14Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Actually, I'm inclined to switch to RFC 8259 syntax for strings for consistency alone. But I think we need to allow for single-quoted as well as double-quoted strings, for example like this:\r\n```\r\nunion-child = %x22 *double-quoted %x22 / ; \"string\"\r\n              %x27 *single-quoted %x27   ; 'string'\r\n\r\ndouble-quoted = dq-unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n\r\n      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF\r\n\r\nsingle-quoted = sq-unescaped /\r\n          escape (\r\n              %x27 /          ; '    apostrophe      U+0027\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF\r\n\r\nescape = %x5C                 ; \\\r\n```\r\n@cburgmer this is the first time we would be deviating from the syntax in Proposal A. WDYT?",
              "createdAt": "2020-07-23T16:02:14Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjgzMjI3",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T16:04:01Z",
          "updatedAt": "2020-07-23T16:04:02Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "Yes.",
              "createdAt": "2020-07-23T16:04:02Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Mjg4NjYy",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T16:10:40Z",
          "updatedAt": "2020-07-23T16:10:40Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Good idea.",
              "createdAt": "2020-07-23T16:10:40Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjkwNDI1",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T16:12:52Z",
          "updatedAt": "2020-07-23T16:12:52Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "Agreed, although I think the syntaxes are equivalent in this case.",
              "createdAt": "2020-07-23T16:12:52Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Mjk4MTkw",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T16:22:30Z",
          "updatedAt": "2020-07-23T16:22:30Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "I wanted to follow Proposal A and keep the grammar productions for index and slice separate because that approach neatly avoids some the issues by distinguishing between union elements which can select multiple elements and those which can select at most one element. But we may be able to organise the document to keep these definitions close to each other.",
              "createdAt": "2020-07-23T16:22:30Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Mjk4NzMy",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T16:23:12Z",
          "updatedAt": "2020-07-23T16:23:12Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Probably. I haven't been consistent in applying MUST etc. and it would certainly be an improvement.",
              "createdAt": "2020-07-23T16:23:12Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTY4Nzcy",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-24T15:11:59Z",
          "updatedAt": "2020-07-24T15:12:00Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "> I think we need to allow for single-quoted as well as double-quoted strings\r\n\r\nOf course, but that can be done like this:\r\n```\r\nunion-child = %x27 *single-quoted %x27 /  ; 'string'\r\n              json-string ; see RFC blah-blah-blah\r\n```\r\nI mean, JSON string already includes double-quotes in its definition.",
              "createdAt": "2020-07-24T15:11:59Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1OTEzNzAx",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T15:52:48Z",
          "updatedAt": "2020-07-27T15:52:49Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "I think it would be better to keep the ABNF self-contained:\r\n- It's easier to read without jumping over to another RFC. (We could make the production names the same if that helps and have a comment \"copied from RFC nnnn\")\r\n- I'd like our text to be immutable, but the ABNF in another RFC could mutate because of errata (which we wouldn't _necessarily_ want to adopt, at least not without our own errata)\r\n- it should be possible to extract the ABNF and generate a lexer/parser from it.",
              "createdAt": "2020-07-27T15:52:49Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1OTQzNzcz",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T16:28:45Z",
          "updatedAt": "2020-07-27T16:28:45Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "@cabo Have you any general advice about whether it is best to inline or refer to ABNF from existing RFCs?",
              "createdAt": "2020-07-27T16:28:45Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1OTU0MDY4",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T16:42:13Z",
          "updatedAt": "2020-07-27T16:42:13Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Funny, I just answered the same question on a different list :-)\r\n\r\nGenerally, right now, it is better to copy, because there is no actionable way to refer.\r\nUntil that get's unwieldy, so if you need the date-time production from RFC 3339, that carries so much baggage you'd better refer.\r\n\r\nWe are solving the same problem for CDDL right now in the CBOR WG, so maybe we'll have something that will spill over to ABNF as wel.  For now, copy over refer, I'd say.",
              "createdAt": "2020-07-27T16:42:13Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NDkzMzQy",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-28T10:12:26Z",
          "updatedAt": "2020-07-28T10:12:27Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "I'm going to stick with the copy of the ABNF and also preserve the symmetry between single and double quoted strings as I think that's a lot more readable.",
              "createdAt": "2020-07-28T10:12:26Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NDk2NDY4",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-28T10:17:16Z",
          "updatedAt": "2020-07-28T10:17:16Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "I'm going to fix this in a later PR by making a pass through the the whole document.",
              "createdAt": "2020-07-28T10:17:16Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NDk3OTAy",
          "commit": {
            "abbreviatedOid": "8c306fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-28T10:19:31Z",
          "updatedAt": "2020-07-28T10:19:31Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "Actually, I've decided not to change this because the JSON standard doesn't provide a suitable signed integer production. We can revisit this when float literals make their appearance.",
              "createdAt": "2020-07-28T10:19:31Z",
              "updatedAt": "2020-07-28T10:20:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU3NzIxODAz",
      "title": "union slices",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/11",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "See the [rendered HTML](https://glyn.github.io/internet-draft/) version of this PR.",
      "createdAt": "2020-07-28T10:34:50Z",
      "updatedAt": "2020-09-23T15:00:57Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "919345a34eea31f11fc8fd7c944e5b726a1f5da4",
      "headRepository": "glyn/internet-draft",
      "headRefName": "union-slice",
      "headRefOid": "9cc1a7a9d472e7163a20a558c32882261cb38b69",
      "closedAt": "2020-09-23T15:00:51Z",
      "mergedAt": "2020-09-23T15:00:51Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "e1d86466d2dea14682fbded0e3f94637b18d07c1"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo fyi I still need to make an editorial pass to use the terms MUST, SHOULD, etc. consistently. But you may care to skim read this version to get a feel for where we are at.",
          "createdAt": "2020-07-28T16:58:35Z",
          "updatedAt": "2020-07-28T16:58:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2ODcxNTM0",
          "commit": {
            "abbreviatedOid": "4a6806e"
          },
          "author": "jchesterpivotal",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-28T17:51:14Z",
          "updatedAt": "2020-07-28T17:58:01Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I suggest breaking this into two sentences. \"A syntactically valid matcher MUST NOT produce errors. This means that some operations which might be considered erroneous, such as indexing beyond the end of an array, result in fewer descendants being selected\".",
              "createdAt": "2020-07-28T17:51:15Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            },
            {
              "originalPosition": 63,
              "body": "I found this difficult to follow. Perhaps something like \"Array access is a union element which matches zero or more elements of an array node.\"",
              "createdAt": "2020-07-28T17:54:38Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            },
            {
              "originalPosition": 120,
              "body": "Same comment as above, this is a little difficult for me to follow.",
              "createdAt": "2020-07-28T17:55:36Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            },
            {
              "originalPosition": 122,
              "body": "Should \"does not match a node which is not an array\" appear at the top of the section with the introduction about Array Access?",
              "createdAt": "2020-07-28T17:56:13Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDE0MzQw",
          "commit": {
            "abbreviatedOid": "4a6806e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T11:00:42Z",
          "updatedAt": "2020-07-29T11:00:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yes, I like that thanks.",
              "createdAt": "2020-07-29T11:00:42Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDM0Mjk2",
          "commit": {
            "abbreviatedOid": "4a6806e"
          },
          "author": "Cleidiano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T11:33:35Z",
          "updatedAt": "2020-07-29T11:33:35Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Expression like `$[0, 1]` will not be included in the spec?",
              "createdAt": "2020-07-29T11:33:35Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDM1MjU5",
          "commit": {
            "abbreviatedOid": "4a6806e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T11:35:05Z",
          "updatedAt": "2020-07-29T11:35:06Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "I'm using the terminology of a matcher _matching_ a node and then _selecting_ subnodes. There's a clear distinction for example with \"dot child\" where the key matches the key in an object but the matcher selects the value subnode. In the array case, we can probably get away with shortening this. Let's see how that pans out.",
              "createdAt": "2020-07-29T11:35:06Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDM3NTEw",
          "commit": {
            "abbreviatedOid": "4a6806e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T11:38:27Z",
          "updatedAt": "2020-07-29T11:38:28Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Yes. I was trying to avoid duplication in the syntax and semantics section, but I think it reads better with a bit of repetition.\r\n\r\nWhen my wife was a maths teacher, she used to tell me \"You only learn by repetition. You only learn by repetition.\"",
              "createdAt": "2020-07-29T11:38:27Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDQwMTE5",
          "commit": {
            "abbreviatedOid": "4a6806e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T11:42:19Z",
          "updatedAt": "2020-07-29T11:42:19Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "Tried a rewording. See what you think.",
              "createdAt": "2020-07-29T11:42:19Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDQxNTM4",
          "commit": {
            "abbreviatedOid": "4a6806e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T11:44:40Z",
          "updatedAt": "2020-07-29T11:44:40Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Yes it will. According to the syntax definition `[0, 1]` is a union of two array accesses.",
              "createdAt": "2020-07-29T11:44:40Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDgzNTk0",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "Cleidiano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T12:45:39Z",
          "updatedAt": "2020-07-29T12:45:40Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Oh, my fault,  index access is a type of union element, sorry.",
              "createdAt": "2020-07-29T12:45:40Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NTA2Mjgw",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T13:12:52Z",
          "updatedAt": "2020-07-29T13:12:53Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "No problem. If others make the same mistake, we may need to think about how to address that in the document.\r\n\r\n(I am trying to avoid adding numerous examples, which might be one fix, as that can weaken a standards document because less attention is paid to the normative text, by both readers and authors.)",
              "createdAt": "2020-07-29T13:12:53Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDQ1Mzk5",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:57:39Z",
          "updatedAt": "2020-09-23T08:57:39Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "> zero or more descendants of the node\r\n\r\nAre we sure we're not going to allow nodes from input list to get included in the output list (like `descendant-or-self::` axis in XPath)?",
              "createdAt": "2020-09-23T08:57:39Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDUzMzQy",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T09:07:09Z",
          "updatedAt": "2020-09-23T09:07:10Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Ah, I think you missed the following in the Terminology section 2.2:\r\n> The descendants of a node are taken to include the node itself and the descendants of any children of the node.",
              "createdAt": "2020-09-23T09:07:09Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDU1NTYw",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T09:09:56Z",
          "updatedAt": "2020-09-23T09:09:56Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Maybe we should define the last element of array as `{\"c\":2}` - just to demonstrate how non-matching node is filtered out?",
              "createdAt": "2020-09-23T09:09:56Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDc0NzYx",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T09:33:11Z",
          "updatedAt": "2020-09-23T09:33:11Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "> result is the concatenation\r\n\r\nI think we should explicitly define here (or somewhere else) what happens when concatenated lists contain same node (we have unions, so it's absolutely possible).",
              "createdAt": "2020-09-23T09:33:11Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDg5MTc5",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T09:51:18Z",
          "updatedAt": "2020-09-23T09:51:18Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "> it MUST be non-zero\r\n\r\nI'm not sure if we should make zero step illegal; maybe it's better to define that array-slice with zero step just matches nothing? I don't feel that this situation is worth complicationg syntax / throwing a syntax error; it's just like selecting an index out of range - so why we would want to especially handle this situation?\r\n\r\nAnother argument is query templates: user may use something like `sprintf(\"$.a[%d:%d:%d]\", x, y, z)` and it may be quite surprising to get syntax errors on zero `z` and not getting it on any other value.",
              "createdAt": "2020-09-23T09:51:18Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NTQ4MDUx",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T11:12:30Z",
          "updatedAt": "2020-09-23T11:12:31Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Yep. But in this case it seems that the term \"descendant\" doesn't fit very well. What would you think about replacing it with \"branch\"?",
              "createdAt": "2020-09-23T11:12:30Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjUwMjM3",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:19:21Z",
          "updatedAt": "2020-09-23T13:19:22Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I don't follow why \"descendant\" doesn't fit well. Please could you elaborate?\r\n\r\n(\"branch\" seems like a strange term, unless you have a particular definition in mind.)",
              "createdAt": "2020-09-23T13:19:21Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjYwODk3",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:30:03Z",
          "updatedAt": "2020-09-23T13:30:03Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I mean, when I say \"descendant\" I usually mean direct or indirect child of a node, but not the node itself. I'm not a native English-speaker and thus I may be wrong, but I don't feel that node can be \"a descendant of itself\". XPath also separates \"descendant-or-self\" from \"descendant\" semantically.\r\n\r\nBranch is, of course, not a good variant too.",
              "createdAt": "2020-09-23T13:30:03Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjYwOTUz",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:30:06Z",
          "updatedAt": "2020-09-23T13:30:06Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Yes: changed to allow zero.",
              "createdAt": "2020-09-23T13:30:06Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjY1NTM4",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:34:46Z",
          "updatedAt": "2020-09-23T13:34:47Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Added.",
              "createdAt": "2020-09-23T13:34:46Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjY5NzI0",
          "commit": {
            "abbreviatedOid": "9163d2b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:38:50Z",
          "updatedAt": "2020-09-23T13:38:50Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I'll add a placeholder for now. Do you happen to know if there's a consensus on this?",
              "createdAt": "2020-09-23T13:38:50Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0Njc3MTYx",
          "commit": {
            "abbreviatedOid": "865e89e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:46:01Z",
          "updatedAt": "2020-09-23T13:46:02Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Yes, I take your point. It's too risky to redefine the normal meaning of descendant as people could miss, or forget, the redefinition. I'll try rewording this.",
              "createdAt": "2020-09-23T13:46:02Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjgxMjE1",
          "commit": {
            "abbreviatedOid": "29f9c6d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:49:54Z",
          "updatedAt": "2020-09-23T13:49:54Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Done. See what you think.",
              "createdAt": "2020-09-23T13:49:54Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NzMzMDk1",
          "commit": {
            "abbreviatedOid": "29f9c6d"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-23T14:38:42Z",
          "updatedAt": "2020-09-23T14:52:21Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "In fact, there are three lists concatenated: two of length one and one of length zero.",
              "createdAt": "2020-09-23T14:39:37Z",
              "updatedAt": "2020-09-23T14:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NzU2ODkw",
          "commit": {
            "abbreviatedOid": "9cc1a7a"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T15:00:42Z",
          "updatedAt": "2020-09-23T15:00:42Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Good catch. Fixed.",
              "createdAt": "2020-09-23T15:00:42Z",
              "updatedAt": "2020-09-23T15:00:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4Mjk1MTUx",
      "title": "Mention IETF mailing list in README",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/12",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-29T08:57:16Z",
      "updatedAt": "2020-07-29T10:05:53Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "1cbdb234e56fbb839e156dad10e67b4da686d894",
      "headRepository": "glyn/internet-draft",
      "headRefName": "ietf",
      "headRefOid": "a19ab30fe1f6a680d30b9f1494be17cee72970ee",
      "closedAt": "2020-07-29T10:05:53Z",
      "mergedAt": "2020-07-29T10:05:53Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "7ec665ade81558219f09e05781ce1e6ead5b287e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MzM4MjMz",
          "commit": {
            "abbreviatedOid": "a19ab30"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-29T09:12:31Z",
          "updatedAt": "2020-07-29T09:12:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1MTg0NTY3",
      "title": "Define dot child name",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/13",
      "state": "MERGED",
      "author": "remorhaz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-09T18:17:30Z",
      "updatedAt": "2020-09-24T15:27:38Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "7ec665ade81558219f09e05781ce1e6ead5b287e",
      "headRepository": "remorhaz/internet-draft",
      "headRefName": "dot-child-name",
      "headRefOid": "3e922b5b0fbbb7b9a7995d5c26a440e510c1cca3",
      "closedAt": "2020-09-23T11:36:36Z",
      "mergedAt": "2020-09-23T11:36:36Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "7dfd5b3c1ee58b559c46ac768099bcab7d28ad1c"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@remorhaz I'm soon away until 14 Sept. after which it would be great to be able to merge this. Would you have some time to apply those changes?",
          "createdAt": "2020-09-02T13:36:58Z",
          "updatedAt": "2020-09-02T13:36:58Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, in a couple of days.",
          "createdAt": "2020-09-02T14:30:52Z",
          "updatedAt": "2020-09-02T14:30:52Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Related: #15 ",
          "createdAt": "2020-09-21T09:55:34Z",
          "updatedAt": "2020-09-21T09:55:34Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@glyn, I think we can finally merge this PR.",
          "createdAt": "2020-09-22T16:37:49Z",
          "updatedAt": "2020-09-22T16:37:58Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> @glyn, I think we can finally merge this PR.\r\n\r\nThanks. I'll take a look in the next couple of days.",
          "createdAt": "2020-09-22T16:39:05Z",
          "updatedAt": "2020-09-22T16:39:05Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@remorhaz When I run scripts/gen.sh or scripts/docker-gen.sh I get some additional changes to the generated HTML. I'm running xml2rfc v3.1.1 on macOS. Did you forget to regenerate or are our versions of xml2rfc behaving differently?",
          "createdAt": "2020-09-23T09:36:36Z",
          "updatedAt": "2020-09-23T09:36:36Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Did you forget to regenerate?\r\n\r\nHmm, I don't think so. I've added an `author` element recently (after all other changes were made) and I see it in target .txt, so the regeneration seems to have been performed.\r\n\r\n>  or are our versions of xml2rfc behaving differently?\r\n\r\nMaybe, but in dockerfile I just did the same actions that were defined in readme, so that's wierd. What are the changes exactly?\r\n\r\n",
          "createdAt": "2020-09-23T09:59:01Z",
          "updatedAt": "2020-09-23T09:59:01Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> > or are our versions of xml2rfc behaving differently?\r\n> \r\n> Maybe, but in dockerfile I just did the same actions that were defined in readme, so that's wierd. What are the changes exactly?\r\n\r\nSee https://github.com/jsonpath-standard/internet-draft/commit/2816a2ce6512c34fb7bca6e50c1c64775f57f6ee. This change implies you are on an old version of xml2rfc:\r\n```\r\n-<meta content=\"xml2rfc 2.47.0\" name=\"generator\">\r\n+<meta content=\"xml2rfc 3.1.1\" name=\"generator\">\r\n```\r\n\r\n\r\n",
          "createdAt": "2020-09-23T10:03:39Z",
          "updatedAt": "2020-09-23T10:03:39Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, let me try to upgrade xml2rpc version in dockerfile...",
          "createdAt": "2020-09-23T10:07:03Z",
          "updatedAt": "2020-09-23T10:07:03Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've just rebuilt my local docker image without any changes and it pulled the fresh version of xml2rpc, so the unexpected changes should go away.",
          "createdAt": "2020-09-23T10:22:35Z",
          "updatedAt": "2020-09-23T10:22:35Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I've just rebuilt my local docker image without any changes and it pulled the fresh version of xml2rpc, so the unexpected changes should go away.\r\n\r\nYes, that's better thanks. Unfortunately, when I regenerate, I still see a diff: https://github.com/jsonpath-standard/internet-draft/commit/eabc0f0cee03bc6afaae23377a27b6fcc27fae2e. It looks like xml2rfc is non-deterministic! `\u00af\\_(\u30c4)_/\u00af`. I guess there's not much we can do without patching xml2rfc...",
          "createdAt": "2020-09-23T10:27:45Z",
          "updatedAt": "2020-09-23T10:27:45Z"
        },
        {
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not very convenient, yes. But I don't see any quick solution, either.",
          "createdAt": "2020-09-23T11:07:13Z",
          "updatedAt": "2020-09-23T11:07:13Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Ticket raised against xml2rfc: https://trac.tools.ietf.org/tools/xml2rfc/trac/ticket/553.",
          "createdAt": "2020-09-24T15:27:38Z",
          "updatedAt": "2020-09-24T15:27:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNDM4NDA5",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-24T12:57:02Z",
          "updatedAt": "2020-08-24T13:05:22Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I _quite_ like being able to use a quoted key to specify a dot child name, but is there a precedent or consensus for this? I've tried to avoid innovation as much as possible in this version.",
              "createdAt": "2020-08-24T12:57:02Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            },
            {
              "originalPosition": 16,
              "body": "I'm trying to make this document self-contained, so please could you add definitions for `DIGIT` and `ALPHA`? In particular, it should be possible to extract the ABNF and then generate a parser.",
              "createdAt": "2020-08-24T12:58:08Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            },
            {
              "originalPosition": 19,
              "body": "I'm not convinced this should include surrogates such as `D800`.",
              "createdAt": "2020-08-24T13:02:28Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            },
            {
              "originalPosition": 34,
              "body": "\"defined below\" is a bit risky. Best to describe and link to the specific section.",
              "createdAt": "2020-08-24T13:05:14Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTIyMTc2",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:05:30Z",
          "updatedAt": "2020-08-24T14:05:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Well, what I see now is: the majority of implementations support the syntax itself (so we should support it, too, I believe). But there's a difference in a way of decoding the key: some implementations consider quotes as non-special part of the ID (\"raw\" approach) and some \"unquote\" the string. The following links show that there's no clear \"majority\" in the approach, but I think that \"unquote\" approach is much less surprising than \"raw\" one.\r\n\r\nhttps://cburgmer.github.io/json-path-comparison/results/dot_notation_with_double_quotes.html\r\nhttps://cburgmer.github.io/json-path-comparison/results/dot_notation_with_single_quotes.html",
              "createdAt": "2020-08-24T14:05:30Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTI2NjM5",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:10:43Z",
          "updatedAt": "2020-08-24T14:10:43Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "`DIGIT` and `ALFA` are defined in [appendix B.1 of ABNF RFC](https://tools.ietf.org/html/rfc5234#appendix-B.1), and they are widely used in other RFCs without re-defining. For example, [JSON RFC](https://tools.ietf.org/html/rfc8259#section-6) uses `DIGIT` rule as a part of JSON number definition.",
              "createdAt": "2020-08-24T14:10:43Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTMyMTE2",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:16:36Z",
          "updatedAt": "2020-08-24T14:16:37Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Maybe it's better to move the definition itself up, so the reader have no need to jump to it while reading from the beginning?",
              "createdAt": "2020-08-24T14:16:37Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTM2NDg0",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:21:14Z",
          "updatedAt": "2020-08-24T14:21:14Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I agree that we could adopt that approach, but as we've discussed elsewhere, there isn't a formal way to pull in ABNF definitions from an RFC, so this introduces a formal weakness which I'd personally prefer to avoid.",
              "createdAt": "2020-08-24T14:21:14Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTQwMzMz",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:25:30Z",
          "updatedAt": "2020-08-24T14:25:30Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "It's tricky because either way could be surprising. If we adopt the \"unquote\" approach, then why bother having bracket child notation at all? It would really be superfluous. I'd find that surprising.\r\n\r\nAlso, both G\u00f6ssner's implementations adopt the \"raw\" approach and I feel that we should probably use G\u00f6ssner to break any \"ties\" now that we are going to merge into an internet draft which will include him as an author.",
              "createdAt": "2020-08-24T14:25:30Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTQwNjA5",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:25:49Z",
          "updatedAt": "2020-08-24T14:25:49Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I just follow the philosophy of JSON strings here. [Section 7 of JSON RFC](https://tools.ietf.org/html/rfc8259#section-7) defines non-ASCII range as \"continuum\" of codepoints within Unicode range, and [section 8.2](https://tools.ietf.org/html/rfc8259#section-8.2) explicitly describes the surrogate case.",
              "createdAt": "2020-08-24T14:25:49Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTQxMzg0",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:26:40Z",
          "updatedAt": "2020-08-24T14:26:40Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Seems reasonable. Why not try that and see if it works out?",
              "createdAt": "2020-08-24T14:26:40Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTQ0NzU0",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:29:59Z",
          "updatedAt": "2020-08-24T14:29:59Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I really like following JSON string syntax. Since it's an area that will be debated again, I think it would be worth adding some text to this document (like the comment above) to call that out.",
              "createdAt": "2020-08-24T14:29:59Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTQ1OTEy",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:31:09Z",
          "updatedAt": "2020-08-24T14:31:09Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Okay, I see no problem in redefining some core ABNF rules that we use, I'll do that.",
              "createdAt": "2020-08-24T14:31:09Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTQ3MTUy",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:32:21Z",
          "updatedAt": "2020-08-24T14:32:21Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thanks!",
              "createdAt": "2020-08-24T14:32:21Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTU1Nzc3",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:41:11Z",
          "updatedAt": "2020-08-24T14:41:11Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "> If we adopt the \"unquote\" approach, then why bother having bracket child notation at all?\r\n\r\nInteresting point, very good. But on the other hand, we have no \"bracket child\" anymore: brackets define union now (and the former \"bracket child\" is just a special case of singular union) - that's the main reason for having them, I believe.\r\n\r\nI feel that if both interpretations are surprising, then we should probably forbid the quotes in dot-child-name at all, bringing some existing queries as a sacrifice to clarity. What do you think?",
              "createdAt": "2020-08-24T14:41:11Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTY4NjIz",
          "commit": {
            "abbreviatedOid": "fa70478"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:47:26Z",
          "updatedAt": "2020-08-24T14:47:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "That seems reasonable to me and it's consistent with the definition of `unquoted-key` which already prohibits single and double quotes from appearing anywhere.",
              "createdAt": "2020-08-24T14:47:26Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjQ5NjE4",
          "commit": {
            "abbreviatedOid": "79aae3e"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T16:35:36Z",
          "updatedAt": "2020-09-22T16:35:37Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "We don't need to do that anymore, because we've rejected supporting quoted dot-child-names.",
              "createdAt": "2020-09-22T16:35:37Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDkwNzYz",
          "commit": {
            "abbreviatedOid": "6dbcc47"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T09:53:12Z",
          "updatedAt": "2020-09-23T09:53:12Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I think it would be neater to define separate rules for `DIGIT` and `ALPHA`. Then we could probably do without the \"core ABNF\" comments, which are slightly distracting for the general reader.",
              "createdAt": "2020-09-23T09:53:12Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NTAwNjE3",
          "commit": {
            "abbreviatedOid": "150c9ce"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T10:05:53Z",
          "updatedAt": "2020-09-23T10:05:53Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done!",
              "createdAt": "2020-09-23T10:05:53Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NTA3OTU5",
          "commit": {
            "abbreviatedOid": "6dbcc47"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T10:15:28Z",
          "updatedAt": "2020-09-23T10:15:29Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "This text is similar to that in [RFC 7159 section 8.2](https://tools.ietf.org/html/rfc7159#section-8.2), but our goal is slightly different. RFC 7159 defined the JSON data format whereas we are defining a standard for JSONPath implementations. So we should probably say something about implementations rather than the more general \"software\". How about the following (which also has some editorial improvements)?\r\n```suggestion\r\n                  <t>Note that the <tt>dot-child-name</tt> rule follows the philosophy of JSON strings and is\r\n                     allowed to contain bit sequences that cannot encode Unicode characters (a single unpaired UTF-16 surrogate, for example).\r\n                     The behaviour of an implementation is undefined for child names which do not encode Unicode characters.\r\n```",
              "createdAt": "2020-09-23T10:15:29Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NTEwODk3",
          "commit": {
            "abbreviatedOid": "6dbcc47"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T10:19:32Z",
          "updatedAt": "2020-09-23T10:19:32Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "nit: Also, it would be nice to line up the comments vertically. :-)",
              "createdAt": "2020-09-23T10:19:32Z",
              "updatedAt": "2020-09-23T10:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NTYzMDkz",
          "commit": {
            "abbreviatedOid": "3e922b5"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks great now, thanks. I'm adding a few editorial changes and will merge soon.",
          "createdAt": "2020-09-23T11:34:16Z",
          "updatedAt": "2020-09-23T11:34:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkxNzEzMDY5",
      "title": "Editorial changes",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/19",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "Align ABNF comments.\r\n\r\nUse the term Unicode characters rather than Unicode symbols for consistency.\r\n\r\n(Also regenerate, which fills in for a missing generate at master.)",
      "createdAt": "2020-09-23T11:39:04Z",
      "updatedAt": "2020-09-23T14:03:43Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "7dfd5b3c1ee58b559c46ac768099bcab7d28ad1c",
      "headRepository": "glyn/internet-draft",
      "headRefName": "dot-child-name",
      "headRefOid": "781e3b7dcd8e1aee69ca202a453c58ce2b84517f",
      "closedAt": "2020-09-23T14:01:23Z",
      "mergedAt": "2020-09-23T14:01:23Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "919345a34eea31f11fc8fd7c944e5b726a1f5da4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjY0MjI5",
          "commit": {
            "abbreviatedOid": "781e3b7"
          },
          "author": "remorhaz",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-23T13:33:26Z",
          "updatedAt": "2020-09-23T13:33:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkyMzE2MTU5",
      "title": "Use \"selector\" instead of \"matcher\"",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/22",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "Fixes https://github.com/jsonpath-standard/internet-draft/issues/20\r\n\r\nSee the [rendered HTML](https://glyn.github.io/internet-draft/) version of this PR.",
      "createdAt": "2020-09-24T09:34:45Z",
      "updatedAt": "2020-09-24T12:46:03Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "e1d86466d2dea14682fbded0e3f94637b18d07c1",
      "headRepository": "glyn/internet-draft",
      "headRefName": "20-selector-terminology",
      "headRefOid": "2ff678076145fecad4ae5a322e24a55d2d6fc215",
      "closedAt": "2020-09-24T12:45:59Z",
      "mergedAt": "2020-09-24T12:45:58Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "bf2098d875dbda9b0c8f2df27a444c5ce1605693"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I particularly welcome @gregsdennis's comments since he raised https://github.com/jsonpath-standard/internet-draft/issues/20.",
          "createdAt": "2020-09-24T09:36:24Z",
          "updatedAt": "2020-09-24T09:36:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NDg4MjA5",
          "commit": {
            "abbreviatedOid": "2ff6780"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "I think the `matcher -> selector` changes are good.  I'd just add the word \"distinct\" in the place indicated.\r\n\r\nReading through, I saw a few other language nuances that could be cleared up.  I'll raise them in separate issues for discussion.",
          "createdAt": "2020-09-24T11:50:33Z",
          "updatedAt": "2020-09-24T11:56:39Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "\"distinct concatenation\"",
              "createdAt": "2020-09-24T11:50:33Z",
              "updatedAt": "2020-09-24T11:56:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NDk0NzA2",
          "commit": {
            "abbreviatedOid": "2ff6780"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T12:00:03Z",
          "updatedAt": "2020-09-24T12:00:04Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Does distinct concatenation mean with duplicates removed? That term is unfamiliar to me. ",
              "createdAt": "2020-09-24T12:00:03Z",
              "updatedAt": "2020-09-24T12:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NTA0OTI3",
          "commit": {
            "abbreviatedOid": "2ff6780"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T12:13:56Z",
          "updatedAt": "2020-09-24T12:13:56Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Correct, no duplicates. I think mine currently regards the same value from different locations as distinct from one another, meaning it'll keep both.\r\n\r\nIt's worth discussing further, probably. Maybe just merge this for now, and I'll open an issue for it.",
              "createdAt": "2020-09-24T12:13:56Z",
              "updatedAt": "2020-09-24T12:13:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NTA1MTQz",
          "commit": {
            "abbreviatedOid": "2ff6780"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-24T12:14:11Z",
          "updatedAt": "2020-09-24T12:14:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NTMxMzMz",
          "commit": {
            "abbreviatedOid": "2ff6780"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T12:45:52Z",
          "updatedAt": "2020-09-24T12:45:52Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Yes, I'd like to keep that as a separate issue. It's somewhat related to the placeholder we have in the spec about whether to remove duplicates from unions.",
              "createdAt": "2020-09-24T12:45:52Z",
              "updatedAt": "2020-09-24T12:45:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk4NjU1MzMy",
      "title": "Allow step of array slice to be omitted",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/28",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This allows slices of the form [0:10:].",
      "createdAt": "2020-10-06T15:47:13Z",
      "updatedAt": "2020-10-08T11:17:32Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "bf2098d875dbda9b0c8f2df27a444c5ce1605693",
      "headRepository": "glyn/internet-draft",
      "headRefName": "optional-step",
      "headRefOid": "302f3a8fecbb4523ce48764bb087258de6e7214c",
      "closedAt": "2020-10-08T11:17:28Z",
      "mergedAt": "2020-10-08T11:17:28Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "b1a0a366d6a41394d47f291a799ec2fb5d58517c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMjc3MjUw",
          "commit": {
            "abbreviatedOid": "344b898"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-06T19:09:17Z",
          "updatedAt": "2020-10-06T19:09:27Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Should the `ws` be included in the brackets?  Maybe `ws [ %x3A ws [ integer ] ]` is better?",
              "createdAt": "2020-10-06T19:09:18Z",
              "updatedAt": "2020-10-07T06:57:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTczNzYx",
          "commit": {
            "abbreviatedOid": "344b898"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T06:55:50Z",
          "updatedAt": "2020-10-07T06:55:51Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "It's syntactically equivalent because of the `ws` in the union syntax, but I agree it is more consistent.",
              "createdAt": "2020-10-07T06:55:50Z",
              "updatedAt": "2020-10-07T06:57:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTc0ODQ0",
          "commit": {
            "abbreviatedOid": "302f3a8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T06:57:35Z",
          "updatedAt": "2020-10-07T06:57:35Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "changed",
              "createdAt": "2020-10-07T06:57:35Z",
              "updatedAt": "2020-10-07T06:57:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Njc2MDE3",
          "commit": {
            "abbreviatedOid": "302f3a8"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T11:16:22Z",
          "updatedAt": "2020-10-08T11:16:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxNjk0NTcz",
      "title": "Run scripts/docker-gen.sh",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/30",
      "state": "MERGED",
      "author": "mkmik",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "running `docker-gen.sh` now runs xml2rfc version `3.2.1`.\r\nThis PR just checks in the minor modifications in the output that this tool does since `3.1.1`, so that next PRs will have more meaningful diffs in the output",
      "createdAt": "2020-10-12T16:53:06Z",
      "updatedAt": "2020-10-13T15:24:28Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "b1a0a366d6a41394d47f291a799ec2fb5d58517c",
      "headRepository": "mkmik/internet-draft",
      "headRefName": "newrun",
      "headRefOid": "ad019465d0277394f91e67b2eca25bbd0adda818",
      "closedAt": "2020-10-13T15:24:28Z",
      "mergedAt": "2020-10-13T15:24:28Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "ed3f1a6ad937db6d658ab8c701289d77d49fcfbb"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> running `docker-gen.sh` now runs xml2rfc version `3.2.1`.\r\n> This PR just checks in the minor modifications in the output that this tool does since `3.1.1`, so that next PRs will have more meaningful diffs in the output\r\n\r\nUnfortunately, xml2rfc is [non-deterministic](https://trac.tools.ietf.org/tools/xml2rfc/trac/ticket/553), so this PR won't make future diffs and more meaningful. Happy to merge it if the `3.1.1`->`3.2.1` has any value, but I doubt that.",
          "createdAt": "2020-10-13T14:31:35Z",
          "updatedAt": "2020-10-13T14:31:35Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "I noticed, but the size of the delta due to non determinism is smaller if the version is the same",
          "createdAt": "2020-10-13T14:44:39Z",
          "updatedAt": "2020-10-13T14:44:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NTU3Mzk5",
          "commit": {
            "abbreviatedOid": "ad01946"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-13T15:24:23Z",
          "updatedAt": "2020-10-13T15:24:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0ODg4NDUy",
      "title": "Change array slicing specification",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/31",
      "state": "MERGED",
      "author": "mkmik",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Related to #29 and jsonpath-standard/jsonpath-reference-implementation#22\r\n\r\n@glyn ",
      "createdAt": "2020-10-16T14:24:22Z",
      "updatedAt": "2020-10-26T18:17:06Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "1b8ae91470bcef2e3dd98f10f561f7230a7daf22",
      "headRepository": "mkmik/internet-draft",
      "headRefName": "slice",
      "headRefOid": "ca521edf68d8a841c310f78e3c0102faa3d94673",
      "closedAt": "2020-10-26T18:17:06Z",
      "mergedAt": "2020-10-26T18:17:06Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "87422dafa36fbfaafccba55a3ce01e6fb8852006"
      },
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "No.  Stop talking about actual values. We shouldn't be doing that. We should define ***behavior***, not limits. Limits are an implementation detail. What happens when those limits are exceeded is for us to define.",
          "createdAt": "2020-10-20T10:00:46Z",
          "updatedAt": "2020-10-20T10:00:46Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> No. Stop talking about actual values. We shouldn't be doing that. We should define _**behavior**_, not limits. Limits are an implementation detail. What happens when those limits are exceeded is for us to define.\r\n\r\nYes, I have some sympathy for this. From a spec point of view, we should either get correct slice behaviour or an error (still to be mentioned in the text). Implementations which choose poor limits will soon get an appropriate reputation.\r\n\r\nThis is somewhat analogous to specifying `malloc` non-deterministically: it either succeeds or it fails, but we don't try to say when it will fail as that would get into implementation detail.",
          "createdAt": "2020-10-20T10:25:28Z",
          "updatedAt": "2020-10-20T10:25:28Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, I can't decide whether it would be a good thing to mention that slicing is based on Python slices. WDYT @mkmik  @gregsdennis?",
          "createdAt": "2020-10-21T09:41:49Z",
          "updatedAt": "2020-10-21T09:41:49Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "currently the aspirational spec deviates from python slices in one detail: when step is 0 we yield an empty slice, while python raises an erro\r\n",
          "createdAt": "2020-10-21T09:48:36Z",
          "updatedAt": "2020-10-21T09:48:36Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "Javascript's `.slice` method has the same semantics w.r.t the negative indices and behaviour w.r.t out of bound indices, but it lacks a `step`. Which is good because the JSON in JSONPath has a historical connection with JS. Should we mention that the core slicing syntax (excluding the step part) is based on JavaScript semantics?\r\n\r\nhttps://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array) may not be exhaustive but shows that python is the only language that has inclusive start, exclusive end and a step.\r\n\r\nThe \"python connection\" thus comes into play only once we introduce `step`. If we want to support `step` (not sure if we have to), then I think it would be quite confusing if the behaviour of JSONPath were different than the only other (popular) language that has the `first:end:step` syntax.\r\n\r\nWhether the spec should explicitly acknowledge this connection is another question. One one hand it would be weird to not acknowledge it, but on the other hand, what if the spec ends up being subtly different from python's? is there an unambiguous spec of the slicing expression for python or is it de-facto implementation defined?",
          "createdAt": "2020-10-21T10:25:04Z",
          "updatedAt": "2020-10-21T10:25:04Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> currently the aspirational spec deviates from python slices in one detail: when step is 0 we yield an empty slice, while python raises an erro[r]\r\n\r\nYeah, that's a bit of a pain when it comes to mentioning Python slices. In an earlier version, a zero step was disallowed by the syntax, which is another solution. But someone didn't like that...",
          "createdAt": "2020-10-21T10:25:24Z",
          "updatedAt": "2020-10-21T10:25:24Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> is there an unambiguous spec of the slicing expression for python or is it de-facto implementation defined?\r\n\r\nThe [spec](https://docs.python.org/2.0/ref/slicings.html), such as it is, isn't really definitive.",
          "createdAt": "2020-10-21T15:53:24Z",
          "updatedAt": "2020-10-21T15:54:10Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "The other aspect to consider is that if Python updates their definition of a slice (to include a step, perhaps) then our spec is out of date.  It may be worth mentioning Python as a source of inspiration, but then proceed to define the slice anyway. ",
          "createdAt": "2020-10-21T18:57:13Z",
          "updatedAt": "2020-10-21T19:02:41Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> The other aspect to consider is that if Python updates their definition of a slice (to include a step, perhaps) then our spec is out of date. It may be worth mentioning Python as a source of inspiration, but then proceed to define the slice anyway.\r\n\r\nAbsolutely. I wasn't trying to suggest that we delegate the spec to Python, but that we acknowledge the inspiration as you say. They may want to lift our spec in due course. ;-)",
          "createdAt": "2020-10-22T09:20:15Z",
          "updatedAt": "2020-10-22T09:20:15Z"
        },
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "@glyn , @gregsdennis PTAL;\r\n\r\nI looked around how people explain the python slice behavior with negative indices and I also gave this as an exercise to a a more junior colleague. I think there might be value in adding a little \"level of indirection\" by introducing the concept of \"lower\" and \"upper\" bound, to contextualize the need for a different terminating condition.\r\n",
          "createdAt": "2020-10-26T10:27:43Z",
          "updatedAt": "2020-10-26T10:27:43Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@mkmik please remember to add yourself to the list of authors.",
          "createdAt": "2020-10-26T12:06:53Z",
          "updatedAt": "2020-10-26T12:06:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODY0NjEw",
          "commit": {
            "abbreviatedOid": "c9ac139"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-17T01:53:30Z",
          "updatedAt": "2020-10-17T01:53:31Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "I'm not a fan of specifying a limit, though I do agree with the usage of RECOMMENDED to allow leeway for implementations.\r\n\r\nInstead of specifying a hard limit, I think we should specify a behavior when an implementation encounters values outside of its language's range.",
              "createdAt": "2020-10-17T01:53:31Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjE3NDgx",
          "commit": {
            "abbreviatedOid": "c9ac139"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T10:22:13Z",
          "updatedAt": "2020-10-19T10:22:14Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "perhaps we should define a reasonable lower bound as a MUST? e.g. I don't think it makes sense to have conforming implementations that only support 256 element arrays",
              "createdAt": "2020-10-19T10:22:13Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjMwMDM4",
          "commit": {
            "abbreviatedOid": "c9ac139"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T10:39:55Z",
          "updatedAt": "2020-10-19T10:39:55Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "Perhaps a signed 32 bit range could be mandatory (MUST) and a signed 64 bit range recommended (SHOULD).",
              "createdAt": "2020-10-19T10:39:55Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjM0MjIz",
          "commit": {
            "abbreviatedOid": "c9ac139"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T10:46:04Z",
          "updatedAt": "2020-10-19T10:46:05Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "SGTM, w.r.t array length.\r\n\r\nWhat about slice start and end positions? The RI offers an API that allows for full 64-bit absolute range *and* a full 64-bit range for \"end relative\" positions. If \"end relative\" positions are \"naively\" implemented with negative numbers (as suggested by the standard's own syntactic layer), that would limit implementations to only 63 bits to specify an absolute position (the same problem arises for those implementations that choose a 32-bit index space, and use 31-bit signed positions).",
              "createdAt": "2020-10-19T10:46:04Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTA3NTg0",
          "commit": {
            "abbreviatedOid": "c9ac139"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T09:25:20Z",
          "updatedAt": "2020-10-20T09:25:20Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "On balance, I'd prefer to keep the spec simple rather than complicate it for \"non-naive\" implementations. Signed 64 bit values of slice start and end positions should be fine for all real-world JSON arrays. Implementations that choose to support only signed 32 bit values could be at a disadvantage for very large JSON arrays, but in that case, it would probably be better to use an implementation that supports signed 64 bit values.",
              "createdAt": "2020-10-20T09:25:20Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTI0MzA4",
          "commit": {
            "abbreviatedOid": "c9ac139"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I've made quite a few comments, mostly stylistic and trying to make the spec more formal.",
          "createdAt": "2020-10-20T09:44:36Z",
          "updatedAt": "2020-10-20T10:20:22Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Because of the above deletions, the spec is now silent on the semantics for an array index. Probably best to re-instate the above.",
              "createdAt": "2020-10-20T09:44:36Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 148,
              "body": "This is inconsistent with the wording for other selectors. The general framing is that a selector selects zero or more nodes, each of which is a descendant of the node or the node itself. The output from a selector is a list of nodes.\r\n```suggestion\r\n                     <t>A slice expression selects a subset of the elements of the input array.</t>\r\n```",
              "createdAt": "2020-10-20T09:49:29Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 151,
              "body": "```suggestion\r\n                        Each of these parameters is optional.</t>\r\n```",
              "createdAt": "2020-10-20T09:50:51Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 150,
              "body": "```suggestion\r\n                        and an iteration delta, <tt>step</tt>, which also governs the iteration order.\r\n```",
              "createdAt": "2020-10-20T09:52:36Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 152,
              "body": "`b` and `len` need defining.",
              "createdAt": "2020-10-20T09:53:13Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 153,
              "body": "This isn't very clear. It's not absolutely clear that \"remapping\" refers to the interpretation of negative bounds. Better to use a single term consistently. (This isn't the rule for normal English, but specs are allowed to be boring.)\r\n\r\nAlso, we haven't talked about \"evaluation\" of slices or mentioned any \"steps\" in the evaluation. Ideally, it would be good to avoid an algorithmic/sequenced description in the normative text. Better to define terms and use them. For instance, we could talk about \"normalizing\" (American English preferred) bounds first and then say how the slice selects elements based on the normalized bounds.",
              "createdAt": "2020-10-20T09:59:26Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 155,
              "body": "I'm not keen on the \"invalid\" terminology, as this connotes an error or mistake. Such bounds are perfectly valid. We can either describe how they are clamped, depending on the step value. Or we could allow them to default to +/- infinity and make it clear how very large positive and negative explicit (including defaulted) bounds are interpreted.",
              "createdAt": "2020-10-20T10:04:58Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 5,
              "body": "These whitespace changes are distracting. Was this deliberate or just the result of the editor?",
              "createdAt": "2020-10-20T10:07:49Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 160,
              "body": "So the earlier statement of omitted bounds taking a default value isn't _quite_ accurate as in this case, we are avoiding saying what the default value is.",
              "createdAt": "2020-10-20T10:09:34Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 164,
              "body": "`i` is undefined.\r\n\r\nWe don't say _how_ individual elements are indexed. In particular, index 0 selects the first element of the array.\r\n\r\n\"collecting\" could be changed to \"selecting\" for consistency with the rest of the spec.",
              "createdAt": "2020-10-20T10:13:40Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 169,
              "body": "I hope these three paragraphs are actually consequences of the preceding text. If so, it would be better to be clear that they are consequences rather than additional rules. E.g. \"As a consequence of the above:\" follow by a list of three bullets.",
              "createdAt": "2020-10-20T10:15:41Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 203,
              "body": "I think we might be going into too much implementation detail here, which sets a nasty precedent for the rest of the spec. If we keep the pseudocode, I wonder if we can somehow indicate that it isn't normative.",
              "createdAt": "2020-10-20T10:18:58Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            },
            {
              "originalPosition": 216,
              "body": "I think I'd prefer to mention these inline to motivate the slice notation.",
              "createdAt": "2020-10-20T10:19:44Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTI4Njc3",
          "commit": {
            "abbreviatedOid": "e467a1d"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T10:26:15Z",
          "updatedAt": "2020-10-21T10:26:15Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "if step is negative the output of the slice expression cannot be represented by a pure selection of the input array",
              "createdAt": "2020-10-21T10:26:15Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTI5NjMx",
          "commit": {
            "abbreviatedOid": "e467a1d"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T10:27:29Z",
          "updatedAt": "2020-10-21T10:27:30Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "uh I thought we had another section about (non-slice) indexing; will put back",
              "createdAt": "2020-10-21T10:27:29Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTk5MjYy",
          "commit": {
            "abbreviatedOid": "e467a1d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T12:02:00Z",
          "updatedAt": "2020-10-21T12:02:00Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Why not? Ordering? In my mind, selection doesn't imply a particular ordering.",
              "createdAt": "2020-10-21T12:02:00Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNjEyMzc4",
          "commit": {
            "abbreviatedOid": "e467a1d"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T12:18:32Z",
          "updatedAt": "2020-10-21T12:18:32Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "yeah ordering was my concern. To me \"selects\" sounds like the original ordering is preserved and we just apply a \"filter\" that removes extra elements. What we do here is to apply a transformation, we \"map\" the input array into an output array.\r\n\r\nthat said, that's only my interpretation, if \"selects\" clearly conveys the desired meaning of \"remapping\" I'm ok with it.\r\n\r\n",
              "createdAt": "2020-10-21T12:18:32Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNjg3Njg0",
          "commit": {
            "abbreviatedOid": "e467a1d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T13:35:25Z",
          "updatedAt": "2020-10-21T13:35:26Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "\"select\" will only convey specific meanings if we say so. I'd prefer not to try to overload the term and be explicit about the ordering properties of slices. Maybe in this introductory statement we can say:\r\n```suggestion\r\n                     <t>A slice expression selects a subset of the elements of the input array, in the same order as the array or the reverse order, depending on the expression.</t>\r\n```",
              "createdAt": "2020-10-21T13:35:25Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NjM4ODk3",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T10:23:31Z",
          "updatedAt": "2020-10-26T10:23:31Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "PTAL",
              "createdAt": "2020-10-26T10:23:31Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NjM5MTU4",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T10:23:50Z",
          "updatedAt": "2020-10-26T10:23:50Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "PTAL",
              "createdAt": "2020-10-26T10:23:50Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NjM5NjY2",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T10:24:28Z",
          "updatedAt": "2020-10-26T10:24:29Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "PTAL",
              "createdAt": "2020-10-26T10:24:28Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NjkyNDc5",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T11:36:36Z",
          "updatedAt": "2020-10-26T11:36:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The behaviour of array access for non-array nodes is now undefined.",
              "createdAt": "2020-10-26T11:36:36Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NjkyOTU5",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T11:37:19Z",
          "updatedAt": "2020-10-26T11:37:19Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Probably worth adding a non-normative reference for ECMA-262.",
              "createdAt": "2020-10-26T11:37:19Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Njk2NDIw",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T11:42:50Z",
          "updatedAt": "2020-10-26T11:42:50Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "It seems strange to talk about _syntactic_ sugar in the semantics section. Perhaps like the following would be clearer:\r\n```suggestion\r\n                     <t>The result of the array indexing expression <tt>[i]</tt> is defined to be the result of the array slicing expression\r\n                        <tt>a[i:Normalize(i)+1:1]</tt>.</t>\r\n```",
              "createdAt": "2020-10-26T11:42:50Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Njk3MDk0",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T11:43:54Z",
          "updatedAt": "2020-10-26T11:43:55Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "This is fine, but a table would have been equally easy to follow.",
              "createdAt": "2020-10-26T11:43:55Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Njk4MzA5",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T11:45:46Z",
          "updatedAt": "2020-10-26T11:45:47Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "I'm not sure what value this statement adds and it could even be viewed as implementation bias. The following statements say what to do when a value is encountered which the implementation can't cope with.",
              "createdAt": "2020-10-26T11:45:46Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Njk4NDQ5",
          "commit": {
            "abbreviatedOid": "0b80bbe"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T11:45:59Z",
          "updatedAt": "2020-10-26T11:46:00Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Makes sense, thanks",
              "createdAt": "2020-10-26T11:45:59Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NzA1MTI3",
          "commit": {
            "abbreviatedOid": "a101a86"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T11:56:02Z",
          "updatedAt": "2020-10-26T11:56:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "`aex` really is a thing of beauty, isn't it? ;-)\r\n```suggestion\r\n# TODO fix aex to not extract ABNF-looking rules from pseudocode blocks\r\n```",
              "createdAt": "2020-10-26T11:56:03Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NzExMjgw",
          "commit": {
            "abbreviatedOid": "0b80bbe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T12:05:03Z",
          "updatedAt": "2020-10-26T12:05:03Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "Section 2.3 allows implementations to defer raising errors until applying the JSONPath to a document. So how about something like this instead?\r\n```suggestion\r\n                        An implementation MUST raise an error if any of the slice expression parameters does not fit in the implementation's representation of an integer.\r\n```",
              "createdAt": "2020-10-26T12:05:03Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NzEyMDIw",
          "commit": {
            "abbreviatedOid": "0b80bbe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T12:06:12Z",
          "updatedAt": "2020-10-26T12:06:13Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n                        fit in the implementation's representation of an integer, the implementation\r\n```",
              "createdAt": "2020-10-26T12:06:12Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NzMxMTYw",
          "commit": {
            "abbreviatedOid": "0b80bbe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T12:34:33Z",
          "updatedAt": "2020-10-26T12:34:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Whoops!:\r\n```suggestion\r\n                        <tt>[i:Normalize(i)+1:1]</tt>.</t>\r\n```",
              "createdAt": "2020-10-26T12:34:33Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODI3MTk4",
          "commit": {
            "abbreviatedOid": "a8bc57d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T14:22:33Z",
          "updatedAt": "2020-10-26T14:22:34Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "To be clear, I was suggesting deleting the sentence.",
              "createdAt": "2020-10-26T14:22:33Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODM5MzY1",
          "commit": {
            "abbreviatedOid": "a8bc57d"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T14:33:47Z",
          "updatedAt": "2020-10-26T14:33:47Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "thanks for the suggestion, rewrote as a table",
              "createdAt": "2020-10-26T14:33:47Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODUzODc1",
          "commit": {
            "abbreviatedOid": "9e1ed49"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T14:47:31Z",
          "updatedAt": "2020-10-26T14:47:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "good catch; I put it back where `a(i)` is defined",
              "createdAt": "2020-10-26T14:47:31Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODUzOTg1",
          "commit": {
            "abbreviatedOid": "9e1ed49"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T14:47:37Z",
          "updatedAt": "2020-10-26T14:47:37Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "added",
              "createdAt": "2020-10-26T14:47:37Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODU2NDM4",
          "commit": {
            "abbreviatedOid": "77411e2"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T14:49:37Z",
          "updatedAt": "2020-10-26T14:49:38Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "suggestion applied",
              "createdAt": "2020-10-26T14:49:38Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODgwNTI2",
          "commit": {
            "abbreviatedOid": "4b91454"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T15:12:24Z",
          "updatedAt": "2020-10-26T15:12:25Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Yes, according to the [definition](https://tools.ietf.org/html/rfc7991#section-2.7.6) of the author tag, `editor` is the only option for a role. If you'd prefer not to act an an editor:\r\n```suggestion\r\n    <author fullname=\"Marko Mikulicic\" initials=\"M\" surname=\"Mikulicic\">\r\n```",
              "createdAt": "2020-10-26T15:12:25Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODgyODY3",
          "commit": {
            "abbreviatedOid": "4b91454"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T15:14:39Z",
          "updatedAt": "2020-10-26T15:14:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I can see it in the syntax section, but it's probably better to move that to somewhere near the top of the semantics section.",
              "createdAt": "2020-10-26T15:14:39Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTAyMzgx",
          "commit": {
            "abbreviatedOid": "4b91454"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T15:33:22Z",
          "updatedAt": "2020-10-26T15:33:22Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "thanks",
              "createdAt": "2020-10-26T15:33:22Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTEyNTY3",
          "commit": {
            "abbreviatedOid": "922c930"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T15:43:01Z",
          "updatedAt": "2020-10-26T15:43:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "moved on top",
              "createdAt": "2020-10-26T15:43:02Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTc3Njk4",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:47:21Z",
          "updatedAt": "2020-10-26T16:47:21Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n                        This section specifies the behaviour fully, without depending on JavaScript or Python behaviour.\r\n```",
              "createdAt": "2020-10-26T16:47:21Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTgxMTE1",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:51:06Z",
          "updatedAt": "2020-10-26T16:51:07Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n                        Array indexing is defined in terms of array slicing.</t>\r\n```",
              "createdAt": "2020-10-26T16:51:07Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTgxOTYy",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:52:00Z",
          "updatedAt": "2020-10-26T16:52:01Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\n                        as follows:</t>\r\n```",
              "createdAt": "2020-10-26T16:52:00Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTgyODU4",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:52:56Z",
          "updatedAt": "2020-10-26T16:52:57Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Perhaps the following?\r\n```suggestion\r\n                       <name>Default array slice start and end values</name>\r\n```",
              "createdAt": "2020-10-26T16:52:56Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTgzMjky",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:53:26Z",
          "updatedAt": "2020-10-26T16:53:26Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```suggestion\r\n                        as slice bounds and must first be normalized. Normalization is defined as:</t>\r\n```",
              "createdAt": "2020-10-26T16:53:26Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTg0MzM3",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:54:31Z",
          "updatedAt": "2020-10-26T16:54:31Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n                        <tt>lower</tt> and <tt>upper</tt>. The direction of the iteration, defined\r\n                        by the sign of <tt>step</tt>, determines which of the parameters is the lower bound and which\r\n```",
              "createdAt": "2020-10-26T16:54:31Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTg1Mjc4",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:55:27Z",
          "updatedAt": "2020-10-26T16:55:27Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n                     <t>The slice expression selects elements with indices between the lower and upper bounds.\r\n```",
              "createdAt": "2020-10-26T16:55:27Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTg5MTc4",
          "commit": {
            "abbreviatedOid": "362e43c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T16:59:35Z",
          "updatedAt": "2020-10-26T16:59:36Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "```suggestion\r\n                     <t>When <tt>step = 0</tt>, no elements are selected and the result array is empty.\r\n                       This is intentional.</t>\r\n```",
              "createdAt": "2020-10-26T16:59:35Z",
              "updatedAt": "2020-10-26T17:40:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDEzMDY5",
          "commit": {
            "abbreviatedOid": "b7967f1"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Excellent - a great improvement. Thanks!",
          "createdAt": "2020-10-26T17:26:14Z",
          "updatedAt": "2020-10-26T17:26:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA4MTUzMzAw",
      "title": "Remove trailing whitespace",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/32",
      "state": "MERGED",
      "author": "mkmik",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-22T09:35:30Z",
      "updatedAt": "2020-10-22T09:36:54Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "ed3f1a6ad937db6d658ab8c701289d77d49fcfbb",
      "headRepository": "mkmik/internet-draft",
      "headRefName": "whitespace",
      "headRefOid": "bbe193247f3211a57c7188f56aa90279e4cc2f43",
      "closedAt": "2020-10-22T09:36:54Z",
      "mergedAt": "2020-10-22T09:36:54Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "11e61d994a14f957adaf202c1a041a92e250c622"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTM5NTkz",
          "commit": {
            "abbreviatedOid": "bbe1932"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-22T09:36:49Z",
          "updatedAt": "2020-10-22T09:36:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA4MTU3NDQx",
      "title": "Add editorconfig",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/33",
      "state": "MERGED",
      "author": "mkmik",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://editorconfig.org/\r\n\r\nSome editors have native support for this. Other need a plugin (e.g. https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig)",
      "createdAt": "2020-10-22T09:42:23Z",
      "updatedAt": "2020-10-22T09:43:05Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "11e61d994a14f957adaf202c1a041a92e250c622",
      "headRepository": "mkmik/internet-draft",
      "headRefName": "editorconfig",
      "headRefOid": "1dcc5f136e7559f2eb55cf7606a08f951dea1292",
      "closedAt": "2020-10-22T09:43:05Z",
      "mergedAt": "2020-10-22T09:43:04Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "64e1b64633a0ed980c70b45c8eeca56dd1d3d60a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTQ0NzA1",
          "commit": {
            "abbreviatedOid": "1dcc5f1"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-22T09:42:53Z",
          "updatedAt": "2020-10-22T09:42:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA4MTc0MDM1",
      "title": "Mention editorconfig in README.md",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/34",
      "state": "MERGED",
      "author": "mkmik",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-22T10:08:53Z",
      "updatedAt": "2020-10-22T14:37:40Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "64e1b64633a0ed980c70b45c8eeca56dd1d3d60a",
      "headRepository": "mkmik/internet-draft",
      "headRefName": "readme",
      "headRefOid": "1112137a1053f3928b5287e3a3e6f8f6919ba06b",
      "closedAt": "2020-10-22T10:25:30Z",
      "mergedAt": "2020-10-22T10:25:29Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "1b8ae91470bcef2e3dd98f10f561f7230a7daf22"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTcxNzky",
          "commit": {
            "abbreviatedOid": "39e8550"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T10:16:14Z",
          "updatedAt": "2020-10-22T10:16:15Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nBasic conventions around source files formatting are captured in the `.editorconfig` file.\r\n```",
              "createdAt": "2020-10-22T10:16:15Z",
              "updatedAt": "2020-10-22T10:25:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTc4OTcw",
          "commit": {
            "abbreviatedOid": "1112137"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-22T10:25:22Z",
          "updatedAt": "2020-10-22T10:25:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwMTk0Njcw",
      "title": "Change array slicing specification",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/35",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Features of the specification approach:\r\n1. defines array indexing in terms of the slicing operation,\r\n   thus avoiding duplication\r\n2. albeit being verbose, the distinct forward and backward\r\n   iteration loops and explicit lower and upper bound variable\r\n   names helps the reader understand the termination condition.\r\n3. clearly distinguishes the \"slice parameters\" (which can be\r\n   negative), from the normalized bounds (lower, upper) to help\r\n   readers avoid the confusion of iterating until normalized\r\n   end = -1.\r\n\r\nCo-authored-by: Glyn Normington <normingtong@vmware.com>",
      "createdAt": "2020-10-26T17:34:13Z",
      "updatedAt": "2020-10-26T18:16:38Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "1b8ae91470bcef2e3dd98f10f561f7230a7daf22",
      "headRepository": "glyn/internet-draft",
      "headRefName": "slice",
      "headRefOid": "e5e2851075fc6e307dedf8a05deece31e502b3ca",
      "closedAt": "2020-10-26T18:16:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDIzMzUx",
          "commit": {
            "abbreviatedOid": "e5e2851"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-26T17:38:19Z",
          "updatedAt": "2020-10-26T17:38:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwNzMyMTk5",
      "title": "Gentle introduction to array access",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/36",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "See also a [rendered version](https://glyn.github.io/internet-draft/#name-array-access-2).",
      "createdAt": "2020-10-27T12:55:44Z",
      "updatedAt": "2020-10-28T10:40:45Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "87422dafa36fbfaafccba55a3ce01e6fb8852006",
      "headRepository": "glyn/internet-draft",
      "headRefName": "array-access-intro",
      "headRefOid": "4fca8fb5c24750d180adba02d5a12b3773b11433",
      "closedAt": "2020-10-28T10:40:41Z",
      "mergedAt": "2020-10-28T10:40:41Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "a56829dcbf0be114b3aa91bf0a1c51f12f63d693"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Raised https://github.com/jsonpath-standard/internet-draft/issues/37 which I think should be addressed as a global editorial change, separate from this PR.",
          "createdAt": "2020-10-27T14:38:36Z",
          "updatedAt": "2020-10-27T14:38:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NzU5MDA5",
          "commit": {
            "abbreviatedOid": "9182ba4"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2020-10-27T14:21:31Z",
          "updatedAt": "2020-10-27T14:21:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NzYxMTkx",
          "commit": {
            "abbreviatedOid": "9182ba4"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T14:23:23Z",
          "updatedAt": "2020-10-27T14:23:23Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "\"Array access\" sounds a bit odd to me; I know it's the title of the section so it doesn't come from this PR.\r\n\r\nWhat about \"Array selection\" ?",
              "createdAt": "2020-10-27T14:23:23Z",
              "updatedAt": "2020-10-28T10:40:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NzY3MDQ5",
          "commit": {
            "abbreviatedOid": "9182ba4"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T14:28:26Z",
          "updatedAt": "2020-10-27T14:28:27Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Good point. Actually, we use the term \"selector\" elsewhere, so I'll try that and see how it works out.",
              "createdAt": "2020-10-27T14:28:26Z",
              "updatedAt": "2020-10-28T10:40:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NzczMDQy",
          "commit": {
            "abbreviatedOid": "18d6565"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T14:33:33Z",
          "updatedAt": "2020-10-27T14:33:33Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "@mkmik Done. See what you think. (I avoided renaming \"union child\" to \"union child selector\" but we may decide to do that for consistency.)",
              "createdAt": "2020-10-27T14:33:33Z",
              "updatedAt": "2020-10-28T10:40:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDc2MTgy",
          "commit": {
            "abbreviatedOid": "18d6565"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T09:39:22Z",
          "updatedAt": "2020-10-28T09:39:23Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I'm wondering about specifically flagging this section as normative because that might then cast some doubt over whether other sections are normative. Maybe a bland title such as \"Details\" would be safer?",
              "createdAt": "2020-10-28T09:39:23Z",
              "updatedAt": "2020-10-28T10:40:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTI1MzI2",
          "commit": {
            "abbreviatedOid": "18d6565"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T10:37:44Z",
          "updatedAt": "2020-10-28T10:37:44Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "SGTM",
              "createdAt": "2020-10-28T10:37:44Z",
              "updatedAt": "2020-10-28T10:40:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTI1NDQ5",
          "commit": {
            "abbreviatedOid": "18d6565"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T10:37:53Z",
          "updatedAt": "2020-10-28T10:37:53Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "LGTM",
              "createdAt": "2020-10-28T10:37:53Z",
              "updatedAt": "2020-10-28T10:40:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTI2OTQw",
          "commit": {
            "abbreviatedOid": "18d6565"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T10:39:48Z",
          "updatedAt": "2020-10-28T10:39:48Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Ok, I went for \"Detailed Semantics\".",
              "createdAt": "2020-10-28T10:39:48Z",
              "updatedAt": "2020-10-28T10:40:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwOTM5OTY2",
      "title": "Use xpath to feed only abnf soucecode to aex and bap",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/38",
      "state": "MERGED",
      "author": "mkmik",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "thus avoding other types of sourcecode (such as pseudocode) to be validated by the ABNF checker.\r\n\r\naex is still needed because it reformats the content for bap somehow (didn't investigate).",
      "createdAt": "2020-10-27T17:40:48Z",
      "updatedAt": "2020-10-28T11:00:59Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "a56829dcbf0be114b3aa91bf0a1c51f12f63d693",
      "headRepository": "mkmik/internet-draft",
      "headRefName": "xpath",
      "headRefOid": "8e99b8962c12e1bca9579e7745648f355823b045",
      "closedAt": "2020-10-28T11:00:56Z",
      "mergedAt": "2020-10-28T11:00:56Z",
      "mergedBy": "mkmik",
      "mergeCommit": {
        "oid": "e194dedb81236a93b1a90b23d1addd1e5c596e2d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTI4NTg3",
          "commit": {
            "abbreviatedOid": "9f31389"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T10:41:52Z",
          "updatedAt": "2020-10-28T10:41:52Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think the TODO is addressed by this PR.",
              "createdAt": "2020-10-28T10:41:52Z",
              "updatedAt": "2020-10-28T11:00:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTMxMzcy",
          "commit": {
            "abbreviatedOid": "9f31389"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Maybe delete the TODO since you have provided a good workaround.",
          "createdAt": "2020-10-28T10:45:23Z",
          "updatedAt": "2020-10-28T10:45:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTQyNjY5",
          "commit": {
            "abbreviatedOid": "8e99b89"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T11:00:17Z",
          "updatedAt": "2020-10-28T11:00:18Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "good catch done",
              "createdAt": "2020-10-28T11:00:17Z",
              "updatedAt": "2020-10-28T11:00:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMzU4Mjc0",
      "title": "Convert to markdown",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/40",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "This will be easier to edit and review in PRs.\r\n\r\nThanks to @cabo for translating the XML file to suitable markdown and\r\nfor creating the kramdown-based tooling. Also he fixed the outdated\r\nBCP14 boilerplate.\r\n\r\nFixes https://github.com/jsonpath-standard/internet-draft/issues/39\r\n\r\nSee the [rendered version](https://glyn.github.io/internet-draft/).",
      "createdAt": "2020-11-17T12:04:18Z",
      "updatedAt": "2020-11-18T11:45:30Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "e194dedb81236a93b1a90b23d1addd1e5c596e2d",
      "headRepository": "glyn/internet-draft",
      "headRefName": "kramdown",
      "headRefOid": "ac0bab76a562e01a94a736bd17e54a21c9b405f4",
      "closedAt": "2020-11-18T11:45:26Z",
      "mergedAt": "2020-11-18T11:45:26Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "b84ccaeff55d0c8386b26b5d16a85904d1fd2c58"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMzA5OTM3",
          "commit": {
            "abbreviatedOid": "7a8476b"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-17T12:25:24Z",
          "updatedAt": "2020-11-17T12:25:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI3NTc3Nzk5",
      "title": "Editorial improvements",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/41",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks for feedback from Daniel Parker and Carsten Bormann.",
      "createdAt": "2020-11-25T16:52:26Z",
      "updatedAt": "2020-11-26T16:49:50Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "b84ccaeff55d0c8386b26b5d16a85904d1fd2c58",
      "headRepository": "glyn/internet-draft",
      "headRefName": "editorial-improvements",
      "headRefOid": "658ed7ac1a9504a4d76d68b6bb5cd2927773b021",
      "closedAt": "2020-11-26T16:49:17Z",
      "mergedAt": "2020-11-26T16:49:16Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "113da3f9ea1df449b462467810d3a374159f6e2f"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> Couple questions and a suggestion\r\n\r\nI'd like to merge so that @cabo can proceed to raise PRs which add introductory material from the G\u00f6ssner draft. None of this is set in concrete, so there will be ample opportunities to revisit the text.",
          "createdAt": "2020-11-26T16:27:27Z",
          "updatedAt": "2020-11-26T16:27:27Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@gregsdennis Merged. Let me know if you have outstanding issues and we can address them separately.",
          "createdAt": "2020-11-26T16:49:46Z",
          "updatedAt": "2020-11-26T16:49:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Njk1Nzky",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Quick look...",
          "createdAt": "2020-11-25T17:00:48Z",
          "updatedAt": "2020-11-25T17:01:59Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "You may want to make use of DIGIT and DIGIT1 here",
              "createdAt": "2020-11-25T17:00:49Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            },
            {
              "originalPosition": 31,
              "body": "I think we need to be more aware about saying \"is\" when we mean \"is represented by\".",
              "createdAt": "2020-11-25T17:01:24Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Njk2ODkz",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-25T17:02:08Z",
          "updatedAt": "2020-11-25T17:02:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTMyNTE2",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T09:24:53Z",
          "updatedAt": "2020-11-26T09:24:54Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Actually, I mean \"is\" rather than \"is represented by\". But the phrase \"is a union element consisting of\" is causing a lot of grief. It probably is better to make the array slice description independent of where it is used, thus:\r\n```suggestion\r\nAn array slice consists of optional integers (in base 10) separated by colons.\r\n```",
              "createdAt": "2020-11-26T09:24:54Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTM3MDYw",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T09:30:00Z",
          "updatedAt": "2020-11-26T09:30:00Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Whoops. Of course.",
              "createdAt": "2020-11-26T09:30:00Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTY2OTMw",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:05:06Z",
          "updatedAt": "2020-11-26T10:08:45Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "What was the guidance around using quoted characters vs their hex equivalent?",
              "createdAt": "2020-11-26T10:05:07Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            },
            {
              "originalPosition": 31,
              "body": "Why remove the count here?  Should we specify that it is three integers, each of which may be omitted?",
              "createdAt": "2020-11-26T10:07:19Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            },
            {
              "originalPosition": 41,
              "body": "Does the markdown translation align the `=`?",
              "createdAt": "2020-11-26T10:07:57Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTcwNDM4",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "Couple questions and a suggestion",
          "createdAt": "2020-11-26T10:09:23Z",
          "updatedAt": "2020-11-26T10:09:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTgzMTAy",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:24:56Z",
          "updatedAt": "2020-11-26T10:24:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "That change was based on input from @cabo.",
              "createdAt": "2020-11-26T10:24:56Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTg0MjYz",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:26:21Z",
          "updatedAt": "2020-11-26T10:26:22Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Good point. Added \"three\".",
              "createdAt": "2020-11-26T10:26:21Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTg1NjYw",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:28:03Z",
          "updatedAt": "2020-11-26T10:28:03Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "No. Does that matter?",
              "createdAt": "2020-11-26T10:28:03Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTg4NTUx",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:31:33Z",
          "updatedAt": "2020-11-26T10:31:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Could you link to the input?  Why have both?",
              "createdAt": "2020-11-26T10:31:34Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTg4NzIx",
          "commit": {
            "abbreviatedOid": "85aff3d"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:31:44Z",
          "updatedAt": "2020-11-26T10:31:44Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Typically I see them aligned for readability, but technically, no.",
              "createdAt": "2020-11-26T10:31:44Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTkyNTEw",
          "commit": {
            "abbreviatedOid": "380417d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:36:32Z",
          "updatedAt": "2020-11-26T10:36:32Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I suggest we leave that for now and do a fine-tuning editorial pass later for consistency.",
              "createdAt": "2020-11-26T10:36:32Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MjAwMTIx",
          "commit": {
            "abbreviatedOid": "380417d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-26T10:46:28Z",
          "updatedAt": "2020-11-26T10:46:28Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@cabo's [guidance](https://mailarchive.ietf.org/arch/msg/jsonpath/jip4OCSgTPH1LZYmL1iMCgxFiMk/) was to use hex for ranges and otherwise use quoted characters except where case sensitivity is needed.",
              "createdAt": "2020-11-26T10:46:28Z",
              "updatedAt": "2020-11-26T15:53:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4MjQwMjkw",
      "title": "Add introductory text from draft-goessner",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/42",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Start work on a merge of the two drafts.\r\n",
      "createdAt": "2020-11-26T19:24:31Z",
      "updatedAt": "2020-12-07T11:52:58Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "113da3f9ea1df449b462467810d3a374159f6e2f",
      "headRepository": "cabo/jsonpath-draft-normington",
      "headRefName": "add-intro",
      "headRefOid": "d7022d02a24b5ad6cf86a13359ffbf84056caf1d",
      "closedAt": "2020-12-07T11:52:57Z",
      "mergedAt": "2020-12-07T11:52:57Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "d7022d02a24b5ad6cf86a13359ffbf84056caf1d"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> LGTM. I made one more group of suggestions to remove some periods in a table.\r\n> \r\n> Please could you answer @gregsdennis's blocking comment and then I'll merge.\r\n\r\nWhich one is that?",
          "createdAt": "2020-12-07T11:10:46Z",
          "updatedAt": "2020-12-07T11:10:46Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> > LGTM. I made one more group of suggestions to remove some periods in a table.\r\n> > Please could you answer @gregsdennis's blocking comment and then I'll merge.\r\n> \r\n> Which one is that?\r\n\r\nYou just answered it, thanks.",
          "createdAt": "2020-12-07T11:11:35Z",
          "updatedAt": "2020-12-07T11:11:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMTAxOTg2",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the general direction. I'd like to remove any reference to the mythical \"underlying scripting engine\". I've also suggested some editorial improvements.",
          "createdAt": "2020-11-27T16:56:41Z",
          "updatedAt": "2020-11-30T11:11:33Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Let's aim high:\r\n```suggestion\r\n2007-02-21 {{JSONPath-orig}} and provides a normative definition for it.\r\n```",
              "createdAt": "2020-11-27T16:56:42Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 163,
              "body": "Not convinced output paths are necessary. Is it not simpler to avoid them?",
              "createdAt": "2020-11-27T16:59:24Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 176,
              "body": "```suggestion\r\nA frequently emphasized advantage of XML is the availability of powerful tools to analyse, transform and selectively extract data from XML documents. {{XPath}} is one of these tools.\r\n```",
              "createdAt": "2020-11-27T17:05:03Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 184,
              "body": "```suggestion\r\n  client, so a server can reduce the amount of data in a response,\r\n```",
              "createdAt": "2020-11-27T17:06:37Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 187,
              "body": "```suggestion\r\nSo what does such a tool look like for JSON?\r\n```",
              "createdAt": "2020-11-27T17:07:19Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\nWhen defining a JSONPath, how should expressions look?\r\n```",
              "createdAt": "2020-11-27T17:07:56Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 242,
              "body": "This last sentence is too prescriptive. We should allow the internal behaviour of JSONPath implementations complete freedom. Also, it may be sensible for output paths to prefer bracket notation, but it isn't necessary. How about this instead:\r\n```suggestion\r\nfor paths input to a JSONPath processor.  Bracket\u2013notation is more general than dot-notation and can serve as a canonical form when a JSONPath processor uses JSONPath expressions for internal purposes or as output paths\r\n```",
              "createdAt": "2020-11-30T10:51:07Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 248,
              "body": "We need to avoid dependencies on any kind of underlying scripting language so I'd prefer to avoid this language from the start.",
              "createdAt": "2020-11-30T10:57:30Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 263,
              "body": "```suggestion\r\nHere is a complete overview and a side by side comparison of the JSONPath syntax elements with their XPath counterparts.\r\n```",
              "createdAt": "2020-11-30T10:58:25Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 333,
              "body": "Let's avoid underlying scripting language dependencies here too.",
              "createdAt": "2020-11-30T11:01:47Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 349,
              "body": "I'm not sure that there is much value in keeping the first column given that JSONPath is already established.\r\n\r\nPlease can we make the result descriptions consistently end or not end with a period. I prefer to avoid the period.",
              "createdAt": "2020-11-30T11:03:48Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 343,
              "body": "```suggestion\r\n| `/store//price`        | `$.store..price`                          | the prices of everything in the store.                        |\r\n```",
              "createdAt": "2020-11-30T11:04:07Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 345,
              "body": "Why not more simply:\r\n```suggestion\r\n| `//book[last()]`       | `$..book[(@.length-1)]`<br>`$..book[-1]` | the last book in order.                                      |\r\n```",
              "createdAt": "2020-11-30T11:05:12Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 352,
              "body": "Good. When do we propose to merge terminology? Before or after offering the merged document to the IETF JSONPath Working Group?",
              "createdAt": "2020-11-30T11:08:40Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwOTMxMTc5",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T13:58:23Z",
          "updatedAt": "2020-11-30T13:58:24Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "I'm in two minds. One of the main advantages of targeting the jsonpath specification at describing how an engine produces a sequence of _output paths_ as opposed to a sequence of _values_, is that it actually simplifies discussing about what a \"value\" actually is and removes potential causes of confusion that may arise in case an engine uses a compressed representation of a json tree, e.g. one where repeated subtrees may be actually reused.\r\n",
              "createdAt": "2020-11-30T13:58:23Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTk5MzYw",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T18:54:36Z",
          "updatedAt": "2020-11-30T18:54:36Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Referencing Pointer is good, but I wonder if we can do more. The purposes of the two syntaxes are different.  Pointer is for isolating a single location within a document. Path is a query syntax which pulls multiple locations.",
              "createdAt": "2020-11-30T18:54:36Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjAwNDE5",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-30T18:56:04Z",
          "updatedAt": "2020-11-30T19:08:47Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Why not just use Pointer?  It's specifically designed for isolating a single location, well-defined, and widely supported.",
              "createdAt": "2020-11-30T18:56:04Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 163,
              "body": "To @mkmik's point, defining a \"value\" as also the location from where it was obtained progresses toward defining the duplicates question.",
              "createdAt": "2020-11-30T18:56:13Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 242,
              "body": "Your suggestions still mention \"internal purposes.\"  I think this needs to be left out entirely.  My implementation doesn't use any notation internally; I have a data model.\r\n\r\nThis spec shouldn't concern itself with the internal working of implementations.  It should be more of a functional requirement set.  As long as it gives the expected output, it should be compliant, regardless of how it got there.  (This isn't high school algebra where you have to show your work.)",
              "createdAt": "2020-11-30T19:02:39Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 248,
              "body": "Avoiding the underlying scripting language is good, but it means that we'll have to eventually define what's valid in expressions. (Can of worms, I know.)",
              "createdAt": "2020-11-30T19:04:13Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            },
            {
              "originalPosition": 290,
              "body": "JSON objects are specifically unordered, and many languages simply _can't_ reference them in the serialized sequence (Ruby comes to mind.)  We went over and over this recently in JSON Schema.",
              "createdAt": "2020-11-30T19:06:37Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjU3MjA0",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T20:11:09Z",
          "updatedAt": "2020-11-30T20:11:09Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "The wording her certainly can be improved.  The existing text tries to emphasize that array indices start at 1 in XPath and at 0 in JSONPath, it certainly is not trying to invent numeric indices for maps (JSON objects).\r\n\r\nThanks for a good set of actionable proposals for improvement!  I'll submit an update on Wednesday.",
              "createdAt": "2020-11-30T20:11:09Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NDI0MDE2",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T20:44:36Z",
          "updatedAt": "2020-12-03T20:44:36Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "Now, is that a suggestion or a promise?  I'll redundantly leave both sentences in for now.",
              "createdAt": "2020-12-03T20:44:36Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NDQyNjM0",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T20:57:46Z",
          "updatedAt": "2020-12-03T20:57:47Z",
          "comments": [
            {
              "originalPosition": 352,
              "body": "I think we don't need to have terminology adjusted before proposing the merged document for adoption.  But we can start any discussion we need now.",
              "createdAt": "2020-12-03T20:57:46Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NDQzNjE3",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T20:59:08Z",
          "updatedAt": "2020-12-03T20:59:08Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "I'm not trying to address this in this version yet, so I just added a note.",
              "createdAt": "2020-12-03T20:59:08Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NDQ0MDc1",
          "commit": {
            "abbreviatedOid": "84e62fe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T20:59:45Z",
          "updatedAt": "2020-12-03T20:59:46Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "We could.  There are subtle differences we'd need to elaborate first to do this.",
              "createdAt": "2020-12-03T20:59:45Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NDQ5MTUz",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T21:07:07Z",
          "updatedAt": "2020-12-03T21:07:07Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "Long Wednesday.  Please check my proposed updates.",
              "createdAt": "2020-12-03T21:07:07Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NjY1MDkw",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T05:23:33Z",
          "updatedAt": "2020-12-04T05:23:33Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "But can a well formed JSONPointer identify an empty object or empty array? My understanding of the rules for evaluation in https://tools.ietf.org/html/rfc6901#section-7 is that that is not defined.",
              "createdAt": "2020-12-04T05:23:33Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0Njc0NTM1",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T05:53:22Z",
          "updatedAt": "2020-12-04T05:53:22Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Sure.  For `{ \"a\": {} }`, `/a` points to the empty object.  What in Section 7 makes you think it doesn't?",
              "createdAt": "2020-12-04T05:53:22Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODQ3MTU4",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T10:45:06Z",
          "updatedAt": "2020-12-04T10:45:07Z",
          "comments": [
            {
              "originalPosition": 352,
              "body": "I'd like to get terminology nailed down sooner rather than later, but it doesn't have to be part of this PR.",
              "createdAt": "2020-12-04T10:45:06Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODUxMTMz",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T10:50:10Z",
          "updatedAt": "2020-12-04T10:50:10Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Specifically, JSON Schema uses JSON Pointers in its `$ref` keyword to reference a location within the schema in its JSON form.  Per JSON Schema, the reference MUST resolve to a valid schema object.  However, `{}` is a perfectly valid object.\r\n\r\nThe only time Section 7 applies is when the pointer indicates a route _into_ this object, e.g. `/a/missing` in @cabo's example would be required to error because the value at `/a` doesn't contain a `missing` property.",
              "createdAt": "2020-12-04T10:50:10Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODUxOTIz",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T10:51:13Z",
          "updatedAt": "2020-12-04T10:51:13Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "RFC 6901 goes to lengths to make sure any JSON map key (which essentially is any Unicode string) can be used as a path component.  It decodes that (needing an escape for / and then for the escape), and then looks whether it is looking at an array or a map.  Any maps is directly indexed, while for an array the path component is interpreted as a decimal number (there also is the \"-\" special, which I think we don't need).  The latter is easy.  Doing the former requires having a bracket/string syntax for any Unicode string.",
              "createdAt": "2020-12-04T10:51:13Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODU0MDkx",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T10:54:10Z",
          "updatedAt": "2020-12-04T10:54:11Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "I think specifying \"array indices\" is sufficient here. \ud83d\udc4d ",
              "createdAt": "2020-12-04T10:54:11Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODU1NjU3",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T10:56:18Z",
          "updatedAt": "2020-12-04T10:56:19Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "> `*insert repo here*`\r\n\r\nWas this an unfulfilled todo for this PR, or is it supposed to remain open for now?",
              "createdAt": "2020-12-04T10:56:19Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODU3NjIy",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T10:59:03Z",
          "updatedAt": "2020-12-04T10:59:04Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Maybe just something to consider for the future, but not relevant for this PR, then.",
              "createdAt": "2020-12-04T10:59:03Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODU5MTk3",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T11:01:20Z",
          "updatedAt": "2020-12-04T11:01:21Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "I think the first column is helpful for those familiar with XPath, and helps to coalesce the concepts from the preceding table.",
              "createdAt": "2020-12-04T11:01:20Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODYzMTI2",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T11:07:12Z",
          "updatedAt": "2020-12-04T11:07:13Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Conceded, thanks for the correction.",
              "createdAt": "2020-12-04T11:07:13Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3MDEz",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T11:12:45Z",
          "updatedAt": "2020-12-04T11:12:46Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I've opened #44 for this.",
              "createdAt": "2020-12-04T11:12:45Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY4MzMy",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T11:14:44Z",
          "updatedAt": "2020-12-04T11:14:44Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Opened #44 to discuss whether we need output for the initial draft.  I vote we leave it for now.",
              "createdAt": "2020-12-04T11:14:44Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDQyNTUw",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:04:44Z",
          "updatedAt": "2020-12-07T11:04:46Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "Periods removed:\r\n```suggestion\r\n|------------------------|-------------------------------------------|--------------------------------------------------------------|\r\n| `/store/book/author`   | `$.store.book[*].author`                  | the authors of all books in the store                        |\r\n| `//author`             | `$..author`                               | all authors                                                  |\r\n| `/store/*`             | `$.store.*`                               | all things in store, which are some books and a red bicycle  |\r\n| `/store//price`        | `$.store..price`                          | the prices of everything in the store                        |\r\n| `//book[3]`            | `$..book[2]`                              | the third book                                               |\r\n| `//book[last()]`       | `$..book[(@.length-1)]`<br>`$..book[-1]`  | the last book in order                                       |\r\n| `//book[position()<3]` | `$..book[0,1]`<br>`$..book[:2]`           | the first two books                                          |\r\n| `//book[isbn]`         | `$..book[?(@.isbn)]`                      | filter all books with isbn number                            |\r\n| `//book[price<10]`     | `$..book[?(@.price<10)]`                  | filter all books cheaper than 10                             |\r\n| `//*`                  | `$..*`                                    | all Elements in XML document; all members of JSON data item  |\r\n```",
              "createdAt": "2020-12-07T11:04:44Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDQ0MjI2",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM. I made one more group of suggestions to remove some periods in a table.\r\n\r\nPlease could you answer @gregsdennis's blocking comment and then I'll merge. ",
          "createdAt": "2020-12-07T11:07:04Z",
          "updatedAt": "2020-12-07T11:07:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDQ1NDIy",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:08:41Z",
          "updatedAt": "2020-12-07T11:08:41Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "I already did this, with some more editorial fixes, in https://github.com/jsonpath-standard/internet-draft/pull/42/commits/11adbd2",
              "createdAt": "2020-12-07T11:08:41Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDQ2MDAz",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:09:26Z",
          "updatedAt": "2020-12-07T11:09:27Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "I would put that in when the document is at its final repo.",
              "createdAt": "2020-12-07T11:09:27Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDQ3MTA4",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:10:50Z",
          "updatedAt": "2020-12-07T11:10:50Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Thanks @cabo. That's what I expected.",
              "createdAt": "2020-12-07T11:10:50Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDQ4MDA3",
          "commit": {
            "abbreviatedOid": "11adbd2"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:12:01Z",
          "updatedAt": "2020-12-07T11:12:02Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "Er, I don't see those changes in https://github.com/jsonpath-standard/internet-draft/commit/11adbd2.",
              "createdAt": "2020-12-07T11:12:02Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDYxNDY3",
          "commit": {
            "abbreviatedOid": "884bb0f"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:31:07Z",
          "updatedAt": "2020-12-07T11:31:07Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "Oops.  Fixed in 884bb0f",
              "createdAt": "2020-12-07T11:31:07Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDY3NzY1",
          "commit": {
            "abbreviatedOid": "884bb0f"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:39:58Z",
          "updatedAt": "2020-12-07T11:39:59Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "Thanks. Please could you regenerate too?",
              "createdAt": "2020-12-07T11:39:58Z",
              "updatedAt": "2020-12-07T11:47:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDczNzY5",
          "commit": {
            "abbreviatedOid": "d7022d0"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:48:40Z",
          "updatedAt": "2020-12-07T11:48:40Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "Done.",
              "createdAt": "2020-12-07T11:48:40Z",
              "updatedAt": "2020-12-07T11:48:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4ODE1OTI5",
      "title": "whitespace change - removed unnecessary newlines",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/43",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The contents of the other file formats shouldn't change.  This is a change solely to the ~markdown~ kramdown file.\r\n",
      "createdAt": "2020-11-27T23:58:26Z",
      "updatedAt": "2020-11-28T08:14:44Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "113da3f9ea1df449b462467810d3a374159f6e2f",
      "headRepository": "gregsdennis/internet-draft",
      "headRefName": "master",
      "headRefOid": "b55b08dde2a64142a61a007c647c27447ed0be32",
      "closedAt": "2020-11-28T08:14:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I deliberately adopted the \"new sentence, new line\" style as suggested by @cabo to minimise diffs. Closing.",
          "createdAt": "2020-11-28T08:14:44Z",
          "updatedAt": "2020-11-28T08:14:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMzNjQ0MDgy",
      "title": "Prepare to submit internet draft",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/45",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "See [rendered version](https://glyn.github.io/internet-draft/).",
      "createdAt": "2020-12-07T12:45:17Z",
      "updatedAt": "2020-12-07T14:22:13Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "20cda42240b116b86d6cd31b33c24ceb7ab49e6c",
      "headRepository": "glyn/internet-draft",
      "headRefName": "prepare-submission",
      "headRefOid": "d09357fcf13214d174d437ee9ab41776a09cc6f2",
      "closedAt": "2020-12-07T14:21:56Z",
      "mergedAt": "2020-12-07T14:21:55Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "b7009055311f017ae2ca1a7e1ef5bcc8bdf93832"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging. This PR contains no substantive changes other than to rename the document from -latest to -00.\r\n\r\nSee https://datatracker.ietf.org/doc/draft-normington-jsonpath/.",
          "createdAt": "2020-12-07T14:21:46Z",
          "updatedAt": "2020-12-07T14:21:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MTk0NjAy",
          "commit": {
            "abbreviatedOid": "d09357f"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2020-12-07T14:22:13Z",
          "updatedAt": "2020-12-07T14:22:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMzOTkxODI4",
      "title": "More editorial fixes",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/46",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Daniel Parker's comments\r\nFix ABNF (OK, that is not editorial) and dehexify",
      "createdAt": "2020-12-07T22:36:27Z",
      "updatedAt": "2021-03-03T05:03:37Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "612bd269c3423a24cefc217ff3d6f82d79d60841",
      "headRepository": "cabo/jsonpath-draft-normington",
      "headRefName": "editorial",
      "headRefOid": "5255e7c6b866cdac50dcfd3f0592982d6639525d",
      "closedAt": "2021-03-03T05:03:37Z",
      "mergedAt": "2021-03-03T05:03:37Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "325391e30680ae19830faa214b9eac3069f39025"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I rewrote history after checking with @cabo. HEAD now points at the commit _before_ I renamed to -00. (The renaming is tagged as draft-normington-jsonpath-00.) So this PR should look like a set of changes on the `*-latest.*` files.  ",
          "createdAt": "2020-12-08T17:35:41Z",
          "updatedAt": "2020-12-08T17:36:09Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo The README also needs changing to reflect the new naming scheme `draft-normington-jsonpath.*`.",
          "createdAt": "2020-12-08T17:42:11Z",
          "updatedAt": "2020-12-08T17:42:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzIyNjM1",
          "commit": {
            "abbreviatedOid": "c30593e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Please address my comments and delete -00.md, update the script/README as necessary for the renaming back to -latest, and regenerate (including copying the generated HTML to `docs/` so it is published).",
          "createdAt": "2020-12-08T03:42:25Z",
          "updatedAt": "2020-12-08T03:48:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Is \"the argument\" well defined at this point in the document? It's slightly ambiguous since there are two inputs: the JSONPath itself and the JSON value.\r\n\r\nAlso, I suggest adding a comma, thus: \"Since a JSON data item is anonymous, JSONPath uses...\".\r\n\r\n(Sorry I can't use a github suggestion here as I'm reviewing the commits separately.)",
              "createdAt": "2020-12-08T03:42:26Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            },
            {
              "originalPosition": 4,
              "body": "Should be -latest, for consistency.",
              "createdAt": "2020-12-08T03:45:02Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDY0NzUw",
          "commit": {
            "abbreviatedOid": "acdb54d"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T17:30:25Z",
          "updatedAt": "2020-12-08T17:30:25Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "There is a definition for \"argument\".  Of course, we could introduce this once more in the text, but maybe not here.\r\n(And if you have a better name for the JSON data item under consideration by the JSONPath query, I'm all ears.)",
              "createdAt": "2020-12-08T17:30:25Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDY2NTQ5",
          "commit": {
            "abbreviatedOid": "acdb54d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T17:32:33Z",
          "updatedAt": "2020-12-08T17:32:33Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Oops, missed that definition for some reason. Thanks.",
              "createdAt": "2020-12-08T17:32:33Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDczMTA0",
          "commit": {
            "abbreviatedOid": "420091d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T17:40:26Z",
          "updatedAt": "2020-12-08T17:40:26Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "This script needs reworking to match the new naming scheme `draft-normington-jsonpath.*`.",
              "createdAt": "2020-12-08T17:40:26Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDc5NzYz",
          "commit": {
            "abbreviatedOid": "420091d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "My comments have been or are being addressed. Since I'm away until 16 December, I'm going to abstain and leave it to others to approve/merge. Otherwise, I'll pick this up when I'm back.",
          "createdAt": "2020-12-08T17:48:31Z",
          "updatedAt": "2020-12-08T17:48:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTU1Mjc5",
          "commit": {
            "abbreviatedOid": "753def5"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:21:06Z",
          "updatedAt": "2020-12-08T19:21:07Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Perhaps we should define \"key\" and even declare \"property\" as a synonym.",
              "createdAt": "2020-12-08T19:21:06Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTU2NDU4",
          "commit": {
            "abbreviatedOid": "753def5"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-08T19:22:47Z",
          "updatedAt": "2020-12-08T19:27:07Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Do we want to avoid the use of \"expressions\" here so that it's not confused with query expressions (defined on line 290)?",
              "createdAt": "2020-12-08T19:22:47Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            },
            {
              "originalPosition": 52,
              "body": "\"element\" instead of \"item\" to align with the definition.",
              "createdAt": "2020-12-08T19:24:17Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            },
            {
              "originalPosition": 62,
              "body": "Why do we need \"item\"?  \"Element\" is strictly defined.  Maybe just use that.",
              "createdAt": "2020-12-08T19:25:16Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            },
            {
              "originalPosition": 99,
              "body": "Why are we specifying JSON for objects everywhere?  What other meaning does \"object\" have that warrants this specificity?",
              "createdAt": "2020-12-08T19:26:33Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NjA2NzU0",
          "commit": {
            "abbreviatedOid": "753def5"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T20:33:38Z",
          "updatedAt": "2020-12-08T20:33:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Property is a synonym for member, as is entry and field.\r\nHow many of these synonyms do we need?\r\n(RFC 8259 calls the keys \"names\", which is not better, except maybe in combinations such as \"field name\" or \"member name\".)",
              "createdAt": "2020-12-08T20:33:38Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NjA5Njgy",
          "commit": {
            "abbreviatedOid": "753def5"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T20:38:06Z",
          "updatedAt": "2020-12-08T20:38:07Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "\"key\" and \"property\" are by far the most common terms I see in use.  JSON Schema uses both.  In the specific context of a schema, the term \"keyword\" is used to denote a key that carries functionality.",
              "createdAt": "2020-12-08T20:38:07Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NjEwNDAz",
          "commit": {
            "abbreviatedOid": "753def5"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T20:39:10Z",
          "updatedAt": "2020-12-08T20:39:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "And I've been caught calling keys \"labels\".  Some people like to call them \"tags\".\r\nMy first hit when searching was https://www.w3schools.com/Js/js_json_objects.asp, which you may like or not like (they do confuse JSON objects with their representation), but for them introducing JSON objects as key/value pairs seemed obvious, not needing further explanation.",
              "createdAt": "2020-12-08T20:39:10Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NjY4Mzgz",
          "commit": {
            "abbreviatedOid": "e28d965"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T22:00:40Z",
          "updatedAt": "2020-12-08T22:00:41Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done in e28d965\r\n",
              "createdAt": "2020-12-08T22:00:40Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MDY1NTE3",
          "commit": {
            "abbreviatedOid": "e28d965"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-09T10:57:20Z",
          "updatedAt": "2020-12-09T10:57:20Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "I agree. Also other primitives like number and string are also _JSON_ numbers and _JSON_ strings, (with all the subtleties that come from that, both from spec and underlying json engine implementation choices allowed by the JSON spec)",
              "createdAt": "2020-12-09T10:57:20Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MDcwNjA2",
          "commit": {
            "abbreviatedOid": "e28d965"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-09T11:03:31Z",
          "updatedAt": "2020-12-09T11:03:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Key/value is indeed very common. \"field\" is less common but nevertheless attested in the wild.\r\n\r\nI tend to prefer `field name/value` mainly for two reasons: a) it builds on top of RFC 8259 terminology b) the \"field\" qualifier makes sense also when referring to the value (the _field value_)\r\n",
              "createdAt": "2020-12-09T11:03:31Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTg5NzYz",
          "commit": {
            "abbreviatedOid": "71077ad"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-16T11:20:13Z",
          "updatedAt": "2020-12-16T11:20:14Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Thanks. For the record, I marginally prefer the explicit `-latest` suffix as it looks like a placeholder waiting to be replaced by a version number. But I can certainly live with this alternative.",
              "createdAt": "2020-12-16T11:20:14Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTk1NTkw",
          "commit": {
            "abbreviatedOid": "71077ad"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-16T11:27:52Z",
          "updatedAt": "2020-12-16T11:27:52Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The anchor `#overview` clashes with the default anchor for the _other_ `Overview` section.",
              "createdAt": "2020-12-16T11:27:52Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNjA0OTg4",
          "commit": {
            "abbreviatedOid": "71077ad"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-16T11:41:16Z",
          "updatedAt": "2020-12-16T11:41:16Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Normalized form is not yet well defined. Is it intended to be [canonical](https://en.wikipedia.org/wiki/Canonical_form) too or simply normalized (but not necessarily unique among normalized alternatives)?",
              "createdAt": "2020-12-16T11:41:16Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzOTE4NjI1",
          "commit": {
            "abbreviatedOid": "71077ad"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-16T17:26:41Z",
          "updatedAt": "2020-12-16T17:26:41Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "In the spirit of \"you can't please everyone\", my own opinion from an implementer's perspective is that use of synonyms is best avoided. Implementers want a parsimonious vocabulary with precise meaning, preferably one that's consistent with the core specifications (RFC 8259), the introduction of synonyms which are \"suggestive\" only frightens them. What's suggestive to one is misleading to another, for example, \"field\" in the Java specifications refers to a type and an identifier, in a CODASYL data record it means something else. \"property\" isn't mentioned in RFC 8259, why introduce it here?      \r\n\r\nRegarding \"perhaps we should define 'key'\", if it appears in the ABNF, it _is_ defined. Although again, my own preference would be to stick to the RFC 8259 term \"name\". Agreed, it's not \"better\", but so what? Clarity and consistency with the core specifications should in my opinion be the main concern.",
              "createdAt": "2020-12-16T17:26:41Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDUwODA2",
          "commit": {
            "abbreviatedOid": "eaaca44"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T00:53:01Z",
          "updatedAt": "2021-02-27T00:53:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "It probably would help to keep \"name\" around for names in jsonpath.\r\nBut given that \"key\" is not defined in 8259, I'll stick with \"name\" for now, expanding to \"member name\" when needed.\r\n\r\n",
              "createdAt": "2021-02-27T00:53:01Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDUxMjAy",
          "commit": {
            "abbreviatedOid": "eaaca44"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T00:54:46Z",
          "updatedAt": "2021-02-27T00:54:46Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "This is one of many places that uses \"jsonpath expression\".  We could all rename those into \"query\".  Holding off with that right now.\r\n",
              "createdAt": "2021-02-27T00:54:46Z",
              "updatedAt": "2021-02-27T01:03:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDUxODEz",
          "commit": {
            "abbreviatedOid": "eaaca44"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T00:55:27Z",
          "updatedAt": "2021-02-27T00:55:28Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "The slash is XML/JSON.  Element on the JSON side means something different than element on the XML side.",
              "createdAt": "2021-02-27T00:55:27Z",
              "updatedAt": "2021-02-27T01:03:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDUyNDYw",
          "commit": {
            "abbreviatedOid": "eaaca44"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T00:58:46Z",
          "updatedAt": "2021-02-27T00:58:47Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "I changed them all to object.  I continue to believe this is bad usage, but if the spec is mainly directed at people who work exclusively with JSON, that may be a simplification.",
              "createdAt": "2021-02-27T00:58:47Z",
              "updatedAt": "2021-02-27T01:03:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDUyNzYx",
          "commit": {
            "abbreviatedOid": "eaaca44"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T01:00:16Z",
          "updatedAt": "2021-02-27T01:00:17Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "No, that's why it points to a section that explains in which way this is normalized.",
              "createdAt": "2021-02-27T01:00:16Z",
              "updatedAt": "2021-02-27T01:03:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDU2MzIw",
          "commit": {
            "abbreviatedOid": "5255e7c"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T01:17:33Z",
          "updatedAt": "2021-02-27T01:17:34Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Maybe that distinction could be made clearer (later).",
              "createdAt": "2021-02-27T01:17:34Z",
              "updatedAt": "2021-02-27T01:17:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDU3MzYz",
          "commit": {
            "abbreviatedOid": "5255e7c"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T01:19:34Z",
          "updatedAt": "2021-02-27T01:19:34Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "My feeling is that this is a JSON-related specification, so it's likely to be assumed.  We _could_ add a statement in the declarations at the beginning to the effect of, \"All usages of 'object', etc, mean the JSON usage unless otherwise specified.\"",
              "createdAt": "2021-02-27T01:19:34Z",
              "updatedAt": "2021-02-27T01:19:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDU3NTEw",
          "commit": {
            "abbreviatedOid": "5255e7c"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I'm happy with this as an intermediate state to be merged so that we don't block further development.",
          "createdAt": "2021-02-27T01:20:35Z",
          "updatedAt": "2021-02-27T01:20:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyNTExMTI4",
          "commit": {
            "abbreviatedOid": "5255e7c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Yes, let's merge this to allow forward progress to resume.",
          "createdAt": "2021-03-03T05:03:30Z",
          "updatedAt": "2021-03-03T05:03:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ0NzIyNjU4",
      "title": "Point the draft at the official draft git repo",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/48",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-23T11:18:13Z",
      "updatedAt": "2020-12-24T10:05:27Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "d4c5984cb1e36bc89c752bd0c034e0af54cb7a46",
      "headRepository": "glyn/internet-draft",
      "headRefName": "repo-in-draft",
      "headRefOid": "fe14ddf2f990a86a3eff530a060cd35ced6abe94",
      "closedAt": "2020-12-24T10:05:23Z",
      "mergedAt": "2020-12-24T10:05:23Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "e262f18c0d8bab68ddc710e4839c3e366d88539a"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I think we should move to the Martin Thomson template for repositories soon.\r\nUntil then: Do we really need a copy of the HTML in index.html?",
          "createdAt": "2020-12-23T12:07:41Z",
          "updatedAt": "2020-12-23T12:07:41Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we should move to the Martin Thomson template for repositories soon.\r\n> Until then: Do we really need a copy of the HTML in index.html?\r\n\r\nYes, so we have a convenient rendered version (at https://ietf-wg-jsonpath.github.io/draft-ietf-jsonpath-jsonpath/). github pages is pretty restrictive about where the source is located and if it was in the root directory, it would probably need to be named something like `README.md` which wouldn't fit very well with our file names and generation process. If we can find a solution which avoids a copy and which still offers a rendered version, that would be great. (I tried checking in a symlink, but that didn't end happily!)",
          "createdAt": "2020-12-23T12:16:02Z",
          "updatedAt": "2020-12-23T12:18:18Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo Thanks for approving. I'm going to hold off merging for 24 hours as this is the protocol we've tried to observe in the past so others have a chance to review/comment.",
          "createdAt": "2020-12-23T12:17:23Z",
          "updatedAt": "2020-12-23T12:17:23Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "So where does the current github.io structure leave the topic branch HTMLs?\r\n\r\nBTW, maybe we can avoid making a references entry for the github repo and put the link directly into the note.\r\n",
          "createdAt": "2020-12-23T12:27:23Z",
          "updatedAt": "2020-12-23T12:27:23Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> So where does the current github.io structure leave the topic branch HTMLs?\r\n\r\nHigh and dry, I'm afraid. Topic branches are not served by github pages.\r\n \r\n> BTW, maybe we can avoid making a references entry for the github repo and put the link directly into the note.\r\n\r\nDone.",
          "createdAt": "2020-12-23T13:59:55Z",
          "updatedAt": "2020-12-23T13:59:55Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2020-12-23, at 15:00, Glyn Normington <notifications@github.com> wrote:\n> \n> High and dry, I'm afraid. Topic branches are not served by github pages.\n\nOK, they are with Martin Thomson\u2019s template, e.g. see \n\nhttps://cbor-wg.github.io/CBORbis/edits-from-paul/draft-ietf-cbor-7049bis.html\n\nfor a random example.  This also shows a much better usage of index.html:\n\nhttps://cbor-wg.github.io/CBORbis/\n\nThe only reason I haven\u2019t sent a PR with Martin\u2019s template that I haven\u2019t figured out the new black for CI (github actions).  But we don\u2019t have CI now either, so maybe we should start with the template and put in CI when we have figured it out (until then it\u2019s `make; git push --all`).\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2020-12-23T14:19:39Z",
          "updatedAt": "2020-12-23T14:19:39Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo Martin's template looks great if we are comfortable giving contributors write access to their own branches in this repo (rather than have them use their own forks). I suggest we get PR 46 merged first so we don't lose track of the outstanding comment threads, then apply Martin's template, and then add CI.\r\n",
          "createdAt": "2020-12-23T15:43:02Z",
          "updatedAt": "2020-12-23T15:43:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3ODExMzAw",
          "commit": {
            "abbreviatedOid": "251a0e6"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T11:28:10Z",
          "updatedAt": "2020-12-23T11:28:10Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "This change, to trim trailing whitespace, was made courtesy of `.editorconfig`.",
              "createdAt": "2020-12-23T11:28:10Z",
              "updatedAt": "2020-12-23T13:56:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3ODI4NDU1",
          "commit": {
            "abbreviatedOid": "251a0e6"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-23T12:06:47Z",
          "updatedAt": "2020-12-23T12:06:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYwMjUyNTU5",
      "title": "Rename to draft-ietf-jsonpath-base",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/51",
      "state": "MERGED",
      "author": "mkmik",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Updated year\r\n* Updated Marko's affiliation\r\n* Pin versions in Dockerfiles in order to limit unrelated diffs in PRs\r\n\r\nPreview visible at: https://mkmik.github.io/internet-draft/",
      "createdAt": "2021-01-22T22:49:05Z",
      "updatedAt": "2021-06-15T08:43:34Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "2330473a11f68072100b9c9c337a85b8abe41574",
      "headRepository": "mkmik/internet-draft",
      "headRefName": "rename",
      "headRefOid": "8d2d5e9b1945f6ca75f1da4b2414fe0be60a6c58",
      "closedAt": "2021-01-23T07:08:44Z",
      "mergedAt": "2021-01-23T07:08:44Z",
      "mergedBy": "mkmik",
      "mergeCommit": {
        "oid": "612bd269c3423a24cefc217ff3d6f82d79d60841"
      },
      "comments": [
        {
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> Question: what's all the base64 in the generated XML?\r\n\r\nThe markdown source (compressed) out of which the xml file is generated.",
          "createdAt": "2021-01-23T06:45:56Z",
          "updatedAt": "2021-01-23T06:45:56Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\r\n> Question: what's all the base64 in the generated XML?\r\n\r\nThe markdown source, as that cannot be submitted to the datatracker yet.\r\n",
          "createdAt": "2021-06-15T08:43:34Z",
          "updatedAt": "2021-06-15T08:43:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzM2MzU3",
          "commit": {
            "abbreviatedOid": "8d2d5e9"
          },
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "First time I've looked at this particular flavor of PR, but generally LGTM.\r\n\r\nQuestion: what's all the base64 in the generated XML?",
          "createdAt": "2021-01-23T04:57:12Z",
          "updatedAt": "2021-01-23T04:57:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzQyMDgw",
          "commit": {
            "abbreviatedOid": "8d2d5e9"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Cannot say a lot here. Seems to be consistent and ok.",
          "createdAt": "2021-01-23T06:54:04Z",
          "updatedAt": "2021-01-23T06:54:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0ODM3NTYw",
          "commit": {
            "abbreviatedOid": "8d2d5e9"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM, thanks.",
          "createdAt": "2021-01-23T10:29:32Z",
          "updatedAt": "2021-01-23T10:29:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkyMzY1MzIw",
      "title": "Align (and simplify) terminology.",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/72",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I created a pull request so we have something concrete to discuss to close #66.",
      "createdAt": "2021-03-13T13:46:56Z",
      "updatedAt": "2021-03-23T15:46:55Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "503dc8962045e7b58378ef7544f8f6f3ad25cbd2",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "terminology",
      "headRefOid": "ff05a2af83cff52203a6777ba61ff7ce9b46fa1e",
      "closedAt": "2021-03-23T15:46:09Z",
      "mergedAt": "2021-03-23T15:46:09Z",
      "mergedBy": "goessner",
      "mergeCommit": {
        "oid": "56dc1c536db170631f8c016ccd796c5349f0e341"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjEyNTI1",
          "commit": {
            "abbreviatedOid": "bcae42d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-13T17:00:30Z",
          "updatedAt": "2021-03-13T17:00:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  or nested within the JSON data item to which the query is applied.\r\n```",
              "createdAt": "2021-03-13T17:00:30Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjEyNjIw",
          "commit": {
            "abbreviatedOid": "bcae42d"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-13T17:01:54Z",
          "updatedAt": "2021-03-13T17:01:55Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Negative indices are also used in the spec., but maybe these will always be referred to as \"slice bounds\" which are then normalised to unsigned indices.",
              "createdAt": "2021-03-13T17:01:55Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjEyODI4",
          "commit": {
            "abbreviatedOid": "5cbe1a8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-13T17:04:43Z",
          "updatedAt": "2021-03-13T17:04:43Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "OK, we'll need to differentiate between the index as in \"zero-based ordinal number of element in array\" and the index as in \"expression value supplied to indexing operation\".  That bothered me already about the existing text.",
              "createdAt": "2021-03-13T17:04:43Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjE0ODgw",
          "commit": {
            "abbreviatedOid": "bcae42d"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-13T17:32:18Z",
          "updatedAt": "2021-03-13T17:32:18Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Much better now ... Index definition is the real location and might not be confused with slice expression syntax.",
              "createdAt": "2021-03-13T17:32:18Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjE1MTMz",
          "commit": {
            "abbreviatedOid": "bcae42d"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-13T17:36:23Z",
          "updatedAt": "2021-03-13T17:36:23Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "`FUNCTION Normalize(i)` should have `len` consistently as second argument, i.e. `FUNCTION Normalize(i,len)` ...",
              "createdAt": "2021-03-13T17:36:23Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjE2MDU2",
          "commit": {
            "abbreviatedOid": "5cbe1a8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-13T17:50:06Z",
          "updatedAt": "2021-03-13T17:50:06Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Good catch; I have put the fix for Normalize into a separate PR #73 ",
              "createdAt": "2021-03-13T17:50:06Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzNjMxMTQ5",
          "commit": {
            "abbreviatedOid": "5cbe1a8"
          },
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think in an ideal world, it would be good to use only and exactly the 8259 terminology. \"Value\", \"JSON Text\", \"Array\", \"Object\".  The latest draft isn't fresh enough in my mind to have an opinion as to whether this is possible. ",
          "createdAt": "2021-03-16T19:10:49Z",
          "updatedAt": "2021-03-16T19:10:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE0Mzc5NjM0",
          "commit": {
            "abbreviatedOid": "5cbe1a8"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-17T14:31:50Z",
          "updatedAt": "2021-03-17T14:31:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjI3MzEy",
          "commit": {
            "abbreviatedOid": "5cbe1a8"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-13T19:45:10Z",
          "updatedAt": "2021-03-17T18:34:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Was this intended as a continuation of the previous sentence? It's not a sentence unto itself.",
              "createdAt": "2021-03-13T19:45:10Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            },
            {
              "originalPosition": 25,
              "body": "\"Non-negative\" instead of \"unsigned?\"  \"Unsigned\" implies the mechanism by which the number is stored in memory (leading bit contains sign and the rest contains the value), but \"non-negative\" directly speaks to the number without the relation to its storage.",
              "createdAt": "2021-03-13T19:48:56Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            },
            {
              "originalPosition": 48,
              "body": "We'll need to define this eventually.  Not sure removing it is correct for this PR.",
              "createdAt": "2021-03-13T19:51:36Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            },
            {
              "originalPosition": 36,
              "body": "Please see my [comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/60#issuecomment-801313287).  Also @danielaparker's [comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/74#issuecomment-801142162) regarding \"JSON in, JSON out.\"",
              "createdAt": "2021-03-17T18:33:51Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE0NjgxOTAw",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-17T18:56:53Z",
          "updatedAt": "2021-03-17T18:56:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "It is indeed not a sentence.",
              "createdAt": "2021-03-17T18:56:53Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE0NjgyNzUw",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-17T18:57:53Z",
          "updatedAt": "2021-03-17T18:57:53Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I disagree.  I prefer the simpler term.  Would like to hear from others whether they also want to fall back to \"non-negative\".",
              "createdAt": "2021-03-17T18:57:53Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE0NjgzNzM2",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-17T18:59:01Z",
          "updatedAt": "2021-03-17T18:59:01Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I don't think we need to define the term.  We already have one form of normalization in the document, the normalization that creates output paths is just another normalization.",
              "createdAt": "2021-03-17T18:59:01Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE0Njg0ODMz",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-17T19:00:18Z",
          "updatedAt": "2021-03-17T19:00:19Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I have reread both comments now.\r\n",
              "createdAt": "2021-03-17T19:00:19Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1MDU1OTY3",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T07:40:21Z",
          "updatedAt": "2021-03-18T07:40:21Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Yeah, so my point of having you reread those comments was to illustrate my discomfort with the \"nodelist\" concept.  You have neither refuted those comments nor changed the PR, so this remains unresolved.",
              "createdAt": "2021-03-18T07:40:21Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1MDU2NDg3",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T07:41:07Z",
          "updatedAt": "2021-03-18T07:41:07Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Where is that definition? Would it not make sense to define it in... the definitions section?",
              "createdAt": "2021-03-18T07:41:07Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1Mjg4Njc0",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T11:47:45Z",
          "updatedAt": "2021-03-18T11:47:46Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Some discussion about nodelist has happened.  Right now, the discussion in this WG is a bit fragmented; I'll try to dig this out when I have time to search for it.  Should have pointed to it in the first place...",
              "createdAt": "2021-03-18T11:47:45Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1Mjg5OTQ5",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T11:49:17Z",
          "updatedAt": "2021-03-18T11:49:18Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "The normalization we already have is in Section 3.6.2.4 (it is not about output paths, btw.)\r\nI don't think that needs to be in the definitions, as it is local to that section.  That would probably also be the case when text about the normalization is written that leads to Output Paths.",
              "createdAt": "2021-03-18T11:49:18Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1MzU5Mjc3",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T13:05:19Z",
          "updatedAt": "2021-03-18T13:05:19Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Just to note, I share with @gregsdennis some discomfort with the \"nodelist\" concept, and am skeptical that it's needed to describe JSONPath. I don't think the idea of a \"nodelist\" is required to describe the distinguishing feature of JSONPath, that it returns a collection of values (or references) to items that already exist in the original JSON document. We have from the [very beginning](https://goessner.net/articles/JsonPath/) the notion that \"the return value of jsonPath is an array, which is also a valid JSON structure. So you might want to apply jsonPath to the resulting structure\". Practically all implementations support something like:\r\n```\r\nJSON = jsonPath(JSON, path, value option)    \r\n```\r\nor \r\n```\r\nJSON = jsonPath(JSON, path, path option)\r\n```\r\nWith duplicates allowed, which is the case for legacy implementations, the computational model is simply to collect values (or their associated paths). Where is the role for \"nodelists\"?\r\n\r\nWith no duplicates, which is the case for some modern implementations, the computational model is to compute both values and their associated (normalized) paths, and to keep path-value pairs with unique paths. Again, where is the role for \"nodelists\"?\r\n\r\nIn XPath, with it's vastly more complicated data model, I understand the need for \"nodelist\". But I don't understand why we need to take this XPath idea and transpose it to JSONPath. It seems to me to be an unnecessary concept for describing JSONPath.\r\n\r\nI would also suggest that the draft  isn't clear about what it means by \"node\". In a discussion in the terminology issue, @glyn suggested that if I wasn't familiar with trees and nodes, I could consult Wikipedia. But what's important is not what I understand or don't understand, what's important is what the draft says. In XPath specifications, the meaning of \"node\" is crystal clear, in the draft, it is not. I think that lack of clarity is somewhat related to the problem of making an argument for the \"nodelist\" concept that readers such as myself might find convincing.\r\n\r\nI think there should be an issue raised for \"nodelist, and the justification thereof\".  Perhaps @cabo could start one?\r\n",
              "createdAt": "2021-03-18T13:05:19Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1NjcwMjc2",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T17:17:47Z",
          "updatedAt": "2021-03-18T17:17:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I prefer non-negative for the reason @gregsdennis gave.",
              "createdAt": "2021-03-18T17:17:47Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1Njc0MzY3",
          "commit": {
            "abbreviatedOid": "dcf5b53"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I left a comment or two, but am generally comfortable with these changes.",
          "createdAt": "2021-03-18T17:21:51Z",
          "updatedAt": "2021-03-18T17:21:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDkzMzMy",
          "commit": {
            "abbreviatedOid": "91a8cc1"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T01:22:38Z",
          "updatedAt": "2021-03-22T01:22:38Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I changed this as requested.",
              "createdAt": "2021-03-22T01:22:38Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3Mjg4MTgw",
          "commit": {
            "abbreviatedOid": "91a8cc1"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T09:11:40Z",
          "updatedAt": "2021-03-22T09:11:40Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "My first reaction has been in favor of \"unsigned\". But @gregsdennis' \"storage related\" argument definitly is a point for \"non-negative\" ... agreed.",
              "createdAt": "2021-03-22T09:11:40Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzUwMTMy",
          "commit": {
            "abbreviatedOid": "91a8cc1"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:14:54Z",
          "updatedAt": "2021-03-22T10:14:54Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Actually, I made this change because I don't really care too much, but I don't agree with it at all.\r\n\r\nPeople are using unsigned type because they care about the application data type (which is unsigned), only rarely because the bits are then laid out in a specific way.\r\n\r\nThere is a long history of computer languages struggling with naming unsigned types.  FORTRAN only had INTEGER, which was signed.  In the 1970s, languages started to address the issue, but didn't find terminology that they could use from mathematics.  \"Natural\" is both (1..) and (0..) in common usage, so it is ambiguous.  A number of languages used \"Cardinal\" for unsigned integers.  C led the pack with going for \"unsigned\", and that is the term that has stuck.  But, incredibly, as late as the mid 1990s languages were designed that didn't have unsigned types (e.g., Java).\r\n\r\nTo me, requiring the clumsy term \"non-negative\" for unsigned is a bit like requiring to say \"octet\" for byte, except that the latter was actually a reasonable thing until about 1981 (when non-8-bit bytes became extinct).\r\n\r\nAnyway, I'm not arguing for using \"unsigned\" in this PR, because I want to make progress, but, for the record, that's what it *should* be.",
              "createdAt": "2021-03-22T10:14:54Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzkxNDcw",
          "commit": {
            "abbreviatedOid": "91a8cc1"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T11:01:18Z",
          "updatedAt": "2021-03-22T11:01:19Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@cabo I appreciate your flexibility.\r\n\r\nA couple of things bothered me about using \"unsigned\":\r\n* In JSONPath we are dealing with integers represented as strings rather than values of a numeric type.\r\n* If we (and I hope we don't!) allowed indices such as \"-0\" and \"+5\", it would seem strange to describe these as \"unsigned\".",
              "createdAt": "2021-03-22T11:01:18Z",
              "updatedAt": "2021-03-22T12:17:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3NDc5Nzg5",
          "commit": {
            "abbreviatedOid": "ff05a2a"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T12:48:36Z",
          "updatedAt": "2021-03-22T12:48:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@cabo I enjoyed your entertaining nostalgic review of integer types.\r\n\r\n@glyn I am not aware of the fact, that in JSONPath we are dealing with integers represented as strings exclusively.",
              "createdAt": "2021-03-22T12:48:36Z",
              "updatedAt": "2021-03-22T12:48:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3NDg0NTg0",
          "commit": {
            "abbreviatedOid": "ff05a2a"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T12:53:42Z",
          "updatedAt": "2021-03-22T12:53:42Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "We have two kinds of integers:\r\n\r\n1. those coming from the JSON data item.  These are no longer in text form when we get to them; they are true numbers (not necessarily type-annotated to be integers).\r\n2. those written in the JSONPath query.  I would expect that our processing model parses that query and feeds an AST to the process that already has true integers etc. as well.  But we haven't fully defined the processing model, so that is next.\r\n",
              "createdAt": "2021-03-22T12:53:42Z",
              "updatedAt": "2021-03-22T12:54:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3NDg5ODI5",
          "commit": {
            "abbreviatedOid": "ff05a2a"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-22T12:59:18Z",
          "updatedAt": "2021-03-22T12:59:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3NzQ1NTc5",
          "commit": {
            "abbreviatedOid": "ff05a2a"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-22T16:39:21Z",
          "updatedAt": "2021-03-22T16:39:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4NzU5ODA0",
          "commit": {
            "abbreviatedOid": "ff05a2a"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T15:46:55Z",
          "updatedAt": "2021-03-23T15:46:55Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "(I moved nodelist over to a new PR that I'm preparing.)",
              "createdAt": "2021-03-23T15:46:55Z",
              "updatedAt": "2021-03-23T15:46:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkyMzk5ODc1",
      "title": "Use second parameter, len, of Normalize throughout",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/73",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/pull/72#discussion_r593778729",
      "createdAt": "2021-03-13T17:49:18Z",
      "updatedAt": "2021-03-27T15:56:37Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "56dc1c536db170631f8c016ccd796c5349f0e341",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "normalize-fix",
      "headRefOid": "7460193d63726e43992892a466c46699e627e949",
      "closedAt": "2021-03-25T07:01:46Z",
      "mergedAt": "2021-03-25T07:01:46Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "be226f10a48856c7a1721387a76dfb7cb377e039"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's get this merged as it really is uncontroversial.",
          "createdAt": "2021-03-25T07:01:42Z",
          "updatedAt": "2021-03-25T07:01:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNjY4MjA0",
          "commit": {
            "abbreviatedOid": "371cf85"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-14T07:48:19Z",
          "updatedAt": "2021-03-14T07:48:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk2NTAzOTAx",
      "title": "WIP: allow relative paths",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/75",
      "state": "CLOSED",
      "author": "bettio",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "*Draft not yet ready for merge or complete*\r\nSee also GH #59 ",
      "createdAt": "2021-03-19T12:12:14Z",
      "updatedAt": "2021-07-29T09:52:16Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "be226f10a48856c7a1721387a76dfb7cb377e039",
      "headRepository": "bettio/draft-ietf-jsonpath-jsonpath",
      "headRefName": "allow-relative-paths",
      "headRefOid": "dc74b539c4eb1d664b6b9d89d3b573661a1cd899",
      "closedAt": "2021-07-29T09:52:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bettio",
          "authorAssociation": "NONE",
          "body": "As a summary I'm aiming to address with this PR: \r\n- [x] allowing `@` at the beginning of an expression\r\n- [x] `@` at the beginning of an expression defaults to document root\r\n- [x] `@` at the beginning of an expression can be != `$` on certain use-cases\r\n\r\nI'm not addressing:\r\n- [ ] `@` scoping\r\n- [ ]  complete description / formalization of `@`",
          "createdAt": "2021-03-21T21:29:11Z",
          "updatedAt": "2021-03-21T21:29:17Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@bettio wrote:\r\n\r\n> As a summary I'm aiming to address with this PR:\r\n> \r\n> * [x]  allowing `@` at the beginning of an expression\r\n> * [x]  `@` at the beginning of an expression defaults to document root\r\n> * [x]  `@` at the beginning of an expression can be != `$` on certain use-cases\r\n> \r\nFair enough, it can be left open what the current node is initialized to, I have no objection.\r\n\r\nDaniel ",
          "createdAt": "2021-03-21T22:07:10Z",
          "updatedAt": "2021-03-21T22:07:10Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@bettio What are your plans for this PR? Thanks.",
          "createdAt": "2021-07-06T08:49:57Z",
          "updatedAt": "2021-07-06T08:49:57Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as there was no response. Please re-open if you would like to continue working on this PR.",
          "createdAt": "2021-07-29T09:52:16Z",
          "updatedAt": "2021-07-29T09:52:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2MzY5NzYx",
          "commit": {
            "abbreviatedOid": "c6423d8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T12:56:32Z",
          "updatedAt": "2021-03-19T12:56:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This doesn't say what a current item selector actually selects.\r\n(The other text also needs to be fixed, for which I'll probably generate a separate PR.)",
              "createdAt": "2021-03-19T12:56:32Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NDAzODMy",
          "commit": {
            "abbreviatedOid": "c6423d8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T13:33:38Z",
          "updatedAt": "2021-03-19T13:33:39Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'm not sure whether it makes sense to start a JSONPath with a current item selector as this is not \"in the middle of\" an array selection, for example, so what would the current item even mean?\r\n\r\nAlso, is there a consensus among existing implementations to support such a thing?",
              "createdAt": "2021-03-19T13:33:39Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NDg2MzI4",
          "commit": {
            "abbreviatedOid": "c6423d8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T14:51:22Z",
          "updatedAt": "2021-03-19T14:51:23Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Right, the ABNF currently does not discuss nested queries, so there is no place where this could dock with.",
              "createdAt": "2021-03-19T14:51:22Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NTcwMzUy",
          "commit": {
            "abbreviatedOid": "c6423d8"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T16:13:24Z",
          "updatedAt": "2021-03-19T16:13:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Thanks for your early feedback, remeber that it is still a draft / WIP.\r\nIt is not complete and it might contain typos and other mistakes.",
              "createdAt": "2021-03-19T16:13:24Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NTg3MTI2",
          "commit": {
            "abbreviatedOid": "c6423d8"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T16:30:32Z",
          "updatedAt": "2021-03-19T16:30:33Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> I'm not sure whether it makes sense to start a JSONPath with a current item selector as this is not \"in the middle of\" an array selection, for example, so what would the current item even mean?\r\n\r\nTL;DR: it is the item set when calling the JSONPath evaluator, it is quite useful if we are going to embed/use JSONPath with advanced tooling.  \r\n\r\nAnyway please take a look to the following comments that explains that with further details:\r\nhttps://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-797212814\r\nhttps://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-797116919\r\n\r\nAlso supporting `@` for all JSONPaths has the good side effect of simplifying grammar when defining filter expressions (no special cases). \r\n\r\n> Also, is there a consensus among existing implementations to support such a thing?\r\n\r\nJayway supports that, which is an influential implementation (I think we should consider some kind of weighted consensus) and I wish to support this also on my implementation [ExJSONPath](https://github.com/ispirata/exjsonpath/).\r\n\r\nTBH I didn't check this for all existing implementations, so further implementations supporting this syntax might exist.  \r\n\r\n@glyn: Please, may you take a look to #59 that has all the information you are looking for. ",
              "createdAt": "2021-03-19T16:30:32Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NjI0NzU5",
          "commit": {
            "abbreviatedOid": "c6423d8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T17:10:58Z",
          "updatedAt": "2021-03-19T17:10:58Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Thanks. I've been following the discussion in https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59 and so far I haven't seen a compelling need for this feature. It seems to increase the surface area of the spec in a way which, as @timbray mentioned, isn't compatible with our charter.",
              "createdAt": "2021-03-19T17:10:58Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NjM5MTgz",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T17:27:07Z",
          "updatedAt": "2021-03-19T17:27:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Actually it removes the need for any special case when using filters, since we may allow any jsonpath expression, simplifying grammar and existing implementations.\r\nAlso it has a XPath equivalent (which exists for good reasons), so we aren't introducing anything new here (I just added to this PR an example for it).",
              "createdAt": "2021-03-19T17:27:07Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NjQzMTA1",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T17:31:43Z",
          "updatedAt": "2021-03-19T17:31:44Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "What happens when a child node is used as the current item and the current item selector is being used inside a filter expression? I presume the current (e.g. array) item \"wins\", but currently the PR doesn't say.",
              "createdAt": "2021-03-19T17:31:43Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NjQ1OTI4",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T17:35:00Z",
          "updatedAt": "2021-03-19T17:35:01Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "The same that happens when doing `$a[?(@.b[?(@.c == \"foo\")])]` (that means we need to push a new current item every time a filter expression is used).\r\nThis need to be explained with or without this PR in the filter section.",
              "createdAt": "2021-03-19T17:35:01Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NzAwMTg3",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T18:43:25Z",
          "updatedAt": "2021-03-19T18:43:25Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@glyn if you still don't agree about the whole PR I wish to discuss this on #59, otherwise if you agree with the proposed change but you wish to address any specific change contained here we can keep discussing here.\r\nI rather like using this PR to discuss the changes not the concept.\r\nSo let me know if you still have any argument against this, and if you are still worried about increasing the surface area of the spec.",
              "createdAt": "2021-03-19T18:43:25Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NzA0NjQ3",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T18:49:48Z",
          "updatedAt": "2021-03-19T18:49:49Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@cabo let me know if the changes to this paragraph are now ok for you. Also let me know if you have any further advice, otherwise I feel like we can resolve this conversation.",
              "createdAt": "2021-03-19T18:49:49Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2NzQ0OTYw",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T19:49:37Z",
          "updatedAt": "2021-03-19T19:49:37Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I think it might be helpful to introduce (and define) the idea of scope here.  Otherwise we should restrict against nested filter queries.",
              "createdAt": "2021-03-19T19:49:37Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2ODkwNDEx",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-20T07:07:37Z",
          "updatedAt": "2021-03-20T07:07:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@bettio Done: https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-803263672",
              "createdAt": "2021-03-20T07:07:37Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2OTc1Mzcx",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T01:42:25Z",
          "updatedAt": "2021-03-21T01:42:26Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> I'm not sure whether it makes sense to start a JSONPath with a current item selector as this is not \"in the middle of\" an array selection, for example, so what would the current item even mean?\r\n> \r\nThe \"current node\" would mean the same thing as it means [in JMESPath](https://jmespath.org/specification.html#current-node), where it is clearly defined. At the start of JSONPath evaluation, it is the JSON document itself, what else could it be? As the expression is evaluated, the value that the current node represents changes to reflect the node currently being evaluated.  Given an `?(<expr>)` within `[]`, the processing model requires an iteration over the elements of the then current item (say an array); the expression following the \"?\" is evaluated with each of those elements, and an `@` appearing in that expression is substituted for with those elements.\r\n\r\nIn other words, at the start of JSONPath evaluation, `$` and `@` represent the same node. As evaluation proceeds, `$` stays the same, but `@` changes to reflect the node being evaluated.",
              "createdAt": "2021-03-21T01:42:25Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2OTg1MzE4",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T05:51:28Z",
          "updatedAt": "2021-03-21T05:51:28Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> ... but @ changes to reflect the node being evaluated.\n\n\"... but `@` changes to reflect the _current scope_.",
              "createdAt": "2021-03-21T05:51:28Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2OTkzODg2",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T08:19:44Z",
          "updatedAt": "2021-03-21T08:19:44Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> The \"current node\" would mean the same thing as it means [in JMESPath](https://jmespath.org/specification.html#current-node), where it is clearly defined. At the start of JSONPath evaluation, it is the JSON document itself, what else could it be?\r\n\r\nThat seems to contradict the wording of this PR:\r\n> The current item selector `@` when used outside a filter behaves as the document\r\nroot selector unless a child node is given to the evaluator.\r\nWhen a child node is used as current item, evaluator must select it as starting\r\nnode instead of the document root when an expression starting with `@` is\r\nevaluated.",
              "createdAt": "2021-03-21T08:19:44Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDA0ODY3",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T10:35:05Z",
          "updatedAt": "2021-03-21T10:35:06Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'll make an example for the benefit of this conversation, I rather discuss any disagreement comment about this feature on issue #59, so we just keep the conversation about pros/cons in just one place, and here we can just discuss the wording for what we decide at #59.\r\n\r\nLet's assume the following eval function:\r\n```\r\njson_path_eval(document_root, path)\r\n```\r\n\r\nthis implementation will always eval `@.foo` in the same way as `$.foo` as kindly mentioned by @danielaparker in previous comment.\r\n\r\nany implementation might also augment the API by adding an additional (optional) parameter (an overload, or whatever the language supports):\r\n```\r\njson_path_eval(document_root, current_item, path)\r\n```\r\n\r\ntherefore `@.foo` evals to `current_item.foo`, while `$.foo` evals to `document_root.foo` (an example is provided [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-797116919) ).\r\n\r\nIt is up to the API user to decide to use current_item instead of the document root (@gregsdennis explained it well [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-797212814) ).\r\n\r\nClearly we shouldn't describe the json_path_eval API in our draft (the API is clearly implementation specific).\r\nWe just describe the syntax (which is already supported by a number of implementations) and we formalize that a child node can be optionally provided, and in that situation \"When a child node is used as current item, evaluator must select it as starting node instead of the document root when an expression starting with @ is evaluated.\".\r\n\r\nWhen a current item/an explicit starting scope is not provided, \"The current item selector @ when used outside a filter behaves as the document root selector\"\r\n\r\nAn implementation that doesn't care can safely just assume that `@` = `$` unless when current scope is changed by filters.\r\n\r\nThis wording should enable tooling as described in #59.\r\n\r\nLet me know if you have any advice about how to improve wording so we make sure that the behavior described in #59 is accurately described, in case there are no further objections about the wording let's resolve this conversation.\r\n",
              "createdAt": "2021-03-21T10:35:06Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDA1MjM0",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T10:39:40Z",
          "updatedAt": "2021-03-21T10:39:41Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "@gregsdennis: do you think we need to introduce the idea of scope right now, or just wait the filters PR?",
              "createdAt": "2021-03-21T10:39:40Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDEyMTQ4",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T12:00:45Z",
          "updatedAt": "2021-03-21T12:00:46Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I would assume that nested filter queries are out for right now.  There's some discussions [somewhere in the comments on another issue](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/17#issuecomment-698757622) regarding nested filters.  For now this just adds the syntax.  I think it'd better to bring in scope when we start defining filters.  Then we can start looking at the syntax behavior a bit more.",
              "createdAt": "2021-03-21T12:00:45Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDIxMzYz",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T13:38:26Z",
          "updatedAt": "2021-03-21T13:38:26Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> > The \"current node\" would mean the same thing as it means [in JMESPath](https://jmespath.org/specification.html#current-node), where it is clearly defined. At the start of JSONPath evaluation, it is the JSON document itself, what else could it be?\r\n> \r\n> That seems to contradict the wording of this PR:\r\n>\r\n\r\nI agree :-) And I prefer the [JMESPath specification wording](https://jmespath.org/specification.html#current-node). In the JMESPath wording, there is no \"if it's used outside the filter it means this\" or \"if it's used inside the filter it means that\". There is just one consistent meaning for the \"current-node\", represented by `@`, it means the node currently being evaluated.\r\n\r\nThe original [JSONPath article](https://goessner.net/articles/JsonPath/) doesn't say much about the current node, it uses `@` to represent it (referred to as \"current object\"),  and gives two examples:\r\n\r\n```\r\n$.store.book[(@.length-1)].title                   (1)\r\n\r\n$.store.book[?(@.price < 10)].title               (2)\r\n```\r\nBoth of those examples are fully consistent with the JMESPath wording. In (1), the \"current node\" @ represents the array `$.store.book`, in (2), the `?` connotes iteration over the array, and `@` represents the array element.\r\n\r\nIt's easy to generalize that at `$`, the current node `@` represents '$', at `$.store`, it represents `$.store`, and so on.",
              "createdAt": "2021-03-21T13:38:26Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDIxODk1",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T13:43:41Z",
          "updatedAt": "2021-03-21T13:43:42Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> > ... but @ changes to reflect the node being evaluated.\r\n> \r\n> \"... but `@` changes to reflect the _current scope_.\r\n\r\nSee my reply to Glyn. I prefer the [JMESPath specification wording](https://jmespath.org/specification.html#current-node), which is very clear, and completely justifies paths that start with `@`.  Also see [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-803618374) for more elaboration.  ",
              "createdAt": "2021-03-21T13:43:41Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDIyOTE0",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T13:54:28Z",
          "updatedAt": "2021-03-21T13:54:29Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Added a reminder [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/17#issuecomment-803584276), I'm resolving this conversation.",
              "createdAt": "2021-03-21T13:54:29Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDUyNDU4",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T19:18:23Z",
          "updatedAt": "2021-03-21T19:18:24Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@danielaparker: does replacing\r\n\r\n> The current item selector `@` when used outside a filter behaves as the document root selector unless a child node is given to the evaluator.\r\n\r\nwith\r\n\r\n> The current item selector `@` can be used to represent the current node being evaluated. The initial current node defaults to the document root unless a child node is given to the evaluator as initial current node.\r\n\r\nlooks better to you?\r\n\r\nMaybe another phrasing might be:\r\n\r\n\r\n> The current item selector `@` can be used to represent the current node being evaluated. The initial current node defaults to the document root unless a different node is chosen.",
              "createdAt": "2021-03-21T19:18:24Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDUzMDk2",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T19:26:16Z",
          "updatedAt": "2021-03-21T19:26:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think I might also replace:\r\n\r\n>When a child node is used as current item, evaluator must select it as starting\r\nnode instead of the document root when an expression starting with `@` is\r\nevaluated.\r\n\r\nwith\r\n\r\n> Therefore when a child node is set as initial current item, evaluator must select it as starting node instead of the document root when an expression starting with `@` is evaluated.",
              "createdAt": "2021-03-21T19:26:17Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDU0NTg4",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T19:42:50Z",
          "updatedAt": "2021-03-21T19:42:50Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@bettio wrote:\r\n\r\n> @danielaparker: does replacing\r\n> \r\n> > The current item selector `@` when used outside a filter behaves as the document root selector unless a child node is given to the evaluator.\r\n> \r\n> with\r\n> \r\n> > The current item selector `@` can be used to represent the current node being evaluated. The initial current node defaults to the document root unless a child node is given to the evaluator as initial current node.\r\n> \r\n> looks better to you?\r\n> \r\n> Maybe another phrasing might be:\r\n> \r\n> > The current item selector `@` can be used to represent the current node being evaluated. The initial current node defaults to the document root unless a different node is chosen.\r\n\r\nI think it's enough to say \"The current item selector `@` can be used to represent the current node being evaluated\", full stop. That's about equivalent to the meaning of `@` in JMESPath, and to the meaning of \".\" in XPATH 3.1, see [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/59#issuecomment-803618374). \r\n\r\nFor a JSONPath evaluator, it only knows about one document, the one provided as an argument, along with the JSONPath expression. The current node is initialized to that document, and evaluation begins.\r\n\r\nSure, you can have higher level functions built on top of the JSONPath evaluator, that pass a different document to the evaluator depending on whether the path starts with `$` or `@`. Implementers can support such functions if they wish. But the evaluator doesn't know about that, it only knows about one document. \r\n",
              "createdAt": "2021-03-21T19:42:50Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDYyMTEy",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T21:11:15Z",
          "updatedAt": "2021-03-21T21:11:15Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@danielaparker:\r\n> For a JSONPath evaluator, it only knows about one document, the one provided as an argument, along with the JSONPath expression. The current node is initialized to that document, and evaluation begins.\r\n\r\nI would rather stay explicit, so we make sure that it cannot be misunderstood. Therefore writing \"The initial current node defaults to the document root\" doesn't hurt and it helps an unambiguous understanding.\r\n\r\n@danielaparker:\r\n> unless a child node is given to the evaluator as initial current node.\r\n\r\nThis helps remarking that `@` at the beginning of an expression is not necessarily a `$` synonymous according to the following proposal:   \r\n\r\n@gregsdennis:\r\n> Proposal: allow paths to start with @. It operates no differently than $, but can serve as an important indicator to tooling and other systems that consume JSON Path.\r\n\r\nmy goal is making sure that starting evaluation with current item pointing to a child node and optionally referencing it with `@` at the beginning of an expression is compliant with the specification.\r\nI feel like that just stopping at  \"The current item selector @ can be used to represent the current node being evaluated\" might leave my goal in an unclear status.\r\n\r\nBy the way when filtering will be written we'll also remark that current item is updated.\r\n\r\n@danielaparker:\r\n> Sure, you can have higher level functions built on top of the JSONPath evaluator, that pass a different document to the evaluator depending on whether the path starts with $ or @. Implementers can support such functions if they wish. But the evaluator doesn't know about that, it only knows about one document.\r\n\r\nFor the record, my evaluator has 3 parameters: `json_path_eval(document_root, current_item, path)`. It is implemented as a recursive function and `document_root` is always passed unchanged, while `current_item` is updated. The caller may call it doing something like:\r\n`json_path_eval(root, root.foo, \"@.bar\")` which is equivalent to `json_path_eval(root, root, \"$.foo.bar\")`.\r\nNo higher level function magic here ;)\r\nAnyway let's keep out of the discussion implementation detail, again I just need to make sure that `@.bar` (with the meaning that I just showed in the example) is not left out of the spec.\r\n\r\nLastly the PR just aims to allow `@` at the beginning of the expression, I think more PRs are needed for a complete `@` formalization.  \r\n\r\n@danielaparker thanks for your feedback, looking forward to further comments :)",
              "createdAt": "2021-03-21T21:11:15Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDc2MzIz",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-21T23:33:43Z",
          "updatedAt": "2021-03-21T23:33:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@gregsdennis: wish to read any feedback about the wording from you too :) Your help has been valuable so far",
              "createdAt": "2021-03-21T23:33:43Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDgzMDA1",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-22T00:25:40Z",
          "updatedAt": "2021-03-22T00:32:00Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think this could align with the syntax descriptor below better.\n\n> Syntactically, a JSON Path consists of a start selector, which may either be the root selector `$` or the current item selector `@`, followed by...",
              "createdAt": "2021-03-22T00:25:40Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            },
            {
              "originalPosition": 40,
              "body": "Usage of \"node\" here?  I think this is one we've decided to avoid.",
              "createdAt": "2021-03-22T00:29:05Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            },
            {
              "originalPosition": 39,
              "body": "I'm not sure who's working with English as a first language, so please don't take offense, but this could use some grammatical massaging, specifically the use of the word \"the\" in a few places.",
              "createdAt": "2021-03-22T00:30:57Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            },
            {
              "originalPosition": 43,
              "body": "... or when no current item can be defined.",
              "createdAt": "2021-03-22T00:31:47Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDkyODIy",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T01:20:13Z",
          "updatedAt": "2021-03-22T01:20:13Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I don't know who \"we\" is; I think we are still discussing terminology.",
              "createdAt": "2021-03-22T01:20:13Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDkzMDI3",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T01:21:14Z",
          "updatedAt": "2021-03-22T01:21:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "(I'm not so sure about \"child node\", the term \"child\" is usually used for direct descendants.)",
              "createdAt": "2021-03-22T01:21:14Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MTQ5MTM5",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T04:56:16Z",
          "updatedAt": "2021-03-22T04:56:17Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Yes, we're still discussing it, which means that it's something to avoid for now.",
              "createdAt": "2021-03-22T04:56:17Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzUyNDYx",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:17:28Z",
          "updatedAt": "2021-03-22T10:17:28Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "ok, I can replace `node` with `item` and `child node` with `subdocument`. I think that further improvements might be applied on future PRs.",
              "createdAt": "2021-03-22T10:17:28Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzU1MDY4",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:20:25Z",
          "updatedAt": "2021-03-22T10:20:26Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Please wait for PR#72 to settle.",
              "createdAt": "2021-03-22T10:20:25Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzU1NDcw",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:20:55Z",
          "updatedAt": "2021-03-22T10:20:55Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "\"document\" certainly is not the terminology we want to use.",
              "createdAt": "2021-03-22T10:20:55Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzYwMDM2",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:25:54Z",
          "updatedAt": "2021-03-22T10:25:54Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I think that I can replace \"`The current item selector`\" ... \"`with @ is evaluated.`\"\r\n\r\nwith\r\n\r\n```\r\nThe current item selector `@` can be used to represent the current item being\r\nevaluated. The initial current item defaults to the document root unless a\r\nsubdocument is given to the evaluator as initial current item.\r\n```\r\n\r\nI think I can safely remove \"`When a child node is used as current item, evaluator must select it as starting\r\nnode instead of the document root when an expression starting with @ is\r\nevaluated.`\" and  \"`When a child node is used as current item, the current item selector @ selects\r\nit as starting node instead of the document root.`\" since the proposed contains the same information but with a better phrasing.\r\n\r\n@gregsdennis Let me know if it sounds good to you so I can push changes I described here.",
              "createdAt": "2021-03-22T10:25:54Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzY1MDMx",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:31:24Z",
          "updatedAt": "2021-03-22T10:31:25Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": ">  but this could use some grammatical massaging\r\n\r\nIt is not my first language, so any advice or feedback is welcome\r\n\r\nAnyway I think that I'll remove this and just keep:\r\n```\r\nThe current item selector `@` can be used to represent the current item being\r\nevaluated. The initial current item defaults to the document root unless a\r\nsubdocument is given to the evaluator as initial current item.\r\n```\r\n\r\nas described in the other conversation, if you agree too that \"`When a child node is used as current item, the`\"... is just redundant we can remove it and close this conversation since we don't need rephrasing it.",
              "createdAt": "2021-03-22T10:31:25Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzY1MzU3",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:31:45Z",
          "updatedAt": "2021-03-22T10:31:46Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I think @cabo makes a good point about resolving it in another issue when we finish discussing \"node.\"\n\nNo worries.",
              "createdAt": "2021-03-22T10:31:46Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzY2MTc3",
          "commit": {
            "abbreviatedOid": "79412af"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:32:42Z",
          "updatedAt": "2021-03-22T10:32:42Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@cabo: just pushed further changes to this, I think that this conversation is outdated and it can be archived. Let me know if you have any further feedback.",
              "createdAt": "2021-03-22T10:32:42Z",
              "updatedAt": "2021-03-22T10:33:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MzY4NjM1",
          "commit": {
            "abbreviatedOid": "dc74b53"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:35:26Z",
          "updatedAt": "2021-03-22T10:35:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Sorry, github does not make it easy to find the current state of a PR where a conversation has led to changes.  So please ignore my comments if they relate to outdated contents.\r\n\r\nI think the specific wordsmithing of this PR can wait until some other parts of the draft get more stable.",
              "createdAt": "2021-03-22T10:35:26Z",
              "updatedAt": "2021-03-22T10:35:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3Mzc2MTcx",
          "commit": {
            "abbreviatedOid": "dc74b53"
          },
          "author": "bettio",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-22T10:44:09Z",
          "updatedAt": "2021-03-22T10:44:09Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "@gregsdennis: Ok, I'm keeping node for now, we can improve this with a future PR.\r\n\r\n@cabo I removed document and replaced it again with \"root node\". I also replaced \"child node\" with \"descendant node\" which is more accurate.\r\n\r\nSo I will commit & push:\r\n```\r\nThe current item selector `@` can be used to represent the current item being\r\nevaluated. The initial current item defaults to the root node unless a\r\ndescendant node is given to the evaluator as initial current item.\r\n```\r\n\r\nLet me know if you have any further feedback, otherwise let me know you are ok for now so I can push it.",
              "createdAt": "2021-03-22T10:44:09Z",
              "updatedAt": "2021-03-22T10:44:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk4MjUzNDYx",
      "title": "Change title per #68",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/77",
      "state": "CLOSED",
      "author": "timbray",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-22T18:37:06Z",
      "updatedAt": "2021-03-24T21:22:55Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "master",
      "baseRefOid": "503dc8962045e7b58378ef7544f8f6f3ad25cbd2",
      "headRepository": "timbray/draft-ietf-jsonpath-jsonpath",
      "headRefName": "master",
      "headRefOid": "b29df2c1c90b790a6fc402352a16538f8dff080f",
      "closedAt": "2021-03-24T18:34:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "body": "Pro tip: edit the opening comment to include \"Resolves #68\" and GitHub will close the issue when this PR merges.",
          "createdAt": "2021-03-22T19:15:04Z",
          "updatedAt": "2021-03-22T19:15:04Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Heh, \"Fixes #whatever\" I think works too.  I'm in another project where you're not allowed to do that because there are designated issue-closers. Noted.",
          "createdAt": "2021-03-22T19:16:44Z",
          "updatedAt": "2021-03-22T19:16:44Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@timbray Please could you rebase this PR on `main`?",
          "createdAt": "2021-03-24T17:49:06Z",
          "updatedAt": "2021-03-24T17:49:06Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I've cherry-picked the fix over to https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/85.",
          "createdAt": "2021-03-24T18:34:31Z",
          "updatedAt": "2021-03-24T18:34:31Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!\n\nOn Wed, Mar 24, 2021 at 11:34 AM Glyn Normington ***@***.***>\nwrote:\n\n> I've cherry-picked the fix over to #85\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/85>.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/77#issuecomment-806062831>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAAEJEYVE36QTWXZ3E32B4TTFIWERANCNFSM4ZTVI47A>\n> .\n>\n",
          "createdAt": "2021-03-24T18:39:42Z",
          "updatedAt": "2021-03-24T18:39:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3ODgwMjk1",
          "commit": {
            "abbreviatedOid": "b29df2c"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-22T18:57:09Z",
          "updatedAt": "2021-03-22T18:57:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3ODkzNjk2",
          "commit": {
            "abbreviatedOid": "b29df2c"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-22T19:13:35Z",
          "updatedAt": "2021-03-22T19:13:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3OTMyMTQ2",
          "commit": {
            "abbreviatedOid": "b29df2c"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-22T20:02:08Z",
          "updatedAt": "2021-03-22T20:02:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5MDI0NTE0",
      "title": "Processing model",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/79",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Try to nail down the processing model some more, and raise four discussion points that we might be able to resolve now.",
      "createdAt": "2021-03-23T16:54:09Z",
      "updatedAt": "2021-03-27T21:52:23Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "be226f10a48856c7a1721387a76dfb7cb377e039",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "processing-model",
      "headRefOid": "89d7d721dc77e4a7a3a2d53f8b1abcbd8b26c125",
      "closedAt": "2021-03-27T15:38:19Z",
      "mergedAt": "2021-03-27T15:38:19Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "d5f7cb9997acda56d0bebef52c5c606faca37fe0"
      },
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems to be related to #14.",
          "createdAt": "2021-03-23T23:18:12Z",
          "updatedAt": "2021-03-23T23:18:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Indeed, this tries to reflect the great discussion in #14.",
          "createdAt": "2021-03-23T23:19:55Z",
          "updatedAt": "2021-03-23T23:19:55Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "It seems these are all terminology comments.\r\nCan we refrain from continuing the Brownian motion on terminology and focus on content for this PR?\r\nUnless of course the terminology is wrong or not sufficiently sharp.\r\nWe can go back to terminology discussions after having made some progress.",
          "createdAt": "2021-03-24T10:58:57Z",
          "updatedAt": "2021-03-24T10:58:57Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I have collected these items in #84 so we don't forget where we were.\r\n",
          "createdAt": "2021-03-24T12:40:21Z",
          "updatedAt": "2021-03-24T12:40:21Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "\r\n> @cabo, can you at least define the properties of \"node\" for JSONPath? I think the discussion of the processing model depends on that, just as the discussion of the processing model in XPath depends on the properties of \"node\" defined in the XDM. I think the essential properties for JSONPath are value and location, but I would like to know your view.\r\n\r\nI was thinking that line 183..185 were doing that.  But since you insist, in eefc298 I have tried to clarify this paragraph and elevate it to its own definition.",
          "createdAt": "2021-03-24T13:21:51Z",
          "updatedAt": "2021-03-24T13:21:51Z"
        },
        {
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "body": "@cabo wrote:\r\n\r\n> I was thinking that line 183..185 were doing that. But since you insist, in [eefc298](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/commit/eefc298f5e2711d7acb858f5798c1b59f2de3ef9) I have tried to clarify this paragraph and elevate it to its own definition.\r\n\r\nThank you. Your forbearance is appreciated :-)\r\n\r\nI was hoping for something more along the lines of XQuery and XPath Data Model 3.1 wording:\r\n\r\n\"All nodes must satisfy the following general constraints:\"\r\n\r\n\"Elements [Nodes] have the following properties:\"\r\n\r\nBut I understand (and largely agree with) this sentence, which can be considered a working definition:\r\n\r\n\"A node can be viewed as a combination of a (1) JSON value and (2) its location in the  argument; the latter can, if desired, be represented as an Output Path.\"\r\n\r\nI (and no doubt @timbray) would prefer \"root value\" to \"argument\", and I would prefer \"Normalized Path\" to \"Output Path\" (why use any other than the easily constructed canonical one?) but these then become terminological or minor issues. \r\n\r\n \r\n\r\n \r\n\r\n\r\n\r\n",
          "createdAt": "2021-03-24T14:01:49Z",
          "updatedAt": "2021-03-24T14:05:50Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo This needs rebasing on main. Also the text includes some discussion points and I'm not sure whether your intention is that these be addressed before merging?",
          "createdAt": "2021-03-25T11:09:12Z",
          "updatedAt": "2021-03-25T11:09:12Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@gregsdennis and @danielaparker I'd like to get this PR merged with the discussion points inline. That would be a nice stake in the ground. Do either of you have objections to that or are you comfortable with merging?",
          "createdAt": "2021-03-26T15:41:02Z",
          "updatedAt": "2021-03-26T15:41:02Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "To make this easier, I rebased on main again, and I numbered the discussion points (D1 to D4).\r\n",
          "createdAt": "2021-03-26T15:55:43Z",
          "updatedAt": "2021-03-26T15:55:43Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@danielaparker the goal for putting a \"processing model\" in the spec is to have some algorithm to reference internally.  It doesn't need to consider edge cases or have much detail.  It just needs to be sufficient for other parts of the spec to use.  It's not even intended as guidance.  We want to leave as much as possible up to the implementor.",
          "createdAt": "2021-03-27T21:44:03Z",
          "updatedAt": "2021-03-27T21:44:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MTg0NDQx",
          "commit": {
            "abbreviatedOid": "29065e7"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this is coherent, and I like the direction.  I've also added a few suggestions/comments.",
          "createdAt": "2021-03-23T23:59:58Z",
          "updatedAt": "2021-03-24T00:39:43Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Maybe we need a formal definition for \"node\" as well (in addition to the above explanation).  Current discussion seems to point to a value/location pair.  (Though, the discussion also questions the need for such a definition.)  But if we're going to define a node list, then we should probably define what it's a list of.",
              "createdAt": "2021-03-23T23:59:58Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 5,
              "body": "This is good.  We don't need to claim that JSON itself is a tree of nodes, only that this spec views them as such when convenient.\r\n\r\nMaybe instead of \"is also viewed...\" we use \"can also be viewed...\"",
              "createdAt": "2021-03-24T00:03:15Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nThe well-formedness and validity of JSONPath queries are independent of\r\n```",
              "createdAt": "2021-03-24T00:07:45Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 92,
              "body": "I think this needs further discussion before representing it in a PR.",
              "createdAt": "2021-03-24T00:09:11Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\nwhich is applied to each node in the result of the previous selector and outputs\r\na single list of nodes to be used as input by the next selector.\r\n```\r\n\r\nSee [discussion](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/14#issuecomment-694687029) on representing the algorithm as iterating over the individual results of the previous selector vs taking the full result set as a single input.\r\n\r\nThe suggestion above is in line with the rest of the content of the PR so far: each selector iterates over the output from the previous selector.",
              "createdAt": "2021-03-24T00:14:59Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 114,
              "body": "I like leaving this open to the implementation.  We _could_ (in a later PR) go so far as to define what the output looks like for each of these cases in order to give an expected API for consumers of the implementations.\r\n\r\nIt may also be beneficial to explicitly state that a node list is just a collection of nodes; it is _not_ a JSON array, although its _representation in JSON_ is.  This is to say that a node list can be _serialized_ to a JSON array (e.g. for the purposes of output), but it is not one inherently.",
              "createdAt": "2021-03-24T00:17:10Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 94,
              "body": "We should add a paragraph that states that this processing model is an example for the purposes of explaining how JSON Path works and is not prescriptive of the internal workings of an implementation.  If an implementation wishes to (or needs to due to framework limitations) design a different process that yields the same results, this should be acceptable.",
              "createdAt": "2021-03-24T00:20:49Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 183,
              "body": "Definitely worth discussion, but I think a common \"combine\" mechanism is simplest to understand.  Each selector defining its own forces the Path author to remember how each one behaves, which can get confusing fast.",
              "createdAt": "2021-03-24T00:26:36Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            },
            {
              "originalPosition": 189,
              "body": "This touches on the function of `@`, `$` within filter queries, and the idea of scope when `@` is used in nested filter queries.\r\n\r\nI think it's better left for another PR when we've explored these ideas and how they relate.",
              "createdAt": "2021-03-24T00:34:17Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MzQ4MDI1",
          "commit": {
            "abbreviatedOid": "29065e7"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T05:51:58Z",
          "updatedAt": "2021-03-24T05:51:59Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "combine1 appears to be undefined.",
              "createdAt": "2021-03-24T05:51:59Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTE4Mjg5",
          "commit": {
            "abbreviatedOid": "2d5389f"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T09:52:35Z",
          "updatedAt": "2021-03-24T09:52:35Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "There is a definition for \"node\" up in line 183.\r\n\r\nI'm not entirely sure we need both \"item\" and \"node\", but I would ask for your patience to leave this for now until we figure it out.",
              "createdAt": "2021-03-24T09:52:35Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTE4ODc2",
          "commit": {
            "abbreviatedOid": "2d5389f"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T09:53:13Z",
          "updatedAt": "2021-03-24T09:53:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Well, we very actively view it as a tree of nodes in the current text, so I think we are good as is.",
              "createdAt": "2021-03-24T09:53:13Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTIyNjI0",
          "commit": {
            "abbreviatedOid": "9ab79b2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T09:56:43Z",
          "updatedAt": "2021-03-24T09:56:43Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Indeed.  So we could resolve this question before merging, or we could merge with the question intact, to be resolved in later PR.",
              "createdAt": "2021-03-24T09:56:43Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTI0MTM2",
          "commit": {
            "abbreviatedOid": "9ab79b2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T09:58:10Z",
          "updatedAt": "2021-03-24T09:58:10Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Right.  The current PR text says \"depending on the specific API\", so I think we are covered on the first item.  It also doesn't seem to suggest the nodelist is a JSON array, or are text changes actually required for the second suggestion?",
              "createdAt": "2021-03-24T09:58:10Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTMyNDQ4",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:06:32Z",
          "updatedAt": "2021-03-24T10:06:32Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Good point.  I put a new paragraph at the start of 3.2.  I had to weasel word a bit around \"the same\", because we are saying the model isn't deterministic.",
              "createdAt": "2021-03-24T10:06:32Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTMzMjUz",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:07:18Z",
          "updatedAt": "2021-03-24T10:07:19Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "That is a good reason to stick with a common \"combine1\" model.",
              "createdAt": "2021-03-24T10:07:19Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTM0NDMx",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:08:32Z",
          "updatedAt": "2021-03-24T10:08:32Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Sure -- it has the strange name because it is a placeholder that needs to be filled in based on the discussion points.  But we can live with this placeholder while we resolve the discussions, hence giving it a name is a good idea for these discussions.\r\n",
              "createdAt": "2021-03-24T10:08:32Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTM4NTkz",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:12:53Z",
          "updatedAt": "2021-03-24T10:12:53Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "The changed text implies that each function invocation of the selected leaves a node list that is then independently fed to the next selector.  I think the discussion resolved to doing the combine1 step first, yielding a single nodelist, and then applying the next selector again to each node in that nodelist.",
              "createdAt": "2021-03-24T10:12:53Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTYxMDI0",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:36:23Z",
          "updatedAt": "2021-03-24T10:36:23Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "I don't think that we should rely on implications.  Explicit statements are always better.",
              "createdAt": "2021-03-24T10:36:23Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTYyMjc0",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:37:45Z",
          "updatedAt": "2021-03-24T10:37:45Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Can you say what the wording should be?",
              "createdAt": "2021-03-24T10:37:45Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTY0MDUz",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:39:38Z",
          "updatedAt": "2021-03-24T10:39:39Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I'm not sure I followed that.  My suggested changes align this statement with the rest of the your descriptions to say that each selector takes the nodelist (combined) output by the previous selector as a single argument and iterates over the nodes internally.\n\nThe other form is to say that the selector is fed each node individually by the processor, which doesn't line up with the rest of the PR.",
              "createdAt": "2021-03-24T10:39:38Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTY1MzEz",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:41:02Z",
          "updatedAt": "2021-03-24T10:41:02Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Are you saying that we should leave this markdown block quote in place to spur discussion?",
              "createdAt": "2021-03-24T10:41:02Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTY4ODA0",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Regarding \"Data Item: A structure complying to the generic data model of JSON, i.e., composed of containers, namely JSON objects and arrays, and of atomic data, namely null, true, false, numbers, and text strings. Also called a JSON value.\", this seems to be related to @ttimbrays posts [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/66#issuecomment-804425507) and [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/66#issuecomment-804425507). Perhaps \"Data Item\" could be dropped and just use \"JSON value\", as @ttimbrays proposed?\r\n\r\nRegarding \"Argument: Short name for the JSON data item a JSONPath expression is applied to\", this also seems to be related  to @ttimbrays post [here](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath/issues/66#issuecomment-804425507). Perhaps \"Argument\" could be replaced with \"root value\", as @ttimbray suggested?\r\n\r\nNote that if a node is regarded as a value/location pair, than a JSON value cannot be considered as a \"tree of nodes\", or a \"node\" itself. We can define a \"children\" property on a JSON value, which can be considered its members or elements if such exist. But we cannot define a \"location\" property for a JSON value, it's not possible, and \"location\" seems to be an essential property of a node as understood in the processing model defined in this PR. See [here](https://www.w3.org/TR/xpath-datamodel-31/#Node) for a related definition of \"node\" in the XQuery and XPath Data Model 3.1. JSONPath doesn't need a notion of \"node\" as complicated as XDM, but minimally it needs location, children, and value properties.\r\n\r\nI don't think this observation presents a great difficulty for the PR, but I think that mentions of JSON values as \"trees of nodes\" and remarks that \"the term _node_ has the same meaning [as JSON value]\" would be better expunged.\r\n\r\n",
          "createdAt": "2021-03-24T10:44:52Z",
          "updatedAt": "2021-03-24T10:47:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTc0NDUx",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:51:11Z",
          "updatedAt": "2021-03-24T10:51:11Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Yes.  Until that discussion is resolved.\r\n",
              "createdAt": "2021-03-24T10:51:11Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTc2MTYz",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:53:04Z",
          "updatedAt": "2021-03-24T10:53:05Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I think \"node\" warrants its own entry if we're to define \"nodelist.\"  What is a \"nodelist\" a list of?",
              "createdAt": "2021-03-24T10:53:05Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTc2ODc2",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:53:53Z",
          "updatedAt": "2021-03-24T10:53:53Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "The processing model actually says that the selector processing the input nodelist into the output nodelist by processing each entry of the input nodelist into a partial output nodelist and then uses combine1 to put these together into the output nodelist.  This probably needs better terminology.  Your text tells me that a selector is applied to each element of the input nodelist and does not say what we do with all those partial output nodelists.",
              "createdAt": "2021-03-24T10:53:53Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTc3NjU4",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:54:44Z",
          "updatedAt": "2021-03-24T10:54:44Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "OK, I can make line 183 into its own entry.",
              "createdAt": "2021-03-24T10:54:44Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTc5NDM5",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:56:49Z",
          "updatedAt": "2021-03-24T10:56:49Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Actually, it looks like lines 221-222 cover it: \r\n\r\n> While this list can be represented in JSON, e.g. as an array, the nodelist is an abstract concept unrelated to JSON data items.\r\n\r\nWe may want to reiterate this when we cover output formats.",
              "createdAt": "2021-03-24T10:56:49Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTgyMjgy",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T10:59:59Z",
          "updatedAt": "2021-03-24T11:00:00Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "If that's the convention we want to follow for authoring the spec, this is fine.",
              "createdAt": "2021-03-24T10:59:59Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTgzNzQ2",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T11:01:36Z",
          "updatedAt": "2021-03-24T11:01:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I like that \"view\" trick ...",
              "createdAt": "2021-03-24T11:01:36Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTkzNDQ4",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T11:12:54Z",
          "updatedAt": "2021-03-24T11:12:54Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "After rereading my comments, I see the confusion between what I've been saying and my addition of \"each node in.\"  I think this can be removed from my suggestion:\r\n\r\n```suggestion\r\nwhich is applied to the result of the previous selector and outputs\r\na new nodelist to be used as input by the next selector.\r\n```\r\n\r\nRegarding how the results of each node are combined, this paragraph doesn't address it at all.  This paragraph instead focuses on the input/output stream of the selectors.  The \"combining\" logic is something internal to how the selectors work, which is discussed later when you're talking about the \"combine1\" function.  I think this is a good layout for the spec as it stands in this proposal.",
              "createdAt": "2021-03-24T11:12:54Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NjY5MjY1",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T12:42:08Z",
          "updatedAt": "2021-03-24T12:42:08Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "(Marking this as resolved -- it is however best if this is done by who raised the comment.)",
              "createdAt": "2021-03-24T12:42:08Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5Njg5NTgw",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T13:03:10Z",
          "updatedAt": "2021-03-24T13:03:11Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Each selector can only select nodes from the subtree of the current node. So with each selector the number of potentially selectable nodes is reduced or stays constant at best. It can never increase ... so \"combine\" suggests \"increase\", is misleading and should either be \"pick model\" or \"select model\" or something similar.",
              "createdAt": "2021-03-24T13:03:10Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzAxNDAz",
          "commit": {
            "abbreviatedOid": "4288940"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T13:14:49Z",
          "updatedAt": "2021-03-24T13:14:50Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Well, a selector operates on the nodes in the input node list.\r\nThe \"combine1\" function is about combining the outputs that each such operation provides.\r\n\r\nSo if you have `[1], [2]` as the nodelist (identifying nodes by their values here), and the selector is `.[0]`, the output nodelists from each selector function invocation are `1` and `2` respectively.  combine1 would create an output nodelist `1, 2`.  This is a bit boring, but more complex selectors can leave a nodelist for each node in the input nodelist, so we need to discuss how to combine them:\r\n\r\n`{a: {a: 1}},  {a: {a: 2}}` as input nodelist, `..a` as selector: The individual nodelists are  `{a: 1}, 1` and `{a: 2}, 2`.  combine1 turns this into, say, `{a: 1}, 1, {a: 2}, 2`.\r\n",
              "createdAt": "2021-03-24T13:14:50Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzA5MTQ4",
          "commit": {
            "abbreviatedOid": "eefc298"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T13:22:08Z",
          "updatedAt": "2021-03-24T13:22:09Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "A selector can never go up, given the information the current node is holding alone, as it lacks parent node info.\r\n\r\nMaintaining parent node info during selection process introduces a new &ndash; hard to overview &ndash; level of complexity and should be avoided.",
              "createdAt": "2021-03-24T13:22:08Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzE3MTI0",
          "commit": {
            "abbreviatedOid": "eefc298"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T13:29:17Z",
          "updatedAt": "2021-03-24T13:29:17Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Do we also need ...\r\n\r\n```\r\nValue:  A JSON value as defined in [RFC8259].\r\n```\r\n\r\nIt would make your inline ...\r\n\r\n```\r\n(Note that the term JSON\r\n   value also implies that this value complies to the definitions in\r\n   [RFC8259], i.e., is indeed a JSON value.)\r\n```\r\n... obsolete.",
              "createdAt": "2021-03-24T13:29:17Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzU4OTc5",
          "commit": {
            "abbreviatedOid": "eefc298"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T14:04:43Z",
          "updatedAt": "2021-03-24T14:04:43Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "We already say:    The terminology of [RFC8259] applies.\r\nSo we have already imported all that terminology.\r\n\r\nOn the specific note:\r\nA note is by definition redundant; it just alerts the reader to what is said in the note.  I think it is very much worth to say this again, because it reminds people that we are not taking a position on error handling with respect to broken JSON input -- this is just out of scope for the present specification.",
              "createdAt": "2021-03-24T14:04:43Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5Nzg4OTE5",
          "commit": {
            "abbreviatedOid": "eefc298"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T14:28:04Z",
          "updatedAt": "2021-03-24T14:28:05Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Oh well ... it's a simple \"append\" to the resulting nodelist. According to my mental model allowing only a single resulting nodelist, the sequence of ...\r\n* `{a: 1}`\r\n* `1`\r\n* `{a: 2}`\r\n* `2`\r\n\r\n... would be added, where order is implementation dependent of course (determinism).",
              "createdAt": "2021-03-24T14:28:04Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5OTE4Nzg1",
          "commit": {
            "abbreviatedOid": "eefc298"
          },
          "author": "danielaparker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T16:02:59Z",
          "updatedAt": "2021-03-24T16:02:59Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "@goessner wrote:\r\n\r\n> Oh well ... it's a simple \"append\" to the resulting nodelist. According to my mental model allowing only a single resulting nodelist, the sequence of ...\r\n> \r\n> * `{a: 1}`\r\n> * `1`\r\n> * `{a: 2}`\r\n> * `2`\r\n> \r\nJust this. That corresponds to my \"mental model\", and directly to what many implementations do.\r\n\r\n> ... would be added, where order is implementation dependent of course (determinism).\r\n\r\nImplementation dependent, yes, but I think the \"natural order\" would satisfy the minimally restrictive conditions identified by @glyn in #60.\r\n\r\n",
              "createdAt": "2021-03-24T16:02:59Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMDI1NjM1",
          "commit": {
            "abbreviatedOid": "eefc298"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T17:31:58Z",
          "updatedAt": "2021-03-24T17:31:58Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Yes, to spell this out, there is _one_ object with more than one key/value pair and thus one source of non-determinism in this example (assuming the visitation ordering of `..` will be tied down in the spec). So the other possible resultant nodelist would  correspond to:\r\n* `{a: 2}`\r\n* `2`\r\n* `{a: 1}`\r\n* `1`",
              "createdAt": "2021-03-24T17:31:58Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMTQ2NDEx",
          "commit": {
            "abbreviatedOid": "eefc298"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T19:16:50Z",
          "updatedAt": "2021-03-24T19:16:50Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I looked for it last night, but it seems I can't mark it as resolved.",
              "createdAt": "2021-03-24T19:16:50Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwOTcwMzQx",
          "commit": {
            "abbreviatedOid": "0237a69"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-25T10:53:30Z",
          "updatedAt": "2021-03-25T10:53:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjcxOTM1",
          "commit": {
            "abbreviatedOid": "0237a69"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T15:30:19Z",
          "updatedAt": "2021-03-26T15:30:20Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "I'd like to think we can agree on one *combine1*. I haven't heard a strong argument against removing duplicate nodes.",
              "createdAt": "2021-03-26T15:30:20Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjczMzcy",
          "commit": {
            "abbreviatedOid": "0237a69"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T15:31:42Z",
          "updatedAt": "2021-03-26T15:31:42Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "I agree a selector can never go up.",
              "createdAt": "2021-03-26T15:31:42Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjgxMDIy",
          "commit": {
            "abbreviatedOid": "0237a69"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approving with discussion points left inline. Better to make progress on the rest.",
          "createdAt": "2021-03-26T15:39:12Z",
          "updatedAt": "2021-03-26T15:39:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjkzMTk4",
          "commit": {
            "abbreviatedOid": "1755f1e"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T15:51:07Z",
          "updatedAt": "2021-03-26T15:51:07Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "The word nodelist is first discussed in the next sentence, so this is simply pulling in an unneeded forward reference.",
              "createdAt": "2021-03-26T15:51:07Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjk0ODk1",
          "commit": {
            "abbreviatedOid": "1755f1e"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T15:52:44Z",
          "updatedAt": "2021-03-26T15:52:45Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "This thread proposes an answer to the discussion point.\r\nMaybe we can merge the PR first and then specifically address the discussion point.",
              "createdAt": "2021-03-26T15:52:44Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjE4NjI4",
          "commit": {
            "abbreviatedOid": "cf06a90"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T04:32:44Z",
          "updatedAt": "2021-03-27T04:32:44Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Still, \"leaves input to...\" is odd wording.",
              "createdAt": "2021-03-27T04:32:44Z",
              "updatedAt": "2021-03-27T04:57:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjE5MTc4",
          "commit": {
            "abbreviatedOid": "cf06a90"
          },
          "author": "gregsdennis",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm happy with this for its purpose.\n\nI'd like to deal with [this wording](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/79#discussion_r602668320)  at some point, but it's not crucial to this PR.",
          "createdAt": "2021-03-27T04:42:37Z",
          "updatedAt": "2021-03-27T04:42:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjIwMTAx",
          "commit": {
            "abbreviatedOid": "89d7d72"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T04:58:44Z",
          "updatedAt": "2021-03-27T04:58:45Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "89d7d72: leaves \u2794 provides",
              "createdAt": "2021-03-27T04:58:45Z",
              "updatedAt": "2021-03-27T04:58:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5NTU1NTE0",
      "title": "Merge README information",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/80",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge information from the previous README.",
      "createdAt": "2021-03-24T10:11:55Z",
      "updatedAt": "2021-03-24T10:37:18Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "362ce19af810a0d813b52ad11c9c4703fda22450",
      "headRepository": "glyn/internet-draft",
      "headRefName": "merge-readme",
      "headRefOid": "d081b82ea8cd21e1cc743e2f6349a8289abbdd73",
      "closedAt": "2021-03-24T10:37:14Z",
      "mergedAt": "2021-03-24T10:37:14Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "e9f7ff33bd8520acc410b98758db40ec4e495c95"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTU1NDg4",
          "commit": {
            "abbreviatedOid": "d081b82"
          },
          "author": "gregsdennis",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "This looks fine to me",
          "createdAt": "2021-03-24T10:30:35Z",
          "updatedAt": "2021-03-24T10:30:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5NTY3NTg4",
      "title": "Avoid copying HTML to docs directory",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/83",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also leave ABNF file around after check.",
      "createdAt": "2021-03-24T10:28:20Z",
      "updatedAt": "2021-03-24T10:37:38Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "ec03574fcaf19ea50bdef084b64822e86d2799f1",
      "headRepository": "glyn/internet-draft",
      "headRefName": "nocopy",
      "headRefOid": "7f74b297d1fdb09967be8dde2b83b777c946822a",
      "closedAt": "2021-03-24T10:37:35Z",
      "mergedAt": "2021-03-24T10:37:35Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "96ecd98dd8dde63a3c152b580ae906153fbdd6ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTU4NDUy",
          "commit": {
            "abbreviatedOid": "49d7d2c"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2021-03-24T10:33:41Z",
          "updatedAt": "2021-03-24T10:33:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NTU5ODM1",
          "commit": {
            "abbreviatedOid": "0a72aa8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "It is probably innocuous to leave this around in the main branch (as opposed to moving it over to gh-pages), so I think we can leave it at that.",
          "createdAt": "2021-03-24T10:35:09Z",
          "updatedAt": "2021-03-24T10:35:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5OTU4MDYx",
      "title": "Change title per #68",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/85",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-24T18:33:31Z",
      "updatedAt": "2021-03-24T18:40:25Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "e74d02b929ce8162473c001c0eb1c56fc287fd65",
      "headRepository": "glyn/internet-draft",
      "headRefName": "rebase-77",
      "headRefOid": "e0e85990eed55af2885b7133e597e9cfb64a3bdd",
      "closedAt": "2021-03-24T18:40:22Z",
      "mergedAt": "2021-03-24T18:40:22Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "b4c8c200589cdc35d1fdfd8b9fcd45f451e38f6f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5OTcxNDIx",
      "title": "Glyn Normington has retired",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/86",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-24T18:49:20Z",
      "updatedAt": "2021-03-24T18:51:39Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "b4c8c200589cdc35d1fdfd8b9fcd45f451e38f6f",
      "headRepository": "glyn/internet-draft",
      "headRefName": "retire",
      "headRefOid": "558fdf23cf7063ce5565f63aa93f7c396d180d90",
      "closedAt": "2021-03-24T18:51:36Z",
      "mergedAt": "2021-03-24T18:51:36Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "84b7c8c4e5f4f395ad2bc5c696f4c3ee6c4f3af4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5OTk2NDcz",
      "title": "Blank org for Glyn Normington",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/87",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @cabo, I don't need to publicise my retirement quite so\r\nstarkly.",
      "createdAt": "2021-03-24T19:16:40Z",
      "updatedAt": "2021-03-24T19:18:14Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "84b7c8c4e5f4f395ad2bc5c696f4c3ee6c4f3af4",
      "headRepository": "glyn/internet-draft",
      "headRefName": "noorg",
      "headRefOid": "3bf8a0338bf49270b11c7002a386c19a4ded7957",
      "closedAt": "2021-03-24T19:18:11Z",
      "mergedAt": "2021-03-24T19:18:10Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "cf24f76e12b483249f5a59c41dd963dc743aff06"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAyMDg5MjI2",
      "title": "Fix formatting of Table 3: Escape Sequence Replacements",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/89",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-27T15:45:20Z",
      "updatedAt": "2021-03-28T07:26:53Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "d5f7cb9997acda56d0bebef52c5c606faca37fe0",
      "headRepository": "glyn/internet-draft",
      "headRefName": "formatting",
      "headRefOid": "b2149b81dda5e1db0f12ccd97a0f3596f7584868",
      "closedAt": "2021-03-27T15:46:11Z",
      "mergedAt": "2021-03-27T15:46:11Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "4a129f30e0992744ed3d60a7a136994fa0db26e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjU5OTg5",
          "commit": {
            "abbreviatedOid": "b2149b8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T15:48:53Z",
          "updatedAt": "2021-03-27T15:48:53Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Almost...\r\n\r\nThis needs to be `\"\\\\\" \"\\\\\"`\r\n\r\n(Actually, I'd use ``` `\\` ``` in both cases, but this works, too.)",
              "createdAt": "2021-03-27T15:48:53Z",
              "updatedAt": "2021-03-27T15:49:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjYwODYw",
          "commit": {
            "abbreviatedOid": "b2149b8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T16:00:26Z",
          "updatedAt": "2021-03-27T16:00:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@cabo Good eyes. I'll fix that later.",
              "createdAt": "2021-03-27T16:00:26Z",
              "updatedAt": "2021-03-27T16:00:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjg2NDMz",
          "commit": {
            "abbreviatedOid": "b2149b8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T17:06:25Z",
          "updatedAt": "2021-03-27T17:06:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@cabo Now I come to look at this again, I can't see what's wrong - an escaped solidus (`/`) needs to be replaced with a solidus `U+002F`. What problem did you see?",
              "createdAt": "2021-03-27T17:06:25Z",
              "updatedAt": "2021-03-27T17:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjk1MzA3",
          "commit": {
            "abbreviatedOid": "b2149b8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T19:15:10Z",
          "updatedAt": "2021-03-27T19:15:11Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The next line has an unescaped `\\`.",
              "createdAt": "2021-03-27T19:15:10Z",
              "updatedAt": "2021-03-27T19:15:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNzI4MDYw",
          "commit": {
            "abbreviatedOid": "b2149b8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-28T07:26:52Z",
          "updatedAt": "2021-03-28T07:26:52Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@cabo Ah yes! Thanks. BTW PR comments normally refer to the line(s) above.",
              "createdAt": "2021-03-28T07:26:52Z",
              "updatedAt": "2021-03-28T07:26:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAyMTAxNDgw",
      "title": "Editorial: Remove term \"data item\"",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/90",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "See discussion in #84.\r\n\r\nTo do: What exactly doesn't $..* stand for -- the table currently says \"member values\" (i.e., no array elements).  Is that true?",
      "createdAt": "2021-03-27T16:13:01Z",
      "updatedAt": "2021-04-10T09:52:36Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "4a129f30e0992744ed3d60a7a136994fa0db26e2",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "nodataitem",
      "headRefOid": "b9601323a0d84a453bd9542ca4ada49d35d0a095",
      "closedAt": "2021-04-10T09:52:33Z",
      "mergedAt": "2021-04-10T09:52:33Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "c8597e87e9735338ceca4eb6a99c15bf5148dcf2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjg2OTUy",
          "commit": {
            "abbreviatedOid": "00ddad2"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T17:13:41Z",
          "updatedAt": "2021-03-27T17:13:42Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "There is a [consensus](https://cburgmer.github.io/json-path-comparison/results/dot_notation_with_wildcard_after_recursive_descent.html) around `..*`: it traverses descendants (including the starting node) and for each one applies `.*` to objects and `[*]` to arrays.\r\n\r\nLet's defer fine-tuning the description until a PR which covers `..` in detail. ",
              "createdAt": "2021-03-27T17:13:42Z",
              "updatedAt": "2021-03-27T19:08:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjg2OTY3",
          "commit": {
            "abbreviatedOid": "00ddad2"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks.",
          "createdAt": "2021-03-27T17:13:54Z",
          "updatedAt": "2021-03-27T17:13:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjk0OTI5",
          "commit": {
            "abbreviatedOid": "00ddad2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T19:09:55Z",
          "updatedAt": "2021-03-27T19:09:56Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Right.  To reduce confusion, I did add \"array elements\" to the text in the table; but clearly, this needs to be addressed in a technical PR.",
              "createdAt": "2021-03-27T19:09:55Z",
              "updatedAt": "2021-03-27T19:09:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzMDU4NTkw",
          "commit": {
            "abbreviatedOid": "b960132"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-29T09:59:01Z",
          "updatedAt": "2021-03-29T09:59:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAyMTk5NzE1",
      "title": "Add missing escape",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/91",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-28T07:25:10Z",
      "updatedAt": "2021-03-28T18:27:25Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "4a129f30e0992744ed3d60a7a136994fa0db26e2",
      "headRepository": "glyn/internet-draft",
      "headRefName": "table-3-correction",
      "headRefOid": "64e26fbd63dd466566a36184fa7305dcf26016ff",
      "closedAt": "2021-03-28T15:57:21Z",
      "mergedAt": "2021-03-28T15:57:21Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "1528b4d528bfb0b4628e8d298d9a7cb50ac801d9"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Thanks -- saw it too late, but this was what I meant.\r\n",
          "createdAt": "2021-03-28T18:27:25Z",
          "updatedAt": "2021-03-28T18:27:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwMTYzNDEw",
      "title": "removed dashes `-` as valid characters for dot-name selectors",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/94",
      "state": "MERGED",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #16\r\n\r\nAlso, I'm not sure what needs to be included in the PR as far as generated files go.  Any guidance would be helpful.",
      "createdAt": "2021-05-11T11:05:50Z",
      "updatedAt": "2021-06-14T09:48:27Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "c8597e87e9735338ceca4eb6a99c15bf5148dcf2",
      "headRepository": "gregsdennis/draft-ietf-jsonpath-base",
      "headRefName": "main",
      "headRefOid": "d40c4c8616cb75100d73bf1708bec4416f655603",
      "closedAt": "2021-06-14T09:48:27Z",
      "mergedAt": "2021-06-14T09:48:27Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "43d2e974d64d8f450c7bbc68a9db6d49219343ec"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, I'm not sure what needs to be included in the PR as far as generated files go. Any guidance would be helpful.\r\n\r\nIIRC (and it's a big if given how long ago I made a change), you don't need to check in generated files. Indeed `.gitignore` ignores them.",
          "createdAt": "2021-05-11T11:14:41Z",
          "updatedAt": "2021-05-11T11:14:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2NTgwMzg1",
          "commit": {
            "abbreviatedOid": "d40c4c8"
          },
          "author": "mkmik",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-11T11:15:47Z",
          "updatedAt": "2021-05-11T11:15:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzMTA0NDEz",
          "commit": {
            "abbreviatedOid": "d40c4c8"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-19T11:58:33Z",
          "updatedAt": "2021-05-19T11:58:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzMjE2OTQ2",
          "commit": {
            "abbreviatedOid": "d40c4c8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-19T13:40:09Z",
          "updatedAt": "2021-05-19T13:40:29Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "In a separate PR, we should remove all those redundant comments.",
              "createdAt": "2021-05-19T13:40:09Z",
              "updatedAt": "2021-05-19T13:40:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzUwNDQw",
          "commit": {
            "abbreviatedOid": "d40c4c8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-12T19:52:47Z",
          "updatedAt": "2021-06-12T19:52:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQzMDQ3NjA1",
      "title": "84 terminology",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/97",
      "state": "CLOSED",
      "author": "gregsdennis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #84\r\n\r\n## Alterations\r\n\r\n- Removed `Object`, and `Array` since they are defined in 8259.  Replaced with extended verbiage at the beginning of the section that declares that 8259 applies.\r\n- Replaced \"JSON value\" with \"value\" in line with the above.\r\n- Relabeled \"output path\" as \"normalized path\"\r\n\r\n## Additions\r\n\r\n- String - a clarification and expansion on the JSON definition\r\n- Root Node\r\n\r\n## Other\r\n\r\n- Reordered terms and paragraphs so that reading through doesn't use terms that haven't been defined yet (as much as possible).\r\n- Removed a redundant parenthetical sentence in the *Processing Model* section.\r\n- Removed some un-necessary self-references (e.g. \"JSONPath query\" rather than just \"query\").\r\n- Made some general edits\r\n\r\n## Notes\r\n\r\n### Existing in-place definitions\r\n\r\n\"Selector\" and \"slice\" are defined in-place where they're needed.  Do we need to define them in the terminology section as well?\r\n\r\n### Key\r\n\r\nThe draft currently uses \"name\" instead of \"key\" as we had agreed in the meeting.  I suspect that this is because 8259 uses \"name.\"  Since we're trying to align with that, I've left in \"name.\"\r\n\r\n### Index\r\n\r\nWe discussed using \"index\" as a generic term for either a numeric index for arrays or a name for objects.  However in editing this section, I'm starting to second-guess that decision.\r\n\r\nGiven that we've opted to define a union selector as taking as arguments \"indices,\" \"slices,\" and/or \"filters,\" I don't think it's too much of a stretch to separately include \"indices\" and \"names.\"  Because of this, I left the definition of \"index\" as is.\r\n\r\nThis also addresses the tendency to associate \"index\" with arrays, as @glyn had mentioned.\r\n\r\nI'm leaving the changes to \"union selector\" to include all of the various things it can accept for another PR as this is solely to clean up terminology.\r\n\r\n### Emphasizing terms\r\n\r\nI tried capitalizing defined terms to emphasize their special meaning.  It got weird to read, though, since they're used so frequently.  Maybe not _every_ instance of the terms needs to be emphasized.  I'm not sure.  Happy to discuss.\r\n\r\nI've left this change out for now, but there are definitely inconsistencies present already.\r\n",
      "createdAt": "2021-05-12T10:40:26Z",
      "updatedAt": "2021-06-15T09:37:29Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "43d2e974d64d8f450c7bbc68a9db6d49219343ec",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "84-terminology",
      "headRefOid": "fc8dddbeaa487bb47519d59fb33e0b332083bd66",
      "closedAt": "2021-06-15T09:37:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> Resolves #84\r\n> \r\n> ## Alterations\r\n> * Removed `Value`, `Object`, and `Array` since they are defined in 8259.  Replaced with extended verbiage at the beginning of the section that declares that 8259 applies.\r\n> * Replaced \"JSON value\" with \"value\" in line with the above.\r\n\r\nNot good.\r\n\r\nIs there a reason you want to cause this regression?\r\n\r\nGr\u00fc\u00dfe, Carsten\r\n",
          "createdAt": "2021-05-12T13:51:13Z",
          "updatedAt": "2021-05-12T13:51:13Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a reason you want to cause this regression?\n\nIs it a regression?  The spec already had text that it pulled these terms from 8259 and that we don't consider them in terms of their general programming usages.  It's redundant to define them again.\n\nI think it makes sense to claim these terms as defined the same way.  We don't redefine \"MUST\" _et. al._, we claim them from 2119.",
          "createdAt": "2021-05-13T04:44:12Z",
          "updatedAt": "2021-05-13T04:44:12Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> > Is there a reason you want to cause this regression?\r\n> \r\n> Is it a regression? The spec already had text that it pulled these terms from 8259 and that we don't consider them in terms of their general programming usages. It's redundant to define them again.\r\n> \r\n> I think it makes sense to claim these terms as defined the same way. We don't redefine \"MUST\" _et. al._, we claim them from 2119.\r\n\r\nThe current text does point to 8259 and doesn't redefine terms.  Where 8259 defines \"bed\" as \"table\", this is mentioned and possibly detailed once more, which I think is needed for readers who aren't totally immersed in 8259's terminology.\r\nWhy do you want to make it harder to use the specification?\r\n\r\n(Geez, have you ever actually read 8259?  It doesn't actually define the terms.)\r\n\r\nCrystallizing the definitions for use in JSONpath serves a purpose.\r\n\r\nWhy do you think it is detrimental to remind readers that object does not have the English meaning in this document?\r\n\r\nI'd rather spend time on constructive PRs.\r\n\r\nGr\u00fc\u00dfe, Carsten\r\n",
          "createdAt": "2021-05-13T05:43:48Z",
          "updatedAt": "2021-05-13T05:43:48Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Where 8259 defines \"bed\" as \"table\"... \n\nI think we have a confusion.  When I say \"8259\", mean [this RFC](https://datatracker.ietf.org/doc/html/rfc8259) (also denoted by `{{-json}}` in the raw text) which is what it appears the spec is referencing. It doesn't even _contain_ the word \"bed\".  So I have no idea what you're talking about.\n\nThat spec very clearly defines all of the terms that I've removed.\n\n> Crystallizing the definitions for use in JSONpath serves a purpose.\n\nMy concern is redefinition.  It doesn't make sense to define it in two places.  The common practice (as I've seen) is to refer to existing definitions.  Since we're relying heavily on the definition of JSON anyway, it makes sense to just reference those definitions.  Anyone unfamiliar with JSON should want to read that spec as well.\n\n> Why do you think it is detrimental to remind readers that object does not have the English meaning in this document?\n\nI _do_ keep the callout that we're not using the English meaning of \"object\" and \"array.\" I've just moved it up to the text where I claim the definitions from the JSON spec.",
          "createdAt": "2021-05-13T20:08:01Z",
          "updatedAt": "2021-05-13T20:08:01Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 13. May 2021, at 22:08, Greg Dennis ***@***.***> wrote:\n> \n> Where 8259 defines \"bed\" as \"table\"...\n> \n> I think we have a confusion.\n> \n\nYes.  It just didn\u2019t occur to me that this cultural reference may be completely obvious to Germans but almost inaccessible to people from other native languages.\n\nHere are references to the short story that should be mandatory reading for anyone working on terminology (or, actually, anyone communicating).\n(Germans tend to encounter it in school, at around 8th grade.)\n\nhttps://www.deutschunddeutlich.de/contentLD/GD/GT67cTischistTisch.pdf\nhttp://www.barbarafaessler.com/files/BichselAtableisatable.pdf (English translation of unknown quality)\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-05-13T22:07:14Z",
          "updatedAt": "2021-05-13T22:07:14Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting story, but I don't really get your purpose in referencing it.  We're not swapping terms between our spec and 8259.",
          "createdAt": "2021-05-14T06:04:31Z",
          "updatedAt": "2021-05-14T06:04:31Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "just to let you know ... I won't be active until Wednesday next week ...\n\nCheers\n--\nsg\n",
          "createdAt": "2021-05-14T06:17:13Z",
          "updatedAt": "2021-05-14T06:17:13Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I find the definitions in 8259 rather confusing. Take _object_ for example. 8259 contains the following statements:\r\n1. A JSON text is a serialized value.\r\n2. `JSON-text = ws value ws`\r\n3. A JSON value MUST be an object, array, number, or string, or one of the following three literal names: [...]\r\n4. An object structure is represented as a pair of curly brackets surrounding zero or more name/value pairs (or members).\r\n\r\nOne way to read statement 1 is that a value is serlalized to produce JSON text and therefore a value is not itself in serial form. But statement 2 seems to imply that a value _is_ in serial form. So I think statement 1 has to be read as \"A JSON text is a value in a serialized form.\"\r\n\r\nIf a value is in a serialized form, then statement 3 implies that an object is also in a serialized form.\r\n\r\nBut statement 4 is then confusing:\r\n* It seems to be defining an object structure rather than an object.\r\n* It's probably trying to define an object and say that an object is a structure (in the normal use of the word).\r\n* It says an object (structure) \"_is represented as_ a pair of curly brackets [...]\", but if an object is a serialized thing, it _is_ a pair of curly brackets etc. (Or, perhaps better, an object _consists of_ a pair of curly brackets etc.)\r\n\r\nI'm not sure whether we should attempt to clarify this in the JSONPath spec or submit an erratum to 8259 - probably the latter makes more sense.\r\n",
          "createdAt": "2021-05-15T06:24:07Z",
          "updatedAt": "2021-05-15T06:24:07Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "8259 is what it is.  It was created in a politically difficult situation, and it turned out better than many of us had feared.  But it is a rather poor document, and the errata process is not designed to fix its problems.\r\n\r\nBut the situation is actually worse.  When writing the JSONpath specification, we have to think about its audience and not about how we ourselves would like this document to be.  Most people who will read the JSONpath specification will come out of one of the JSON sub-ecosystems and will think that they know what JSON is.  They won't read 8259 just because we reference it.  It simply is not helpful to defer to 8259, we have to make sure that the terms we need are introduced properly.  (Not *defined* -- that is indeed what 8259 needs to be the authoritative reference for.). This is more important because the 8259 terminology is peculiar (its accidental or deliberate ambiguities served its purpose well in the painstaking 8259 process, but that doesn't mean it's particularly good for specifications that actually make use of JSON).\r\n\r\nI wish we could focus on creating a good document for its audience, instead of discussing whether something theoretically needs to be brought up or not.\r\n",
          "createdAt": "2021-05-15T07:05:20Z",
          "updatedAt": "2021-05-15T07:05:20Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo that was well-stated.  I will try to make another round of edits to reinsert these in such a way that clarity is provided without redefining them.",
          "createdAt": "2021-05-15T07:25:40Z",
          "updatedAt": "2021-05-15T07:25:40Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo @goessner @glyn I've made some updates.  Just tagging you in.",
          "createdAt": "2021-05-29T22:52:47Z",
          "updatedAt": "2021-05-29T22:52:47Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "This draft is still mostly a collection of regressions.\r\nE.g., the section about strings is seriously misleading.\r\nThere is no point in this spec explaining JSON inner workings.\r\n(And, of course, that is similar to the symptoms of acting like the definitions in 8259, which aren't really proper definitions anyway, are useful here.)",
          "createdAt": "2021-06-11T07:58:40Z",
          "updatedAt": "2021-06-11T07:58:40Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Oops.  The commit text \"slightly fixed #97\" triggered the automatic close of this PR.\r\nThat was not my intention...",
          "createdAt": "2021-06-14T10:34:26Z",
          "updatedAt": "2021-06-14T10:34:26Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "All pertinent details replicated inn #102.  Closing this.",
          "createdAt": "2021-06-15T09:37:24Z",
          "updatedAt": "2021-06-15T09:37:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3OTA2MTA1",
          "commit": {
            "abbreviatedOid": "892a3cc"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-12T13:45:44Z",
          "updatedAt": "2021-05-12T13:45:45Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n: A name/value pair in an object.  (Not itself a value.)\r\n```",
              "createdAt": "2021-05-12T13:45:45Z",
              "updatedAt": "2021-05-12T13:46:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3OTExMjE4",
          "commit": {
            "abbreviatedOid": "892a3cc"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-12T13:49:57Z",
          "updatedAt": "2021-05-12T13:49:57Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "It would be good to delete this parenthetical remark if/when XML is relegated to an appendix (which could then use \"XML element\" instead).",
              "createdAt": "2021-05-12T13:49:57Z",
              "updatedAt": "2021-05-12T13:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NTc5NzEx",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T04:45:30Z",
          "updatedAt": "2021-05-13T04:45:31Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Will leave for a follow-up PR.  (Ref #96)",
              "createdAt": "2021-05-13T04:45:31Z",
              "updatedAt": "2021-05-13T04:46:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjA4NTQ0",
          "commit": {
            "abbreviatedOid": "722eb58"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T05:56:50Z",
          "updatedAt": "2021-05-13T05:56:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Please indicate where 8259 defines \"string\".",
              "createdAt": "2021-05-13T05:56:51Z",
              "updatedAt": "2021-05-13T05:56:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjEwNjc4",
          "commit": {
            "abbreviatedOid": "b5006a2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T06:02:05Z",
          "updatedAt": "2021-05-13T06:02:05Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "The definitional aspect of the Output Path is that it is output.  The fact that it is normalized is certainly interesting, but not definitional.  Normalized paths could occur anywhere.  Output Paths occur at the output.",
              "createdAt": "2021-05-13T06:02:05Z",
              "updatedAt": "2021-05-13T06:02:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjEwOTAy",
          "commit": {
            "abbreviatedOid": "b5006a2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T06:02:36Z",
          "updatedAt": "2021-05-13T06:02:36Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "The definition is not a replacement for the exposition in the text.",
              "createdAt": "2021-05-13T06:02:36Z",
              "updatedAt": "2021-05-13T06:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjExMTg4",
          "commit": {
            "abbreviatedOid": "b5006a2"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T06:03:20Z",
          "updatedAt": "2021-05-13T06:03:21Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "We are still in the initial exposition, so redundancy is good here.",
              "createdAt": "2021-05-13T06:03:20Z",
              "updatedAt": "2021-05-13T06:03:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjM2ODg3",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T06:56:02Z",
          "updatedAt": "2021-05-13T06:56:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "https://datatracker.ietf.org/doc/html/rfc8259#section-7",
              "createdAt": "2021-05-13T06:56:02Z",
              "updatedAt": "2021-05-13T06:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjQ3NjE3",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T07:14:48Z",
          "updatedAt": "2021-05-13T07:14:49Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yes.\r\n\r\n```\r\n   A string begins and ends with\r\n   quotation marks.  All Unicode characters may be placed within the\r\n   quotation marks, except for the characters that MUST be escaped:\r\n   quotation mark, reverse solidus, and the control characters (U+0000\r\n   through U+001F).\r\n```\r\n\r\nThese are not the strings JSONPath uses.",
              "createdAt": "2021-05-13T07:14:48Z",
              "updatedAt": "2021-05-13T07:14:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjQ4NDMz",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T07:16:12Z",
          "updatedAt": "2021-05-13T07:16:13Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "- `Node` is defined as a value and a location.\r\n- `Nodelist` is defined as a collection of nodes.  The definition also mentions that the output of a query is a nodelist.\r\n- Both the \"Processing Model\" and \"Sematics\" sections also mention that the output is a nodelist.  Moreover, \"Processing Model\" says that each selector produces a nodelist which is then used as the input to the next selector.\r\n\r\nIt seems to me that the output is already well-defined by the above.\r\n\r\nIf we also declare that the location portion of a node needs to be represented with a normalized path, then we get for free that the paths in the output are a normalized path (because the output is a list of nodes), and we don't need to define what an \"output path\" is.\r\n\r\nHowever, \"normalized path\" still needs to be defined.  This is illustrated by your statement:\r\n\r\n> Normalized paths could occur anywhere.\r\n\r\nI don't think we need to have a special-case definition for a path that occurs in the output.",
              "createdAt": "2021-05-13T07:16:12Z",
              "updatedAt": "2021-05-13T07:16:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjQ5NTk3",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T07:18:05Z",
          "updatedAt": "2021-05-13T07:18:05Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Please explain why.  The root node is by definition the entire argument.",
              "createdAt": "2021-05-13T07:18:05Z",
              "updatedAt": "2021-05-13T07:18:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjUxODk3",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T07:21:37Z",
          "updatedAt": "2021-05-13T07:21:37Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "The word \"query\" has no other usage within this spec other than to represent a JSONPath query.  The redundancy doesn't help clarify anything.  (It also appears I missed removing some self-references.)",
              "createdAt": "2021-05-13T07:21:37Z",
              "updatedAt": "2021-05-13T07:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NjY5MTY5",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T07:50:19Z",
          "updatedAt": "2021-05-13T07:50:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think the ones you're thinking of relate to \"names\" in a bracket-selector or filter expression.  These are currently discussed in the \"union selector\" -> \"child\" -> \"syntax\" section, where it's given effectively the same definition as 8259 except that single quotes are also allowed.\r\n\r\nI see the argument to add a \"string\" definition to account for the support of single-quotes.",
              "createdAt": "2021-05-13T07:50:19Z",
              "updatedAt": "2021-05-13T07:50:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzNDI1NTY2",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-19T16:28:44Z",
          "updatedAt": "2021-05-19T16:28:45Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "In fact the root node is not a node initially, as it lacks a name by nature. Similar to your formulation, the root node formally becomes a node by always getting the name '$' assigned by convention. \r\n\r\nYour formulation\r\n\r\n`... refer to the root node of the argument`\r\n\r\nsomehow contradicts your comment\r\n\r\n`The root node is by definition the entire argument.` \r\n\r\nand also somehow confuses below  by ...\r\n\r\n`... executed against a value, the *argument* ...`\r\n\r\nBTW the definition above  is cristal clear, as the *argument* is the value of the *root node*. \r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2021-05-19T16:28:44Z",
              "updatedAt": "2021-05-19T16:28:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzNDYzNDgx",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-19T17:08:25Z",
          "updatedAt": "2021-05-19T17:08:25Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I think we agree with the following ...\r\n\r\n* JSONPath is *selecting* only, not *processing*.\r\n* Analytical post processing on the query result is heavily demanded by users.\r\n\r\nI do like that brillant *extension points* concept a lot. So question is: Can we open the door for analytical post processing via those *extension points*? If so, the spec must provide certainty to implementors regarding *output path* format, which should be either/or ...\r\n\r\n* list of selected values\r\n* list of normalized pathes\r\n\r\nSo an *output path* always should have *normalized path* format in my opinion.",
              "createdAt": "2021-05-19T17:08:25Z",
              "updatedAt": "2021-05-19T17:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcxNzc2NTU2",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-29T22:12:11Z",
          "updatedAt": "2021-05-29T22:12:11Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "> So an output path always should have normalized path format in my opinion.\r\n\r\nI'm not arguing this.  I'm questioning whether we need \"output path\" as an explicit definition.\r\n\r\nTo me, \"output path\" is just a normalized path that happens to be in the output.  There's nothing really special about it that requires a definition.  We _do_ need to define the output somewhere, but it's not a definition or term; it's a feature and requires its own section.\r\n\r\n\"Normalized path,\" on the other hand, is precisely what the current definition is describing:\r\n\r\n> A simple form of JSONPath expression that identifies a node by providing a query that results in exactly that node.",
              "createdAt": "2021-05-29T22:12:11Z",
              "updatedAt": "2021-05-29T22:12:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcxNzc3NTU0",
          "commit": {
            "abbreviatedOid": "b9a8483"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-29T22:36:27Z",
          "updatedAt": "2021-05-29T22:36:27Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "> In fact the root node is not a node initially - @goessner \r\n\r\nNot quite.  \"Argument\" is already defined as a value (not a node):\r\n\r\n```\r\nShort name for the value a JSONPath expression is applied to.\r\n```\r\n\r\nThis means that \"entire value of the argument\" is redundant.  My change simply removes the redundancy.  \"Root node of the argument\" identifies the top-level location of the initial JSON value.",
              "createdAt": "2021-05-29T22:36:27Z",
              "updatedAt": "2021-05-29T22:36:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDY2NDg5",
          "commit": {
            "abbreviatedOid": "34ba61b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T05:41:39Z",
          "updatedAt": "2021-06-11T05:41:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNTYxMDg1",
          "commit": {
            "abbreviatedOid": "34ba61b"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I really don't have time to reread the entire set of changes, but this snippet seriously discourages me from spending any time at all.\r\n",
          "createdAt": "2021-06-11T08:05:15Z",
          "updatedAt": "2021-06-11T08:06:35Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "That is *NOT* what a string is for the purpose of this specification.\r\nWe do not need to confuse our readers.\r\n(It also is completely unrelated to the JSON syntax.)",
              "createdAt": "2021-06-11T08:05:15Z",
              "updatedAt": "2021-06-11T08:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNTk5MDMz",
          "commit": {
            "abbreviatedOid": "34ba61b"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T08:48:06Z",
          "updatedAt": "2021-06-11T08:48:06Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Maybe you should try offering an alternative because this is PRECISELY what a string is for JSON Path: a single- or double-quoted sequence of characters.  JSON uses UTF-8, so that's what I proposed.  If you think it can be better, how so?",
              "createdAt": "2021-06-11T08:48:06Z",
              "updatedAt": "2021-06-11T08:48:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDQ3NjMy",
          "commit": {
            "abbreviatedOid": "34ba61b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:56:05Z",
          "updatedAt": "2021-06-11T16:56:05Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Replace the back-tick with a single quote:\r\n```suggestion\r\n: A sequence of UTF-8 characters surrounded by either single quotes (')\r\n```",
              "createdAt": "2021-06-11T16:56:05Z",
              "updatedAt": "2021-06-11T16:56:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDUwOTA3",
          "commit": {
            "abbreviatedOid": "34ba61b"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks ok to me except the erroneous back-tick needs to be replaced with a single quote.\r\n\r\nI see this PR as not necessarily the end of clarifying the terminology, but as a good step along the road.",
          "createdAt": "2021-06-11T17:00:23Z",
          "updatedAt": "2021-06-11T17:00:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjkxOTkw",
          "commit": {
            "abbreviatedOid": "fcc85db"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-12T03:22:37Z",
          "updatedAt": "2021-06-12T03:22:37Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Committed. Nice catch.",
              "createdAt": "2021-06-12T03:22:37Z",
              "updatedAt": "2021-06-12T03:22:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzAyNzU0",
          "commit": {
            "abbreviatedOid": "fcc85db"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-12T06:49:13Z",
          "updatedAt": "2021-06-12T06:49:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyODYzNDg5",
          "commit": {
            "abbreviatedOid": "fc8dddb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T12:43:31Z",
          "updatedAt": "2021-06-14T12:43:31Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "So do you want to keep the deletion of \"member\" and this and the below changes (which would unfix some nits)?",
              "createdAt": "2021-06-14T12:43:31Z",
              "updatedAt": "2021-06-14T12:43:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY3MDk3Nzgx",
      "title": "Selectors reworked ...",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/98",
      "state": "CLOSED",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... Filter selectors added",
      "createdAt": "2021-06-10T17:11:17Z",
      "updatedAt": "2021-06-16T10:47:44Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "4b8e9e9f05cb20d905e0c863c02a905c321af51f",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "1dfeb0556ed4a503e6fbef38c2d66044660a9ede",
      "closedAt": "2021-06-16T10:47:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "This PR (actually PR #98) appears to revert all the fixes in 9be270d\r\nIs this intentional?",
          "createdAt": "2021-06-11T05:02:05Z",
          "updatedAt": "2021-06-11T05:02:05Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "hmm .. so we generally prefer readable characters over their unicode \nrepresentation ?\n\nI will change that (back).\n\nAm 11.06.2021 um 07:02 schrieb cabo:\n>\n> This PR (actually PR #98 \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/98>) \n> appears to revert all the fixes in 9be270d \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/commit/9be270da87994afe10cb4424cf39413114de1472>\n> Is this intentional?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/98#issuecomment-859266332>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABFM6WVPPRVPUGQNFCNXCNTTSGKFVANCNFSM46O5XMJQ>.\n>\n>\n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n> \tVirenfrei. www.avg.com \n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n>\n>\n> <#DAB4FAD8-2DD7-40BB-A1B8-4E2AA1F9FDF2>\n\n",
          "createdAt": "2021-06-11T05:16:59Z",
          "updatedAt": "2021-06-11T05:16:59Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Indeed, I do prefer readable documents over unreadable ones :-)\r\n\r\nWe can discuss this, but my question really was about undoing a change that I thought we had agreed to make.\r\n",
          "createdAt": "2021-06-11T05:21:17Z",
          "updatedAt": "2021-06-11T05:21:17Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": ">  I will change that (back).\r\n\r\nPlease use the branch pr-98 or merge it, before generating more changes.\r\n\r\n(My tools have a hard time juggling multiple branches that are called main, hence I created that branch to make my fixes.)\r\n\r\n",
          "createdAt": "2021-06-11T05:24:32Z",
          "updatedAt": "2021-06-11T05:24:32Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I would like to thank all for those valuable comments and requested changes.\n\nI will accept most changes without further comments.\n\nCan return to here tomorrow at the earliest.\n\n--\nsg\n",
          "createdAt": "2021-06-11T09:12:24Z",
          "updatedAt": "2021-06-11T09:12:24Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@goessner please rebase",
          "createdAt": "2021-06-14T09:50:59Z",
          "updatedAt": "2021-06-14T09:50:59Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "... had problems rebasing ... made a fresh clone instead.\n--\nsg\n\n\nAm 14.06.2021 um 11:51 schrieb Glyn Normington:\n>\n> @goessner <https://github.com/goessner> please rebase\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/98#issuecomment-860554151>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABFM6WTKY3EABSEYK3DWZM3TSXGJHANCNFSM46O5XMJQ>.\n>\n>\n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n> \tVirenfrei. www.avg.com \n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n>\n>\n> <#DAB4FAD8-2DD7-40BB-A1B8-4E2AA1F9FDF2>\n\n",
          "createdAt": "2021-06-14T15:12:06Z",
          "updatedAt": "2021-06-14T15:12:06Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "... and I went ahead and did what I think is a full rebase, with all the changes, no conflicts, and a correct build.  Now #102.",
          "createdAt": "2021-06-14T15:38:58Z",
          "updatedAt": "2021-06-14T15:38:58Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": ">  #102.\r\n\r\n... and I put in a short review there as well.",
          "createdAt": "2021-06-14T16:11:52Z",
          "updatedAt": "2021-06-14T16:11:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxMzYyOTQy",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "It's wonderful to see a PR covering filters and descendants. Well done @goessner!\r\n\r\nThe downside is that the PR is quite large and I ran out of steam in my initial sitting. In other words, I'll probably have more detailed comments next time I look.\r\n\r\nI would have preferred a separate PR for descendants and then a series of PRs gradually filling out filter expressions, so that detailed review is more feasible. Once we get two or three people's comments on this PR, it's likely to become unmanageable.",
          "createdAt": "2021-06-11T00:45:10Z",
          "updatedAt": "2021-06-11T01:19:50Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "```suggestion\r\nA dot selector combined with a single asterisk is a wild card. It selects all member values of an object as well as all elements of an array. Applying the `dot-wild-selector` to a primitive JSON value (a number, string, or literal) selects\r\nno value.\r\n```",
              "createdAt": "2021-06-11T00:45:10Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 158,
              "body": "```suggestion\r\nThe dot wild card selector has the form `'.*'`.\r\n```",
              "createdAt": "2021-06-11T00:45:46Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 138,
              "body": "```suggestion\r\nMember names containing other ASCII characters than allowed by `dot-selector` &ndash; especially space `' '` and minus `'-'` characters MUST NOT be used with the `dot-selector`. Member names containing these MAY be addressed by the `index-selector` instead. \r\n```",
              "createdAt": "2021-06-11T00:46:20Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 342,
              "body": "```suggestion\r\nThe index wild card selector has the form `'[*]'`.\r\n```",
              "createdAt": "2021-06-11T00:48:12Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 355,
              "body": "```suggestion\r\nAn index selector combined with a single asterisk is a wild card. It selects all member values of an object as well as all elements of an array. Applying the `index-wild-selector` to a primitive JSON value (a number, string, or literal) selects no value. The `index-wild-selector` behaves identically to the `dot-wild-selector`.\r\n```",
              "createdAt": "2021-06-11T00:49:41Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 369,
              "body": "```suggestion\r\nThe array slice selector has the form `'[<start>:<end>:<step>]'`. It selects elements starting at index `<start>`, ending at &ndash; but not including &ndash; `<end>`, while incrementing by `step`.\r\n```",
              "createdAt": "2021-06-11T00:51:10Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 446,
              "body": "The semantics needs to be expanded (to make it clear how each kind of descendant selector applies to the various kinds of values) and the order of enumeration needs to be specified.",
              "createdAt": "2021-06-11T00:58:33Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 467,
              "body": "```suggestion\r\nAny duplicated selected nodes are kept in the node list.\r\n```",
              "createdAt": "2021-06-11T01:01:35Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 482,
              "body": "```suggestion\r\nThe current item is selected if and only if the result is `true`.\r\n```",
              "createdAt": "2021-06-11T01:04:05Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 513,
              "body": "```suggestion\r\n* Types are not implicitly converted in comparisons. So `\"13 == '13'\"` selects no value.\r\n```",
              "createdAt": "2021-06-11T01:07:49Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 514,
              "body": "```suggestion\r\n* A member or element value by itself is *falsy* only, if it does not exist. Otherwise it is *truthy*, resulting in its value. To be more specific explicit comparisons are necessary. This existence test &ndash; as an exception of the general rule &ndash; also works with complex values.\r\n```",
              "createdAt": "2021-06-11T01:08:16Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 517,
              "body": "```suggestion\r\n* Explicit boolean type conversion is done by the not operator `neg-op`.\r\n```",
              "createdAt": "2021-06-11T01:08:46Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 514,
              "body": "Please define the terms _truthy_ and _falsy_. ",
              "createdAt": "2021-06-11T01:11:41Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 517,
              "body": "```suggestion\r\n* Explicit boolean type conversion is done by the not operator `neg-op`.\r\n```\r\nbut what does this mean?",
              "createdAt": "2021-06-11T01:12:50Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 518,
              "body": "This statement seems out of place in the syntax section. Do we need an \"Informal Semantics\" section?",
              "createdAt": "2021-06-11T01:13:41Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            },
            {
              "originalPosition": 506,
              "body": "Please define the semantics of `index` in the semantics section.",
              "createdAt": "2021-06-11T01:15:21Z",
              "updatedAt": "2021-06-11T01:19:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDMzNDA5",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I agree that these sets of changes (the selectors and defining the filters) could have been better served in two PRs, but this looks like a good start.",
          "createdAt": "2021-06-11T04:08:16Z",
          "updatedAt": "2021-06-11T06:04:03Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "This is interesting.  You're claiming the thing that's named \"Argument\" is anonymous, but once referenced with `$` it suddenly has a name?  I'm not sure this provides any benefit over just saying that the Argument _is_ the root node and can be referenced with `$`.",
              "createdAt": "2021-06-11T04:08:16Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 130,
              "body": "This definition also resolves #16 (and duplicate #94). \ud83d\udc4d ",
              "createdAt": "2021-06-11T04:09:44Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 138,
              "body": "This is more of a Path authorship suggestion rather than a requirement of the specification (as would be enforced by an implementation).\r\n\r\nFor example, simply implementing the prescribed syntax would enforce that these characters are invalid.  The implementation can't (or probably shouldn't) coerce such a syntax error into the \"index-selector\" syntax.  It's up to the author of the Path to build a syntactically correct Path.\r\n\r\nI think we need to (as a policy) highlight such authorship suggestions separately from the requirements.",
              "createdAt": "2021-06-11T04:17:18Z",
              "updatedAt": "2021-06-11T06:04:04Z"
            },
            {
              "originalPosition": 150,
              "body": "Good use of \"undefined behavior\" \ud83d\udc4d ",
              "createdAt": "2021-06-11T04:18:55Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 226,
              "body": "What is the `*` for in `*double-quoted`?  The other components (e.g. `ESC` and `unescaped`) don't have them.",
              "createdAt": "2021-06-11T04:21:56Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 280,
              "body": "Should we just specify that the number must be base-10?  This would also exclude hexadecimal formats such as `0xf312`.",
              "createdAt": "2021-06-11T04:24:09Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 329,
              "body": "We need to add verbiage that says an index outside of the bounds of the array (positive or negative) selects no nodes.",
              "createdAt": "2021-06-11T04:29:21Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 63,
              "body": "I don't think we need all of the surrounding single quotes, e.g. \r\n\r\n```\r\n`'$'`\r\n```\r\n\r\nshould just be\r\n\r\n```\r\n`$`\r\n```\r\n\r\nYou've used a backtick to format the text, which (to me at least) suggests that the content of the formatted text is the selector, which is `'$'` rather than just `$`.\r\n\r\n```suggestion\r\n  * Root selector `$`\r\n  * Dot selector `.<name>`, used with object member names exclusively.\r\n  * Dot wild card selector `.*`.\r\n  * Index selector `[<index>]`, where `<index>` is either an (possibly negative) array index or an object member name.\r\n  * Index wild card selector `[*]`.\r\n  * Array slice selector `[<start>:<end>:<step>]`, where `<start>`, `<end>`, `<step>` are integer literals.\r\n  * Nested descendants selector `..`.\r\n  * Union selector `[<sel1>,<sel2>,...,<selN>]`, holding a comma delimited list of selectors.\r\n  * Filter selector `[?(<expr>)]`\r\n  * Current item selector `@`\r\n```\r\n\r\nI also noticed that you're using the extra single quotes in a lot of other places.  I'm not going to comment on every usage.",
              "createdAt": "2021-06-11T04:39:37Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 379,
              "body": "Are `ws` components required?  That would suggest we need it in the other selectors.\r\n\r\nMaybe we can leave it out (or at least unchanged) until we figure out #24.  There are other places that include `ws` as well.",
              "createdAt": "2021-06-11T04:49:47Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 392,
              "body": "This change doesn't allow for the second colon also being optional (e.g. `:` or `2:4`).",
              "createdAt": "2021-06-11T04:51:26Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 433,
              "body": "The allowances of this selector are somewhat different than the `dot-selector`, so I don't think it's right to say that the `descendant-selector` can _replace_ the `dot-selector`.  I think we should just treat its syntax on its own rather than comparing it to another selector.",
              "createdAt": "2021-06-11T05:07:24Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 460,
              "body": "I would say that _any_ of the valid index selectors would be valid here, including a filter selector.  As such, it may make sense to move this section below the `filter-selector` section.\r\n\r\nAlthough it might not make sense to do so, it may be valid to include a wildcard as well, e.g. `[1, *]`",
              "createdAt": "2021-06-11T05:11:21Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 511,
              "body": "Do we have a consensus for supporting expressions without the parentheses?  I don't remember this change being discussed.",
              "createdAt": "2021-06-11T05:19:33Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 474,
              "body": "You seem to be missing a closing angle bracket `>`, e.g. `<expr` vs `<expr>`.  The error is present every time this example syntax is used.",
              "createdAt": "2021-06-11T05:21:16Z",
              "updatedAt": "2021-06-11T06:04:03Z"
            },
            {
              "originalPosition": 505,
              "body": "I'm not sure we have a precedence or decision on functions/calculated values yet (`index()` or otherwise).  It's probably best to leave this out until we can identify a family of functions that we'd like to include so that we can decide on a format that works for everything.",
              "createdAt": "2021-06-11T05:30:34Z",
              "updatedAt": "2021-06-11T06:04:04Z"
            },
            {
              "originalPosition": 492,
              "body": "`container` needs a definition",
              "createdAt": "2021-06-11T05:31:51Z",
              "updatedAt": "2021-06-11T06:04:04Z"
            },
            {
              "originalPosition": 484,
              "body": "Did we decide against arithmetic operations?  These are widely supported and should (perhaps eventually) be supported.",
              "createdAt": "2021-06-11T05:45:47Z",
              "updatedAt": "2021-06-11T06:04:04Z"
            },
            {
              "originalPosition": 514,
              "body": "Perhaps instead simply drop \"truthy\" and \"falsy\" in favor of just saying that a `rel-path-value` by itself select the item if the relative path can be resolved (or some such language).\r\n\r\nHaving \"truthy\" and \"falsy\" at all contradicts the \"explicit comparisons are necessary\" statement since these terms are typically used in systems with loose comparisons.",
              "createdAt": "2021-06-11T05:54:01Z",
              "updatedAt": "2021-06-11T06:04:04Z"
            },
            {
              "originalPosition": 504,
              "body": "I would suggest support for any selector except another filter selector (but it may be supported later).  This would allow further support for things like `$[?(@..foo contains 42)]` which would return true for any item that contains a `foo` property with a value of `42` at any descended level.",
              "createdAt": "2021-06-11T05:59:43Z",
              "updatedAt": "2021-06-11T06:04:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTQ1MjY3",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:19:48Z",
          "updatedAt": "2021-06-14T06:19:48Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Yes, as an autor hint it should be moved elsewhere.",
              "createdAt": "2021-06-14T06:19:48Z",
              "updatedAt": "2021-06-14T06:19:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTQ3MDky",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:23:37Z",
          "updatedAt": "2021-06-14T06:23:38Z",
          "comments": [
            {
              "originalPosition": 514,
              "body": "Instead define it, dropping is better.",
              "createdAt": "2021-06-14T06:23:38Z",
              "updatedAt": "2021-06-14T06:23:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTQ4ODAy",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:27:05Z",
          "updatedAt": "2021-06-14T06:27:05Z",
          "comments": [
            {
              "originalPosition": 517,
              "body": "... look at the table near by. Converting numbers, strings to booleans, as done in C language. ",
              "createdAt": "2021-06-14T06:27:05Z",
              "updatedAt": "2021-06-14T06:27:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTQ5NDk4",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:28:30Z",
          "updatedAt": "2021-06-14T06:28:30Z",
          "comments": [
            {
              "originalPosition": 518,
              "body": "will be moved. Not sure when to move to semantic or informal semantics section.",
              "createdAt": "2021-06-14T06:28:30Z",
              "updatedAt": "2021-06-14T06:28:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTUyNjk1",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:34:39Z",
          "updatedAt": "2021-06-14T06:34:39Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "I still needs to be discussed, if a dot-member-name is allowed to start with a DIGIT.",
              "createdAt": "2021-06-14T06:34:39Z",
              "updatedAt": "2021-06-14T06:34:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTUzNjAy",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:36:21Z",
          "updatedAt": "2021-06-14T06:36:22Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "' simply means multiple ...",
              "createdAt": "2021-06-14T06:36:21Z",
              "updatedAt": "2021-06-14T06:36:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTU1MTYx",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:39:14Z",
          "updatedAt": "2021-06-14T06:39:14Z",
          "comments": [
            {
              "originalPosition": 379,
              "body": "I would also like to drop them. Is there a general recommended way to handle them in ABNF ?",
              "createdAt": "2021-06-14T06:39:14Z",
              "updatedAt": "2021-06-14T06:39:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTU3Mjc5",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:42:49Z",
          "updatedAt": "2021-06-14T06:42:50Z",
          "comments": [
            {
              "originalPosition": 511,
              "body": "this is still a proposal ... I see no possible syntax collisons ... it is backward compatibel and lean.",
              "createdAt": "2021-06-14T06:42:49Z",
              "updatedAt": "2021-06-14T06:42:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTU3NjI3",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:43:21Z",
          "updatedAt": "2021-06-14T06:43:21Z",
          "comments": [
            {
              "originalPosition": 474,
              "body": "... good catch ..",
              "createdAt": "2021-06-14T06:43:21Z",
              "updatedAt": "2021-06-14T06:43:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTU4NTMw",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:44:51Z",
          "updatedAt": "2021-06-14T06:44:51Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "in fact i am quite reluctant here. It's a proposal needing discussion ... will most certainly result in an issue..",
              "createdAt": "2021-06-14T06:44:51Z",
              "updatedAt": "2021-06-14T06:44:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTU4OTM3",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T06:45:33Z",
          "updatedAt": "2021-06-14T06:45:34Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "yes ... or more simply\r\n\r\n`in-op (array / object)`\r\n",
              "createdAt": "2021-06-14T06:45:33Z",
              "updatedAt": "2021-06-14T06:46:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNTk0NDIy",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T07:36:04Z",
          "updatedAt": "2021-06-14T07:36:04Z",
          "comments": [
            {
              "originalPosition": 518,
              "body": "@goessner  wrote:\r\n> will be moved. Not sure when to move to semantic or informal semantics section.\r\n\r\n If by \"when\" you meant \"whether\", I think the statement should be moved to a new informal semantics section.\r\n",
              "createdAt": "2021-06-14T07:36:04Z",
              "updatedAt": "2021-06-14T07:36:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjE1MTY3",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:00:22Z",
          "updatedAt": "2021-06-14T08:00:22Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "... this is nearly the wording in E4X - where I stole that operator from. This is quite important:\r\n\r\n* Combination of descendant-operator with index operator is valid: `..['key']` as is `..[*]`\r\n* But combination of descendant-operator with dot-operator resulting in `...key` or `...*` is not.\r\n\r\nSo formulation \"can be used in place of the normal `dot-selector`\" makes this clear, in order to avoid the latter.",
              "createdAt": "2021-06-14T08:00:22Z",
              "updatedAt": "2021-06-14T08:00:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjIxNDg0",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:07:43Z",
          "updatedAt": "2021-06-14T08:07:44Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "I believe the second colon is already optional ...",
              "createdAt": "2021-06-14T08:07:43Z",
              "updatedAt": "2021-06-14T08:07:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjI1NDIx",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:12:05Z",
          "updatedAt": "2021-06-14T08:12:05Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "(This is not just about other ASCII characters, but other characters in general.)\r\n",
              "createdAt": "2021-06-14T08:12:05Z",
              "updatedAt": "2021-06-14T08:12:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjI3MzA4",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:14:10Z",
          "updatedAt": "2021-06-14T08:14:11Z",
          "comments": [
            {
              "originalPosition": 467,
              "body": "Define word duplicate (or preferable don't use it but describe what happens).",
              "createdAt": "2021-06-14T08:14:11Z",
              "updatedAt": "2021-06-14T08:14:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjI5Mzcw",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:16:28Z",
          "updatedAt": "2021-06-14T08:16:28Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "We probably should not bury the details of the expression language in the selector description.\r\n\r\nWe cannot notate complex (structured, non-atom, ...) values so I don't know how that clause would become active.\r\n\r\ns/Parenthesis/Parentheses/",
              "createdAt": "2021-06-14T08:16:28Z",
              "updatedAt": "2021-06-14T08:16:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjMzMTU5",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:20:34Z",
          "updatedAt": "2021-06-14T08:20:34Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "What does applying `.1` to `[1, 2, 3]` mean?",
              "createdAt": "2021-06-14T08:20:34Z",
              "updatedAt": "2021-06-14T08:20:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjM0MTI5",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:21:33Z",
          "updatedAt": "2021-06-14T08:21:34Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "Cannot happen.",
              "createdAt": "2021-06-14T08:21:34Z",
              "updatedAt": "2021-06-14T08:21:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNjM0ODky",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T08:22:22Z",
          "updatedAt": "2021-06-14T08:22:23Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "This should point to the string literal syntax that we are using for comparisons as well.",
              "createdAt": "2021-06-14T08:22:22Z",
              "updatedAt": "2021-06-14T08:22:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyODY1MjUx",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T12:45:20Z",
          "updatedAt": "2021-06-14T12:45:20Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "Yes, I see in the syntax graph.  Maybe this sentence could be updated, or perhaps even keep the note that this line replaces.  I think having these examples is useful.",
              "createdAt": "2021-06-14T12:45:20Z",
              "updatedAt": "2021-06-14T12:45:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyODc5NzM0",
          "commit": {
            "abbreviatedOid": "2be1afe"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T12:59:53Z",
          "updatedAt": "2021-06-14T12:59:53Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "The `descendant-selector` and `dot-selector` are completely different selectors that happen to have an overlapping syntax.  After all, `$..['foo']` is valid, but `$.['foo']` is not.\r\n\r\nTo say that `descendant-selector` can be used \"in place of\" `dot-selector` conveys replacement, which is incorrect because they do different things.  It's more correct to say that they share a similar syntax in that they both support `dot-member-name`.\r\n\r\nTo be honest, I'm not sure we need the sentence at all.\r\n\r\n```suggestion\r\nThe descendant selector starts with a double dot `'..'` and can be followed by an object member name (similar to the `dot-selector`) or by an `index-selector` acting on objects or arrays.\r\n```",
              "createdAt": "2021-06-14T12:59:53Z",
              "updatedAt": "2021-06-14T12:59:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTc2Mzk4",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:41:48Z",
          "updatedAt": "2021-06-15T05:41:49Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T05:41:48Z",
              "updatedAt": "2021-06-15T05:41:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTc4OTg3",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:47:25Z",
          "updatedAt": "2021-06-15T05:47:25Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "MAY is an interoperability keyword (RFC 2119), while this is just a suggestion for an alternative approach, so MAY seems inappropriate.  Proposed wording in #102.",
              "createdAt": "2021-06-15T05:47:25Z",
              "updatedAt": "2021-06-15T05:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTc5OTkw",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:49:22Z",
          "updatedAt": "2021-06-15T05:49:22Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T05:49:22Z",
              "updatedAt": "2021-06-15T05:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTgwMDY1",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:49:31Z",
          "updatedAt": "2021-06-15T05:49:31Z",
          "comments": [
            {
              "originalPosition": 342,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T05:49:31Z",
              "updatedAt": "2021-06-15T05:49:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTgxNTQ4",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:52:26Z",
          "updatedAt": "2021-06-15T05:52:26Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T05:52:26Z",
              "updatedAt": "2021-06-15T05:52:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTgyMjU5",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:53:48Z",
          "updatedAt": "2021-06-15T05:53:48Z",
          "comments": [
            {
              "originalPosition": 517,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T05:53:48Z",
              "updatedAt": "2021-06-15T05:53:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTgyNDE2",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:54:05Z",
          "updatedAt": "2021-06-15T05:54:05Z",
          "comments": [
            {
              "originalPosition": 517,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T05:54:05Z",
              "updatedAt": "2021-06-15T05:54:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjIzMjkz",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T06:57:25Z",
          "updatedAt": "2021-06-15T06:57:26Z",
          "comments": [
            {
              "originalPosition": 369,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T06:57:25Z",
              "updatedAt": "2021-06-15T06:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjI1NTU3",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:00:11Z",
          "updatedAt": "2021-06-15T07:00:11Z",
          "comments": [
            {
              "originalPosition": 482,
              "body": "This change properly captures whether the item should be selected if the expression fails evaluation (e.g. if `@.foo` isn't found).",
              "createdAt": "2021-06-15T07:00:11Z",
              "updatedAt": "2021-06-15T07:00:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjI3MjAy",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:02:11Z",
          "updatedAt": "2021-06-15T07:02:11Z",
          "comments": [
            {
              "originalPosition": 511,
              "body": "I'd like to see a set of examples.  The parentheses create a level of human-readability that I'm afraid will be lost by removing them.  This is, of course, subjective.  The change is completely compatible.",
              "createdAt": "2021-06-15T07:02:11Z",
              "updatedAt": "2021-06-15T07:02:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjI5MjA0",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:04:40Z",
          "updatedAt": "2021-06-15T07:04:41Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "I would say that we can notate them just fine.  An expression should be able to operate on any JSON literal.  I see no reason why `@.foo == [1, 2]` should be disallowed.",
              "createdAt": "2021-06-15T07:04:41Z",
              "updatedAt": "2021-06-15T07:04:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjMxNjg1",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:07:47Z",
          "updatedAt": "2021-06-15T07:07:47Z",
          "comments": [
            {
              "originalPosition": 467,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T07:07:47Z",
              "updatedAt": "2021-06-15T07:07:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjMzNzg3",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:10:15Z",
          "updatedAt": "2021-06-15T07:10:15Z",
          "comments": [
            {
              "originalPosition": 482,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T07:10:15Z",
              "updatedAt": "2021-06-15T07:10:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjM5Mzc4",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:16:44Z",
          "updatedAt": "2021-06-15T07:16:45Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T07:16:44Z",
              "updatedAt": "2021-06-15T07:16:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjM5ODE4",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:17:14Z",
          "updatedAt": "2021-06-15T07:17:14Z",
          "comments": [
            {
              "originalPosition": 514,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T07:17:14Z",
              "updatedAt": "2021-06-15T07:17:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjQyNjEz",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:20:18Z",
          "updatedAt": "2021-06-15T07:20:19Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "`array` and `object` don't have a definition either.\r\nDo you mean expressions that return an array or object?\r\nOr maybe just literals of these types?",
              "createdAt": "2021-06-15T07:20:18Z",
              "updatedAt": "2021-06-15T07:20:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjQ3OTY4",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:26:08Z",
          "updatedAt": "2021-06-15T07:26:08Z",
          "comments": [
            {
              "originalPosition": 511,
              "body": "Note that the parentheses can still be a convention, even if we don't require them.\r\n",
              "createdAt": "2021-06-15T07:26:08Z",
              "updatedAt": "2021-06-15T07:26:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjU0MTc4",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:32:34Z",
          "updatedAt": "2021-06-15T07:32:35Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "Resolved in #102\r\n\r\n(Of course, we can, and probably will, tweak further.)",
              "createdAt": "2021-06-15T07:32:35Z",
              "updatedAt": "2021-06-15T07:32:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjU5ODY0",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:38:35Z",
          "updatedAt": "2021-06-15T07:38:36Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "both ...\r\n\r\n`[?@.color in ['red,'green','blue']]`\r\n\r\nor \r\n\r\n`[?@.color in $.validColors]`",
              "createdAt": "2021-06-15T07:38:36Z",
              "updatedAt": "2021-06-15T07:39:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjYxMzE1",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:40:04Z",
          "updatedAt": "2021-06-15T07:40:05Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Resolved in #102",
              "createdAt": "2021-06-15T07:40:04Z",
              "updatedAt": "2021-06-15T07:40:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjYyNTU5",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:41:16Z",
          "updatedAt": "2021-06-15T07:41:16Z",
          "comments": [
            {
              "originalPosition": 280,
              "body": "That is again something that should be done in the expression language.",
              "createdAt": "2021-06-15T07:41:16Z",
              "updatedAt": "2021-06-15T07:41:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjY2NjEz",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:45:24Z",
          "updatedAt": "2021-06-15T07:45:24Z",
          "comments": [
            {
              "originalPosition": 511,
              "body": "yes ... I've seen this notation with some implementations in the wild and .. as a minimalist .. I liike it.",
              "createdAt": "2021-06-15T07:45:24Z",
              "updatedAt": "2021-06-15T07:45:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjcyOTM4",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:51:48Z",
          "updatedAt": "2021-06-15T07:51:49Z",
          "comments": [
            {
              "originalPosition": 518,
              "body": "It should perhaps read better:\r\n```\r\nSyntax and behaviour of operators is consistent with the 'C'-family of programming languages.\r\n```\r\nOtherwise we might need to add a table of operator precedence ... which would be no problem though.",
              "createdAt": "2021-06-15T07:51:48Z",
              "updatedAt": "2021-06-15T07:51:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjg1MzU5",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T08:03:37Z",
          "updatedAt": "2021-06-15T08:03:37Z",
          "comments": [
            {
              "originalPosition": 518,
              "body": "FYI: Have a look at how RFC 8949 solves that problem:\r\nhttps://www.rfc-editor.org/rfc/rfc8949.html#section-1.2-6\r\n\r\nThe IESG will insist on a reference to the C standard, I can tell you this much :-)",
              "createdAt": "2021-06-15T08:03:37Z",
              "updatedAt": "2021-06-15T08:03:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjkzOTc1",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T08:12:03Z",
          "updatedAt": "2021-06-15T08:12:03Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "We can restrict comparisons to simple values only (some say 'scalars`) . You can write here\r\n```\r\n[? @.foo[0] == 1 && @.foo[1] == 2]\r\n```\r\ninstead.\r\n\r\nBenefit in use seems to be low, but complexity might become huge otherwise. \r\n",
              "createdAt": "2021-06-15T08:12:03Z",
              "updatedAt": "2021-06-15T08:14:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNzAzODYx",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T08:21:35Z",
          "updatedAt": "2021-06-15T08:21:35Z",
          "comments": [
            {
              "originalPosition": 518,
              "body": "@Glyn: By \"when\" I mean \"whenever\" in comparable situations, should it goto\r\n\r\n* syntax\r\n* semantics\r\n* informal semantics\r\n\r\nAre there specific rules especially to allocate to the last two.",
              "createdAt": "2021-06-15T08:21:35Z",
              "updatedAt": "2021-06-15T08:21:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNzQyOTc2",
          "commit": {
            "abbreviatedOid": "1dfeb05"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T08:58:19Z",
          "updatedAt": "2021-06-15T08:58:19Z",
          "comments": [
            {
              "originalPosition": 518,
              "body": "> @glyn: By \"when\" I mean \"whenever\" in comparable situations, should it goto\r\n> \r\n>     * syntax\r\n> \r\n>     * semantics\r\n> \r\n>     * informal semantics\r\n> \r\n> \r\n> Are there specific rules especially to allocate to the last two.\r\n\r\nNo rules, but the idea with array slices was to introduce the semantics gently in the (informative) informal semantics section and then spell out the (normative) semantics, possibly more indigestibly, in the semantics section. But I am not wedded to this convention so long as we don't confuse normative and informative text.",
              "createdAt": "2021-06-15T08:58:19Z",
              "updatedAt": "2021-06-15T08:58:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY3MTcxNjA0",
      "title": "Updated Pr 98 (selectors reworked)",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/99",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "mit Fix f\u00fcr den YAML-nit",
      "createdAt": "2021-06-10T18:20:24Z",
      "updatedAt": "2021-06-16T10:48:13Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "c8597e87e9735338ceca4eb6a99c15bf5148dcf2",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "pr-98",
      "headRefOid": "31ee9bc47b4c0b5c73aa73dcfd4d830e03947a0c",
      "closedAt": "2021-06-16T10:48:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo/@goessner can you rename the PR to better reflect what it's trying to do, please?  Also a summary of changes would be kind.",
          "createdAt": "2021-06-11T03:42:16Z",
          "updatedAt": "2021-06-11T03:43:00Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "This PR (actually PR #98) reverts all the fixes in 9be270d\r\nIs this intentional?\r\n",
          "createdAt": "2021-06-11T05:00:27Z",
          "updatedAt": "2021-06-11T05:00:27Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "I understood that multiple small PR's are preferrable, which was not so \neasy with the complete rewrite of selectors. I can do that from now on.\n\nAm 11.06.2021 um 05:42 schrieb Greg Dennis:\n>\n> @goessner <https://github.com/goessner> can you rename the PR to \n> better reflect what it's trying to do, please? Also a summary of \n> changes would be kind.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/99#issuecomment-859239841>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABFM6WUCDKLUZXFSHFSYTHTTSGA2JANCNFSM46PBITVQ>.\n>\n>\n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n> \tVirenfrei. www.avg.com \n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n>\n>\n> <#DAB4FAD8-2DD7-40BB-A1B8-4E2AA1F9FDF2>\n\n",
          "createdAt": "2021-06-11T05:21:31Z",
          "updatedAt": "2021-06-11T05:21:31Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I understood that multiple small PR's are preferrable, which was not so easy with the complete rewrite of selectors. I can do that from now on.\r\n\r\n@goessner Do you mean you will now break this PR into multiple small PRs? (That would be great!)",
          "createdAt": "2021-06-11T05:27:29Z",
          "updatedAt": "2021-06-11T05:27:48Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "\n> ------------------------------------------------------------------------\n>\n> In draft-ietf-jsonpath-base.md \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/99#discussion_r649782358>:\n>\n> > @@ -97,6 +97,13 @@ informative:\n>       seriesinfo:\n>         ISO/IEC 22537:2006\n>       date: 2006\n> +  E4X-overview:\n>\n> I don't think we need this -- this seems to be a remnant from an older \n> revision.\n>\n> There are several such remnants, which make it hard to review this PR.\n>\n\noops ... should have been ES4 overview\n\nhttp://archives.ecma-international.org/2007/misc/overview.pdf\n\nHere array slice is documented the first time (pg.34)\u00a0 ... that's all.\nWe can leave it out.\n\n> >  \n>   #### Semantics\n>   {: numbered=\"false\" toc=\"exclude\"}\n>   \n> -A dot child name which is not a single asterisk (`*`) is considered to\n> -have a member name.\n> -It selects the value corresponding to the name from any object node.\n> -It selects\n> -no nodes from a node which is not a object.\n> -\n> -The member name of a dot child name is the sequence of Unicode characters contained\n> -in that name.\n> -\n> -A dot child name consisting of a single asterisk is a wild card. It selects\n> -all the values of any object node.\n> -It also selects all the elements of any array node.\n> -It selects no nodes from\n> -number, string, or literal nodes.\n> +The Argument &mdash; the root JSON value &ndash; is anonymous by nature. By getting assigned the universal name `'$'` it becomes the root node.\n>\n> Writing the actual characters instead of HTML entity references is \n> preferred.\n>\n&ndash; is not accessible per keyboard.\n>\n> The same dashes should be used at the start and at the end of an \n> interjection.\n>\nyes .. typo ..\n\n\n",
          "createdAt": "2021-06-11T09:22:20Z",
          "updatedAt": "2021-06-11T09:22:20Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "yes .. we need a new issue here .. let's discuss.\n\nAm 11.06.2021 um 10:12 schrieb cabo:\n>\n> ***@***.**** commented on this pull request.\n>\n> ------------------------------------------------------------------------\n>\n> In draft-ietf-jsonpath-base.md \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/99#discussion_r649781760>:\n>\n> > +in-op        = \" in \"                               ; in operator\n> +comparable   = number / quoted-string /             ; primitive ...\n> +               true / false / null /                ; values only\n> +               rel-path-val /                       ; descendant value\n> +               calc_val /                           ; calculated value\n> +               json-path                            ; any value\n> +\n> +rel-path-val = \"@\" *(dot-selector / index-selector)\n> +calc_val     = func \"(\" [rel-path-val / json-path] \")\"\n> +func         = \"index\"\n> +~~~~\n> +\n> +Notes:\n> +\n> +* Parenthesis can be used with `boolean-expr` for grouping. So filter selection syntax in the original proposal `'[?(<expr)]'` is naturally contained in the current lean syntax `'[?<expr]'` as a special case.\n> +* Comparisons are restricted to primitive values `number`, `string`, `true`, `false`, `null`. Comparisons with complex values will fail, i.e. no selection occurs.\n>\n> So it appears we need a new issue.\n>\n>   * Comparison with structured values\n>   * Should comparison with structured values (e.g., ***@***.*** == [1, 2]|)\n>     be supported?\n>   * If it is not supported, should this silently fail or the attempt\n>     cause a syntax error (in #99\n>     <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/99>,\n>     it causes a syntax error, but then the text says something else).\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/99#discussion_r649781760>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABFM6WUPIASBBK4FBC2V2EDTSHAQNANCNFSM46PBITVQ>.\n>\n>\n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n> \tVirenfrei. www.avg.com \n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n>\n>\n> <#DAB4FAD8-2DD7-40BB-A1B8-4E2AA1F9FDF2>\n\n",
          "createdAt": "2021-06-11T09:23:30Z",
          "updatedAt": "2021-06-11T09:23:30Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> > + E4X-overview:\n> \n> oops ... should have been ES4 overview\n> \n> http://archives.ecma-international.org/2007/misc/overview.pdf\n> \n> Here array slice is documented the first time (pg.34)  ... that's all.\n> We can leave it out.\n\nI don\u2019t have a strong opinion here, but I think we are better off referencing the current state in ES2020 (also applies to {{SLICE}}).\n\n(The bibliography entry `E4X-overview` turned up in my quick glance at the PR because it is not currently being used.  So we need to add a citation or remove the entry.  This is all housekeeping\u2026  Let\u2019s try to extract the technical discussion points first.)\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-06-11T09:35:24Z",
          "updatedAt": "2021-06-11T09:35:24Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> &ndash; is not accessible per keyboard.\r\n\r\nIt sure is.\r\nThis probably should be an `&mdash;`, however.\r\n\r\nIf you are using Windows:\r\nhttps://softwareaccountant.com/em-dash-in-word/\r\n",
          "createdAt": "2021-06-14T08:06:57Z",
          "updatedAt": "2021-06-14T08:07:10Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "ahh ... learning something new .. only*alt+0151 *on numeric keyboard \nworks for me.**\n\nAm 14.06.2021 um 10:07 schrieb cabo:\n>\n>     \u2013 is not accessible per keyboard.\n>\n> It sure is.\n> This probably should be an |&mdash;|, however.\n>\n> If you are using Windows:\n> https://softwareaccountant.com/em-dash-in-word/ \n> <https://softwareaccountant.com/em-dash-in-word/>\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/99#issuecomment-860478572>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABFM6WX7H6MN745JDHKUEKTTSW2DBANCNFSM46PBITVQ>.\n>\n>\n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n> \tVirenfrei. www.avg.com \n> <http://www.avg.com/email-signature?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=emailclient> \n>\n>\n> <#DAB4FAD8-2DD7-40BB-A1B8-4E2AA1F9FDF2>\n\n",
          "createdAt": "2021-06-14T08:28:16Z",
          "updatedAt": "2021-06-14T08:28:16Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2021-06-14, at 10:28, Stefan Goessner ***@***.***> wrote:\n> \n> ahh ... learning something new .. only*alt+0151 *on numeric keyboard \n> works for me.**\n\n\u2026 and I think this is even easier to type than &mdash; \u2026\n\n(Shift-Option-minus on the Mac.\nOn the iPad or iPhone, long-press the minus and swipe to the character you want.)\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-06-14T08:32:35Z",
          "updatedAt": "2021-06-14T08:32:35Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo please rebase",
          "createdAt": "2021-06-14T09:50:22Z",
          "updatedAt": "2021-06-14T09:50:22Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Covered by #102 now.",
          "createdAt": "2021-06-16T10:48:12Z",
          "updatedAt": "2021-06-16T10:48:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDYzMTQ5",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T05:34:06Z",
          "updatedAt": "2021-06-11T05:34:07Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "Rather than fail silently, another option would be to avoid this situation in the syntax. Then failures will produce a syntax error, which is much clearer to the user. Have you checked for consensus of current implementations? [This issue comment](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/64#issuecomment-838280246) is relevant.",
              "createdAt": "2021-06-11T05:34:06Z",
              "updatedAt": "2021-06-11T05:34:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDc5NzQy",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T06:10:42Z",
          "updatedAt": "2021-06-11T06:10:42Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "I would actually like to be able to say `@.foo == [1,2]`.  I think this is a valid use case.",
              "createdAt": "2021-06-11T06:10:42Z",
              "updatedAt": "2021-06-11T06:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNTY3MzEx",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T08:12:37Z",
          "updatedAt": "2021-06-11T08:12:37Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "So it appears we need a new issue.\r\n\r\n* Comparison with structured values\r\n* Should comparison with structured values (e.g., `@.foo == [1, 2]`) be supported?\r\n* If it is not supported, should this silently fail or the attempt cause a syntax error (in #99, it causes a syntax error, but then the text says something else).\r\n",
              "createdAt": "2021-06-11T08:12:37Z",
              "updatedAt": "2021-06-11T08:12:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNTY4MDY4",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "A few initial impressions.",
          "createdAt": "2021-06-11T08:13:30Z",
          "updatedAt": "2021-06-11T08:20:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't think we need this -- this seems to be a remnant from an older revision.\r\n\r\nThere are several such remnants, which make it hard to review this PR.\r\n",
              "createdAt": "2021-06-11T08:13:30Z",
              "updatedAt": "2021-06-11T08:20:22Z"
            },
            {
              "originalPosition": 100,
              "body": "(Already discussed.)",
              "createdAt": "2021-06-11T08:14:09Z",
              "updatedAt": "2021-06-11T08:20:22Z"
            },
            {
              "originalPosition": 120,
              "body": "Writing the actual characters instead of HTML entity references is preferred.\r\n\r\nThe same dashes should be used at the start and at the end of an interjection.",
              "createdAt": "2021-06-11T08:15:05Z",
              "updatedAt": "2021-06-11T08:20:22Z"
            },
            {
              "originalPosition": 205,
              "body": "If we want to use unnumbered sections more often, we might want to make an ALD for this to reduce noise.\r\nUnnumbered sections are a bit of a boobytrap as they have to be used consistently in the XML.",
              "createdAt": "2021-06-11T08:16:33Z",
              "updatedAt": "2021-06-11T08:20:22Z"
            },
            {
              "originalPosition": 231,
              "body": "I think we should have a separate set of definitions for literals.  This is particular important because JSONPath literals have a more permissive syntax than that of JSON.  (Should they?)\r\nLiterals should never be confused with the data themselves (i.e., we never should say \"string\" when we mean \"string literal\").",
              "createdAt": "2021-06-11T08:18:19Z",
              "updatedAt": "2021-06-11T08:20:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNjE2MDMx",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T09:06:52Z",
          "updatedAt": "2021-06-11T09:06:53Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "> Literals should never be confused with the data themselves (i.e., we never should say \"string\" when we mean \"string literal\").\r\n\r\nWhat?  When was this discussed?  Do we now have to say \"boolean literal\" or \"numeric literal?\"  Where does JSON Path ever use strings that AREN'T a string literal?",
              "createdAt": "2021-06-11T09:06:53Z",
              "updatedAt": "2021-06-11T09:06:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNjM0ODQy",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T09:28:14Z",
          "updatedAt": "2021-06-11T09:28:14Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "> > Literals should never be confused with the data themselves (i.e., we never should say \"string\" when we mean \"string literal\").\r\n> \r\n> What? When was this discussed? \r\n\r\nI wasn't there.  Must have been before 1972, but I'm pretty sure after 1960.\r\n\r\n> Do we now have to say \"boolean literal\" or \"numeric literal?\" \r\n\r\nIf we mean the literal, yes.  If we mean the value, no.\r\nThe important part is to make the distinction.\r\n\r\n> Where does JSON Path ever use strings that AREN'T a string literal?\r\n\r\nThe strings in the argument are no longer literals at the time we get them.\r\nAlso, as soon as a string literal in the query is parsed, it is the resulting value that is then used; different literals for the same value are not distinguishable for the purposes of the language.\r\n\r\nOf course, all this can be done differently, but that is the way it has been done in language design for approximately half a century.\r\n",
              "createdAt": "2021-06-11T09:28:14Z",
              "updatedAt": "2021-06-11T09:28:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTY4MjI0",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:24:31Z",
          "updatedAt": "2021-06-15T05:24:31Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "(Resolved in #102)",
              "createdAt": "2021-06-15T05:24:31Z",
              "updatedAt": "2021-06-15T05:24:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTczMDA5",
          "commit": {
            "abbreviatedOid": "31ee9bc"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:34:46Z",
          "updatedAt": "2021-06-15T05:34:46Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "Done in #102",
              "createdAt": "2021-06-15T05:34:46Z",
              "updatedAt": "2021-06-15T05:34:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 100,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY3Njc1NjEw",
      "title": "Try to avoid the \"default branch\" noise in builds",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/100",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/martinthomson/i-d-template/issues/273#issuecomment-859173896",
      "createdAt": "2021-06-11T04:50:41Z",
      "updatedAt": "2021-06-12T06:51:07Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "c8597e87e9735338ceca4eb6a99c15bf5148dcf2",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "fix-build",
      "headRefOid": "71414d16fb888385a2deb10edffccae631b9deb9",
      "closedAt": "2021-06-12T06:51:00Z",
      "mergedAt": "2021-06-12T06:50:59Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "4b8e9e9f05cb20d905e0c863c02a905c321af51f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDY3NTQy",
          "commit": {
            "abbreviatedOid": "71414d1"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T05:44:14Z",
          "updatedAt": "2021-06-11T05:44:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjE1NDYw",
          "commit": {
            "abbreviatedOid": "71414d1"
          },
          "author": "sthagen",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2021-06-11T21:05:30Z",
          "updatedAt": "2021-06-11T21:05:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4ODg3NTk5",
      "title": "Slightly fixed #97",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/101",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-12T15:03:06Z",
      "updatedAt": "2021-06-14T09:48:01Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "4b8e9e9f05cb20d905e0c863c02a905c321af51f",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "97-step1",
      "headRefOid": "12f7c9ab76bbf9e63396ffb9de2962cb08d0053f",
      "closedAt": "2021-06-14T09:47:58Z",
      "mergedAt": "2021-06-14T09:47:58Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "fcb10c8e00c9fe6c46d7c59b1953e195f92973a4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzM0NzA3",
          "commit": {
            "abbreviatedOid": "12f7c9a"
          },
          "author": "sthagen",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM - as a first step to \u201epull the cow from the ice\u201c",
          "createdAt": "2021-06-12T15:50:22Z",
          "updatedAt": "2021-06-12T15:50:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzM5MTg4",
          "commit": {
            "abbreviatedOid": "12f7c9a"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "well .. let's go on and asymptotically approach the optimum. ",
          "createdAt": "2021-06-12T17:00:13Z",
          "updatedAt": "2021-06-12T17:00:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzM5MzM3",
          "commit": {
            "abbreviatedOid": "12f7c9a"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-12T17:02:42Z",
          "updatedAt": "2021-06-12T17:02:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzQ5ODE3",
          "commit": {
            "abbreviatedOid": "12f7c9a"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-12T19:44:07Z",
          "updatedAt": "2021-06-12T19:44:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5NjcxOTMz",
      "title": "Selectors reworked ...",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/102",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is a full rebase of branch pr-98 (#99) on current main.",
      "createdAt": "2021-06-14T15:37:35Z",
      "updatedAt": "2021-06-16T11:51:40Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "43d2e974d64d8f450c7bbc68a9db6d49219343ec",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "pr-98-try-rebase",
      "headRefOid": "74035beea2c36dde77445bc9fb28bed1e6cc6226",
      "closedAt": "2021-06-16T10:09:34Z",
      "mergedAt": "2021-06-16T10:09:34Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "dd2a88eb04038b8d40c61534dc6dac6d4f07fd5b"
      },
      "comments": [
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this incorporate any changes from the discussions from #98, or is it a simple rebase?",
          "createdAt": "2021-06-15T06:27:39Z",
          "updatedAt": "2021-06-15T06:27:39Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "> Does this incorporate any changes from the discussions from #98, or is it a simple rebase?\r\n\r\nIt is a simple rebase, followed by a number of edits coming from the discussions here.\r\nMost of the remaining conversations need some further discussion, so I hope to cover them with my updated slides in a couple of hours.\r\n",
          "createdAt": "2021-06-15T06:37:18Z",
          "updatedAt": "2021-06-15T06:44:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMDk0MTk2",
          "commit": {
            "abbreviatedOid": "35de2ed"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T16:03:47Z",
          "updatedAt": "2021-06-14T16:10:44Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "In the next PR, I'd prefer if we could move all the expression language parts over to an expression language section.",
              "createdAt": "2021-06-14T16:03:47Z",
              "updatedAt": "2021-06-14T16:10:44Z"
            },
            {
              "originalPosition": 252,
              "body": "See https://www.ietf.org/archive/id/draft-bormann-cbor-cddl-freezer-07.html#name-err6527 for how to do this right.  (Again, this should be in the expression language section.)",
              "createdAt": "2021-06-14T16:08:08Z",
              "updatedAt": "2021-06-14T16:10:44Z"
            },
            {
              "originalPosition": 501,
              "body": "What is the meaning of `<expr`?\r\nMissing `>`?\r\n",
              "createdAt": "2021-06-14T16:10:02Z",
              "updatedAt": "2021-06-14T16:10:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMTA0MjI1",
          "commit": {
            "abbreviatedOid": "35de2ed"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T16:13:43Z",
          "updatedAt": "2021-06-14T16:13:43Z",
          "comments": [
            {
              "originalPosition": 501,
              "body": "yes ... simple typo\r\n\r\nthanks a lot",
              "createdAt": "2021-06-14T16:13:43Z",
              "updatedAt": "2021-06-14T16:13:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMTA1Njky",
          "commit": {
            "abbreviatedOid": "35de2ed"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-14T16:15:12Z",
          "updatedAt": "2021-06-14T16:15:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNTcxMTg0",
          "commit": {
            "abbreviatedOid": "c7025e2"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T05:30:58Z",
          "updatedAt": "2021-06-15T05:30:58Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Wouldn't it make sense then to simple copy that into here ?",
              "createdAt": "2021-06-15T05:30:58Z",
              "updatedAt": "2021-06-15T05:31:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjA1ODIz",
          "commit": {
            "abbreviatedOid": "766d837"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T06:33:55Z",
          "updatedAt": "2021-06-15T06:33:56Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "Having this as a parenthetical seems good to me. \ud83d\udc4d ",
              "createdAt": "2021-06-15T06:33:55Z",
              "updatedAt": "2021-06-15T06:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjEzMTgy",
          "commit": {
            "abbreviatedOid": "766d837"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T06:44:02Z",
          "updatedAt": "2021-06-15T06:44:03Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Yes.\r\n(Discuss today.)\r\n",
              "createdAt": "2021-06-15T06:44:03Z",
              "updatedAt": "2021-06-15T06:44:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjA3NTgy",
          "commit": {
            "abbreviatedOid": "766d837"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "There are also still some open questions from #98.",
          "createdAt": "2021-06-15T06:36:34Z",
          "updatedAt": "2021-06-15T07:09:47Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "If we rename this to `string-content` (or similar) we should be able to reuse much of this section as a definition for all strings.",
              "createdAt": "2021-06-15T06:36:34Z",
              "updatedAt": "2021-06-15T07:09:47Z"
            },
            {
              "originalPosition": 300,
              "body": "Do we need to specify \"octal-like\" or should we just leave it as disallowing leading zeroes?",
              "createdAt": "2021-06-15T06:38:16Z",
              "updatedAt": "2021-06-15T07:09:47Z"
            },
            {
              "originalPosition": 350,
              "body": "```suggestion\r\nFor example, selector `[-1]` selects the last and selector `[-2]` selects the next to last element of an array with at least two elements.\r\n```\r\n\r\nor\r\n\r\n```suggestion\r\nFor example, selector `[-1]` selects the last and selector `[-2]` selects the second from the last element of an array with at least two elements.\r\n```\r\n\r\nSeems \"last but one\" _et. al._ [comes from British English](https://www.collinsdictionary.com/dictionary/english/last-but-one-last-but-three-etc), which is fine, but in my experience American English is typically used, and this phrase isn't commonly used in that vernacular.",
              "createdAt": "2021-06-15T06:51:33Z",
              "updatedAt": "2021-06-15T07:09:47Z"
            },
            {
              "originalPosition": 7,
              "body": "This doesn't quite match up with what's actually going on.  Hence [the issue](https://github.com/jsonpath-standard/jsonpath-compliance-test-suite/issues/3) in the compliance test suite I raised.\r\n\r\nI was thinking it worked as you've written, but the referenced algorithm doesn't work exactly that way.",
              "createdAt": "2021-06-15T07:08:39Z",
              "updatedAt": "2021-06-15T07:09:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjUxODAx",
          "commit": {
            "abbreviatedOid": "84e4abc"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:30:01Z",
          "updatedAt": "2021-06-15T07:30:01Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Glyn already suggested to phrase instead: integer base-10",
              "createdAt": "2021-06-15T07:30:01Z",
              "updatedAt": "2021-06-15T07:30:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjY0Njg0",
          "commit": {
            "abbreviatedOid": "0d32e4f"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:43:24Z",
          "updatedAt": "2021-06-15T07:43:24Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Well, slight massaging required to support both single-quoted and double-quoted strings.\r\nI think we should leave this to a followup PR.",
              "createdAt": "2021-06-15T07:43:24Z",
              "updatedAt": "2021-06-15T07:43:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNjY1NTM5",
          "commit": {
            "abbreviatedOid": "0d32e4f"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T07:44:16Z",
          "updatedAt": "2021-06-15T07:44:16Z",
          "comments": [
            {
              "originalPosition": 350,
              "body": "penultimate",
              "createdAt": "2021-06-15T07:44:16Z",
              "updatedAt": "2021-06-15T07:44:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNzc5MjY0",
          "commit": {
            "abbreviatedOid": "0d32e4f"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T09:33:24Z",
          "updatedAt": "2021-06-15T09:33:24Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Right, but that's in point 2.  We still highlight \"octal-like\" integers in point 3.  Is there a reason we want to call attention to octal over other common number bases?",
              "createdAt": "2021-06-15T09:33:24Z",
              "updatedAt": "2021-06-15T09:33:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNzgxMDQz",
          "commit": {
            "abbreviatedOid": "0d32e4f"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T09:35:14Z",
          "updatedAt": "2021-06-15T09:35:14Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "Suggested in meeting to use `string-literal`",
              "createdAt": "2021-06-15T09:35:14Z",
              "updatedAt": "2021-06-15T09:35:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MTE2ODM3",
          "commit": {
            "abbreviatedOid": "0d32e4f"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T14:51:33Z",
          "updatedAt": "2021-06-15T14:51:33Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "The descendant selector should select all primitive values which are part of the subtree of the input node. For example, `..` applied to the argument `true` should produce `[true]` even though there are no object members or array elements in the argument.\r\n\r\nThe descendant selector should also select _all_ object members and _all_ array elements (the current wording could permit some to be omitted). \r\n```suggestion\r\nThe `descendant-selector` is inspired by ECMAScript for XML (E4X). It selects the node and all its descendants.\r\n```",
              "createdAt": "2021-06-15T14:51:33Z",
              "updatedAt": "2021-06-15T14:51:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQ3MzEx",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T16:41:21Z",
          "updatedAt": "2021-06-15T16:41:21Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Resolved as per interim (needed a bit more surgery than I had thought, though).",
              "createdAt": "2021-06-15T16:41:21Z",
              "updatedAt": "2021-06-15T16:41:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQ3OTE1",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T16:41:57Z",
          "updatedAt": "2021-06-15T16:41:57Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "Resolved as per interim.",
              "createdAt": "2021-06-15T16:41:57Z",
              "updatedAt": "2021-06-15T16:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQ4Mzcx",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T16:42:24Z",
          "updatedAt": "2021-06-15T16:42:25Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Please check as now updated.",
              "createdAt": "2021-06-15T16:42:25Z",
              "updatedAt": "2021-06-15T16:42:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQ4OTg3",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T16:43:01Z",
          "updatedAt": "2021-06-15T16:43:01Z",
          "comments": [
            {
              "originalPosition": 350,
              "body": "We didn't discuss this, so I left it, but \"penultimate\" really is the way to go.",
              "createdAt": "2021-06-15T16:43:01Z",
              "updatedAt": "2021-06-15T16:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQ5MzMz",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T16:43:23Z",
          "updatedAt": "2021-06-15T16:43:23Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "We didn't discuss this, so I left it for a future PR",
              "createdAt": "2021-06-15T16:43:23Z",
              "updatedAt": "2021-06-15T16:43:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQ5OTI1",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T16:44:01Z",
          "updatedAt": "2021-06-15T16:44:01Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "I didn't see this yet when I made a different change.  Please check...",
              "createdAt": "2021-06-15T16:44:01Z",
              "updatedAt": "2021-06-15T16:44:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MzA3NzI4",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I left some comments or suggestions. I am now going on vacation, so apologies if I don't participate further for a couple of weeks.",
          "createdAt": "2021-06-15T17:37:25Z",
          "updatedAt": "2021-06-15T18:23:31Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@mkmik did quite a bit of work on the array slicing spec, so I'd like to acknowledge him somewhere.",
              "createdAt": "2021-06-15T17:37:25Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 70,
              "body": "we import terms with initial capitals and then lower case them in use, e.g. immeditately below. I'm _reasonably_ comfortable with this, but it doesn't seem quite correct.",
              "createdAt": "2021-06-15T17:39:49Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 161,
              "body": "\"selectors\" is too general here.\r\n```suggestion\r\n  * Union selector `[<sel1>,<sel2>,...,<selN>]`, holding a comma delimited list of index, index wild card, array slice, and filter selectors.\r\n```",
              "createdAt": "2021-06-15T17:44:32Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 163,
              "body": "It may be better to move this before the union selector to avoid forward references.",
              "createdAt": "2021-06-15T17:45:38Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 195,
              "body": "Hmmm. I don't think `$` is the name of the root selector. It _is_ the root selector.\r\n```suggestion\r\nEvery valid JSONPath query MUST begin with the root selector `$`.\r\n```",
              "createdAt": "2021-06-15T17:47:40Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 205,
              "body": "I don't think it's necessary to talk about naming or anonymity here. Also, denoting the argument by `$` doesn't make it the root node - it already was the root node. It enables us to _address_ the node.",
              "createdAt": "2021-06-15T17:49:51Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 284,
              "body": "Don't repeat the syntax in the semantics section.\r\n```suggestion\r\n```",
              "createdAt": "2021-06-15T17:52:38Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 285,
              "body": "```suggestion\r\nA `dot-wild-selector` acts as a wild card by selecting the nodes of all member values of an object as well as all element nodes of\r\n```",
              "createdAt": "2021-06-15T17:53:00Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 300,
              "body": "It may address no member values or no array elements.\r\n```suggestion\r\nAn index selector `[<index>]` addresses at most one object member value or at most one array element value.\r\n```",
              "createdAt": "2021-06-15T17:58:37Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 449,
              "body": "```suggestion\r\nFor example, selector `[0]` selects the first and selector `[4]` the fifth element of a sufficiently long array.\r\n```",
              "createdAt": "2021-06-15T18:10:53Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 479,
              "body": "Same issue as before - don't put syntax in the semantics section.\r\n```suggestion\r\nAn `index-wild-selector`\r\n```",
              "createdAt": "2021-06-15T18:12:57Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 481,
              "body": "Should talk about selecting nodes rather than values.",
              "createdAt": "2021-06-15T18:13:31Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 524,
              "body": "@gregsdennis pointed out before that omitting the three integers always leaves behind _two_ separating colons when only one colon is valid. The ABNF is correct, but the description here contradicts it.",
              "createdAt": "2021-06-15T18:15:21Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 578,
              "body": "The descendant selector should select all primitive values which are part of the subtree of the input node. For example, `..*` applied to the argument `true` should produce `[true]` even though there are no object members or array elements in the argument.\r\n\r\nThe descendant selector should also select _all_ object members and _all_ array elements (the current wording could permit some to be omitted).\r\n```suggestion\r\nIt selects the node and all its descendants..\r\n```",
              "createdAt": "2021-06-15T18:17:40Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 602,
              "body": "For the record, \"ws\" is far more memorable than \"S\".",
              "createdAt": "2021-06-15T18:19:24Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            },
            {
              "originalPosition": 650,
              "body": "We also need absolute path values such as `$.foo`.",
              "createdAt": "2021-06-15T18:21:52Z",
              "updatedAt": "2021-06-15T18:23:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MzgzNDc4",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T18:59:31Z",
          "updatedAt": "2021-06-15T18:59:31Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I put him back to the contributors section (sorry about that).",
              "createdAt": "2021-06-15T18:59:31Z",
              "updatedAt": "2021-06-15T18:59:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MzgzODIx",
          "commit": {
            "abbreviatedOid": "cdb4eeb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T18:59:56Z",
          "updatedAt": "2021-06-15T18:59:57Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "That's my German (nouns with caps, adjectives with lower case).  Fixed.",
              "createdAt": "2021-06-15T18:59:57Z",
              "updatedAt": "2021-06-15T18:59:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Mzg2MTI5",
          "commit": {
            "abbreviatedOid": "6e7144c"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:02:46Z",
          "updatedAt": "2021-06-15T19:02:47Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Indeed.",
              "createdAt": "2021-06-15T19:02:46Z",
              "updatedAt": "2021-06-15T19:02:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Mzg3NzYw",
          "commit": {
            "abbreviatedOid": "6e7144c"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:04:42Z",
          "updatedAt": "2021-06-15T19:04:43Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "Changed this -- a bit redundant now.",
              "createdAt": "2021-06-15T19:04:43Z",
              "updatedAt": "2021-06-15T19:04:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Mzg4OTU0",
          "commit": {
            "abbreviatedOid": "6e7144c"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:06:08Z",
          "updatedAt": "2021-06-15T19:06:08Z",
          "comments": [
            {
              "originalPosition": 284,
              "body": "Can't leave the \"it\" floating; slightly rephrased.",
              "createdAt": "2021-06-15T19:06:08Z",
              "updatedAt": "2021-06-15T19:06:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MzkwMTk0",
          "commit": {
            "abbreviatedOid": "bfde93e"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:07:36Z",
          "updatedAt": "2021-06-15T19:07:36Z",
          "comments": [
            {
              "originalPosition": 284,
              "body": "Oh, you have better text below.",
              "createdAt": "2021-06-15T19:07:36Z",
              "updatedAt": "2021-06-15T19:07:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MzkzOTIz",
          "commit": {
            "abbreviatedOid": "4876c3b"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:12:16Z",
          "updatedAt": "2021-06-15T19:12:17Z",
          "comments": [
            {
              "originalPosition": 481,
              "body": "Fixed.",
              "createdAt": "2021-06-15T19:12:16Z",
              "updatedAt": "2021-06-15T19:12:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Mzk0NzY0",
          "commit": {
            "abbreviatedOid": "4876c3b"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:13:16Z",
          "updatedAt": "2021-06-15T19:13:16Z",
          "comments": [
            {
              "originalPosition": 524,
              "body": "Wait, the step is optional in the syntax, too.",
              "createdAt": "2021-06-15T19:13:16Z",
              "updatedAt": "2021-06-15T19:13:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Mzk2ODUw",
          "commit": {
            "abbreviatedOid": "47306e9"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:15:48Z",
          "updatedAt": "2021-06-15T19:15:48Z",
          "comments": [
            {
              "originalPosition": 578,
              "body": "To do: Define \"descendants\" (making sure that member values are, but member names aren't).",
              "createdAt": "2021-06-15T19:15:48Z",
              "updatedAt": "2021-06-15T19:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Mzk4MjU3",
          "commit": {
            "abbreviatedOid": "47306e9"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:17:32Z",
          "updatedAt": "2021-06-15T19:17:32Z",
          "comments": [
            {
              "originalPosition": 602,
              "body": "If you are stuck in an ABNF littered with them, S is sufficiently memorable...\r\n\r\n(WS really should be for mandatory whitespace, OWS is optional whitespace, but that is too long here.)",
              "createdAt": "2021-06-15T19:17:32Z",
              "updatedAt": "2021-06-15T19:17:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Mzk4OTcz",
          "commit": {
            "abbreviatedOid": "47306e9"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T19:18:25Z",
          "updatedAt": "2021-06-15T19:18:25Z",
          "comments": [
            {
              "originalPosition": 650,
              "body": "Todo for next PR...",
              "createdAt": "2021-06-15T19:18:25Z",
              "updatedAt": "2021-06-15T19:18:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NDYyMzAz",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "sthagen",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks like a good next step on our path.",
          "createdAt": "2021-06-15T20:34:42Z",
          "updatedAt": "2021-06-15T20:41:15Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "I have a hard time understanding what a node of a value might be. This seems to be dimensionally wrong. Maybe there are too many objects in that sentence?",
              "createdAt": "2021-06-15T20:34:42Z",
              "updatedAt": "2021-06-15T20:41:15Z"
            },
            {
              "originalPosition": 602,
              "body": "I never got that color thing people associate with space - maybe I should buy me a printer and do some archaeology? Just  `S` or `SP` should do nicely.",
              "createdAt": "2021-06-15T20:40:18Z",
              "updatedAt": "2021-06-15T20:41:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NDcyNDkx",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T20:47:31Z",
          "updatedAt": "2021-06-15T20:47:32Z",
          "comments": [
            {
              "originalPosition": 524,
              "body": "The ABNF syntax is correct (last time I looked!). It's just the above sentence which is misleading.",
              "createdAt": "2021-06-15T20:47:32Z",
              "updatedAt": "2021-06-15T20:47:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NDc0MDc3",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "As I'm going away, approving so I don't block progress. I think @cabo has responded to most if not all my comments.",
          "createdAt": "2021-06-15T20:49:38Z",
          "updatedAt": "2021-06-15T20:49:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NzYzMjMy",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T06:19:43Z",
          "updatedAt": "2021-06-16T06:19:43Z",
          "comments": [
            {
              "originalPosition": 602,
              "body": "I am fine with \"S\" (minimalistic :). Is there a convention to write constants in capitals?",
              "createdAt": "2021-06-16T06:19:43Z",
              "updatedAt": "2021-06-16T06:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NzYzNzg3",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T06:20:42Z",
          "updatedAt": "2021-06-16T06:20:42Z",
          "comments": [
            {
              "originalPosition": 650,
              "body": "this is a `json-path` then.",
              "createdAt": "2021-06-16T06:20:42Z",
              "updatedAt": "2021-06-16T06:20:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NzcxMzIw",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-16T06:32:24Z",
          "updatedAt": "2021-06-16T06:57:18Z",
          "comments": [
            {
              "originalPosition": 556,
              "body": "Seems to be misleading (I know my wording). It was surely adopted by Python before 2014. So skip `later`.",
              "createdAt": "2021-06-16T06:32:24Z",
              "updatedAt": "2021-06-16T06:57:18Z"
            },
            {
              "originalPosition": 670,
              "body": "For the next PR:\r\n\r\nThinking a bit more about `in-op` leads me to the conclusion, that this operator makes sense only for arrays.\r\n`'key' in $.obj` is equivalent to `$.obj.key` and `'key' in <literal-object>` seems to be useless. I see no other rational here. Someone else ?",
              "createdAt": "2021-06-16T06:50:45Z",
              "updatedAt": "2021-06-16T06:57:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODUwODA4",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T08:04:45Z",
          "updatedAt": "2021-06-16T08:04:46Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "I agree that this is rather verbose now.  Maybe\r\n\r\n> Finally, `.b` selects from any input node of type object any node corresponding to a member named `b`.\r\n\r\n(requires editing the line above it as well)",
              "createdAt": "2021-06-16T08:04:45Z",
              "updatedAt": "2021-06-16T08:05:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODU1MzQ5",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T08:09:23Z",
          "updatedAt": "2021-06-16T08:09:23Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "You just added \"As in JSON numbers...\"\r\n\r\n>3. As in JSON numbers, the syntax does not allow octal-like integers with leading zeros such as `01` or `-01`.\r\n\r\nThat doesn't address my concern at all.  My question is about the callout of _octal_ and exclusion of other number bases such as binary and hexadecimal.",
              "createdAt": "2021-06-16T08:09:23Z",
              "updatedAt": "2021-06-16T08:09:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODU1ODQw",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T08:09:53Z",
          "updatedAt": "2021-06-16T08:09:54Z",
          "comments": [
            {
              "originalPosition": 350,
              "body": "I'm okay with this.",
              "createdAt": "2021-06-16T08:09:53Z",
              "updatedAt": "2021-06-16T08:09:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODU4MTg2",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T08:12:15Z",
          "updatedAt": "2021-06-16T08:14:57Z",
          "comments": [
            {
              "originalPosition": 604,
              "body": "Repetition of \"It\" and extra period (ironically).\r\n\r\n```suggestion\r\nThe `descendant-selector` is inspired by ECMAScript for XML (E4X).\r\nIt selects the node and all its descendants.\r\n```",
              "createdAt": "2021-06-16T08:12:15Z",
              "updatedAt": "2021-06-16T09:52:44Z"
            },
            {
              "originalPosition": 602,
              "body": "Do we need to make concession for multiple whitespace chars (e.g. `*ws` or `*S`), or is that implicitly covered?",
              "createdAt": "2021-06-16T08:14:57Z",
              "updatedAt": "2021-06-16T08:14:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODY4NjA3",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Added some comments that I'm happy to have resolved in a follow-up non-functional edit PR.",
          "createdAt": "2021-06-16T08:22:35Z",
          "updatedAt": "2021-06-16T08:22:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTM1OTY0",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:26:19Z",
          "updatedAt": "2021-06-16T09:26:19Z",
          "comments": [
            {
              "originalPosition": 650,
              "body": "That is a simple solution that we can refine later.  Put it in.",
              "createdAt": "2021-06-16T09:26:19Z",
              "updatedAt": "2021-06-16T09:26:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTM5MDc1",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:29:17Z",
          "updatedAt": "2021-06-16T09:29:17Z",
          "comments": [
            {
              "originalPosition": 602,
              "body": "RFC 8610 defines this as:\r\n\r\n     S = *WS\r\n     WS = SP / NL\r\n     SP = %x20\r\n     NL = COMMENT / CRLF\r\n     COMMENT = \";\" *PCHAR CRLF\r\n     PCHAR = %x20-7E / %x80-10FFFD\r\n     CRLF = %x0A / %x0D.0A\r\n\r\nI'm not sure we need to support comments in JSONPath (that is a serious question though), but if you remove that, pesky details like isolated CRs are fixed, too (and then CDDL simply disallows HTs, which may not be popular here).\r\n\r\nNext PR...",
              "createdAt": "2021-06-16T09:29:17Z",
              "updatedAt": "2021-06-16T09:29:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTQxMTQ0",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:31:15Z",
          "updatedAt": "2021-06-16T09:31:16Z",
          "comments": [
            {
              "originalPosition": 602,
              "body": "Oh, and I'm not sure these can all be called constants, but there is indeed a tendency in ABNF usage to give token-level (scanner) productions such as DIGIT, ALPHA, WS, ... upper case names.",
              "createdAt": "2021-06-16T09:31:15Z",
              "updatedAt": "2021-06-16T09:31:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTQ0MDQ2",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:34:11Z",
          "updatedAt": "2021-06-16T09:34:11Z",
          "comments": [
            {
              "originalPosition": 670,
              "body": "there is still the \"enum\" use case, as in `$.service_level in [\"silver\", \"gold\"]`, which is an abbreviation for `$.service_level == \"silver\" || $.service_level == \"gold\"`.",
              "createdAt": "2021-06-16T09:34:11Z",
              "updatedAt": "2021-06-16T09:34:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTUyNTEz",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:42:33Z",
          "updatedAt": "2021-06-16T09:42:34Z",
          "comments": [
            {
              "originalPosition": 556,
              "body": "A quick search finds it in Python in 2009, but I didn't check further.\r\nChanged to \", and that of Python\".\r\n\r\nBTW, do we support negative steps?",
              "createdAt": "2021-06-16T09:42:33Z",
              "updatedAt": "2021-06-16T09:42:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTU0MjY3",
          "commit": {
            "abbreviatedOid": "6e58652"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:44:17Z",
          "updatedAt": "2021-06-16T09:44:17Z",
          "comments": [
            {
              "originalPosition": 604,
              "body": "Fixed.",
              "createdAt": "2021-06-16T09:44:17Z",
              "updatedAt": "2021-06-16T09:44:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTU1Mjkx",
          "commit": {
            "abbreviatedOid": "74035be"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:45:23Z",
          "updatedAt": "2021-06-16T09:45:24Z",
          "comments": [
            {
              "originalPosition": 670,
              "body": "well ... this is the `in <array>` use case.",
              "createdAt": "2021-06-16T09:45:23Z",
              "updatedAt": "2021-06-16T09:45:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTYwMDA3",
          "commit": {
            "abbreviatedOid": "74035be"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:50:05Z",
          "updatedAt": "2021-06-16T09:50:06Z",
          "comments": [
            {
              "originalPosition": 556,
              "body": "The current test suite and the comparison matrix _does_ have negative step cases.",
              "createdAt": "2021-06-16T09:50:05Z",
              "updatedAt": "2021-06-16T09:50:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTgyMjAx",
          "commit": {
            "abbreviatedOid": "74035be"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T10:13:29Z",
          "updatedAt": "2021-06-16T10:13:29Z",
          "comments": [
            {
              "originalPosition": 556,
              "body": "@cabo Negative steps are also supported in the spec. See for example Table 4.",
              "createdAt": "2021-06-16T10:13:29Z",
              "updatedAt": "2021-06-16T10:13:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1MDY2NDQ2",
          "commit": {
            "abbreviatedOid": "74035be"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T11:51:39Z",
          "updatedAt": "2021-06-16T11:51:40Z",
          "comments": [
            {
              "originalPosition": 556,
              "body": "Thanks.  It just occurred to me as the semantics section needs to gain more content.",
              "createdAt": "2021-06-16T11:51:39Z",
              "updatedAt": "2021-06-16T11:51:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0MTk0NTkz",
      "title": "Close discussion D1",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/104",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here's a chance to actually have the discussion if anyone wants to.",
      "createdAt": "2021-07-06T09:08:16Z",
      "updatedAt": "2021-07-07T11:11:54Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "dd2a88eb04038b8d40c61534dc6dac6d4f07fd5b",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "discussion-d1",
      "headRefOid": "6e69a78765984aaabb4a0e277dc2a0ef2674f2ee",
      "closedAt": "2021-07-07T11:11:51Z",
      "mergedAt": "2021-07-07T11:11:51Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "8c99e5028c27ae49690182902125c2ca9b613867"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Well, I'm certainly ready for this model.\r\n",
          "createdAt": "2021-07-06T09:15:01Z",
          "updatedAt": "2021-07-06T09:15:01Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm good with the approach described in the text.  As long as a string can be parsed as a Path, it should evaluate.  I can't see a case where processing a valid path against a value would produce an error; merely empty result sets.\r\n\r\nThis means that the only errors should be syntax errors, correct?",
          "createdAt": "2021-07-06T10:16:10Z",
          "updatedAt": "2021-07-06T10:16:10Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> This means that the only errors should be syntax errors, correct?\r\n\r\nI think so.",
          "createdAt": "2021-07-06T10:29:38Z",
          "updatedAt": "2021-07-06T10:29:38Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "May I encourage reviewers who are in favour of this PR to approve it?",
          "createdAt": "2021-07-06T10:30:12Z",
          "updatedAt": "2021-07-06T10:30:12Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I was awaiting a bit more discussion.",
          "createdAt": "2021-07-06T10:34:24Z",
          "updatedAt": "2021-07-06T10:34:24Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, I've requested a review from Stefan.",
          "createdAt": "2021-07-06T10:36:27Z",
          "updatedAt": "2021-07-06T10:36:27Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "> are we ready for the error model defined here, i.e. one\r\n> that does not have runtime errors, but only compile time errors?\r\n\r\nYes absolutely ... I like that clean concept a lot.",
          "createdAt": "2021-07-06T12:15:50Z",
          "updatedAt": "2021-07-06T12:15:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5ODc5NjYy",
          "commit": {
            "abbreviatedOid": "6e69a78"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-06T12:16:34Z",
          "updatedAt": "2021-07-06T12:16:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMzM3MDQz",
          "commit": {
            "abbreviatedOid": "6e69a78"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-06T20:05:27Z",
          "updatedAt": "2021-07-06T20:05:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0MTk4ODky",
      "title": "Nail down combine1",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/105",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-06T09:14:02Z",
      "updatedAt": "2021-07-07T11:11:27Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "dd2a88eb04038b8d40c61534dc6dac6d4f07fd5b",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "nail-down-combine1",
      "headRefOid": "274933b1aa151e92508480e9fb98c8bdb9e87ddb",
      "closedAt": "2021-07-07T11:11:24Z",
      "mergedAt": "2021-07-07T11:11:24Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "b1f4de76e17e95d7a87d535c3c5f0d7cf3180fc8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMzM1NDE3",
          "commit": {
            "abbreviatedOid": "274933b"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I agree with this. Concatenation seems to always be the appropriate action here.",
          "createdAt": "2021-07-06T20:03:18Z",
          "updatedAt": "2021-07-06T20:03:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0MjAxMjM2",
      "title": "Close discussion D4",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/106",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here's a chance to actually have the discussion if anyone wants to.",
      "createdAt": "2021-07-06T09:17:08Z",
      "updatedAt": "2021-07-07T11:11:40Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "dd2a88eb04038b8d40c61534dc6dac6d4f07fd5b",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "discussion-d4",
      "headRefOid": "a2393e73d20b2ce375cb54c0d412d2c9f680d955",
      "closedAt": "2021-07-07T11:11:37Z",
      "mergedAt": "2021-07-07T11:11:37Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "f9d7b3a1eb8d743d3f8cdba8acba8cff997c9a18"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "One related question is whether the selector can use $ internally (still returning nodes within the current node).",
          "createdAt": "2021-07-06T09:19:16Z",
          "updatedAt": "2021-07-06T09:19:16Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> One related question is whether the selector can use $ internally (still returning nodes within the current node).\r\n\r\nI am in favour of supporting `$` inside filter expressions as a way to access the root node of the argument, but I don't think that should block this PR as the context of the discussion seems to be which nodes are selected. As you point out, using `$` in a filter expression doesn't select the root node - it selects nodes within the current node as usual.",
          "createdAt": "2021-07-06T09:44:32Z",
          "updatedAt": "2021-07-06T09:44:32Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree.  Paths like `$.foo[?(@.bar < $.baz)]` should be allowed, but wouldn't select anything that is not a descendent of `$.foo`.  Here the `$.baz` provides a basis for comparison used to select the current node `@` in the iteration.\r\n\r\nI see no value (for an initial release anyway) in allowing selection of ancestor nodes.  If a use case and syntax for it are later defined, I'm happy to release that as a follow-up version.",
          "createdAt": "2021-07-06T10:20:35Z",
          "updatedAt": "2021-07-06T10:20:35Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "yes ... using `$` in a logical expression is valid and does no harm.",
          "createdAt": "2021-07-06T12:09:41Z",
          "updatedAt": "2021-07-06T12:09:41Z"
        },
        {
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "body": "@goessner yes, but the issue at hand here is whether there is a mechanism that can select ancestor or cousin nodes.  I think we're in agreement that that there is no such mechanism.",
          "createdAt": "2021-07-06T20:04:54Z",
          "updatedAt": "2021-07-06T20:04:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5ODczODQw",
          "commit": {
            "abbreviatedOid": "a2393e7"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-06T12:09:59Z",
          "updatedAt": "2021-07-06T12:09:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMzQ3OTgz",
          "commit": {
            "abbreviatedOid": "a2393e7"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Indeed, we seem to be in agreement.",
          "createdAt": "2021-07-06T20:20:13Z",
          "updatedAt": "2021-07-06T20:20:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 107,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0MjA4OTQz",
      "title": "Clarify editors & authors",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/107",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-06T09:27:26Z",
      "updatedAt": "2021-07-07T11:11:11Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "dd2a88eb04038b8d40c61534dc6dac6d4f07fd5b",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "authorship",
      "headRefOid": "3269be6265e67ddb1b20a3baff27bbbc4ec7086f",
      "closedAt": "2021-07-07T11:11:08Z",
      "mergedAt": "2021-07-07T11:11:08Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "c4238561691b048f5e00af7592bc67f016daa2d3"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "I think Stefan should be first author, and I wouldn't mind to be last.",
          "createdAt": "2021-07-06T13:36:49Z",
          "updatedAt": "2021-07-06T13:36:49Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think Stefan should be first author, and I wouldn't mind to be last.\r\n\r\nOk, thanks. Updated.",
          "createdAt": "2021-07-06T15:02:02Z",
          "updatedAt": "2021-07-06T15:02:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMDc0OTA0",
          "commit": {
            "abbreviatedOid": "3269be6"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thank you.",
          "createdAt": "2021-07-06T15:09:31Z",
          "updatedAt": "2021-07-06T15:09:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0MjY0MTUz",
      "title": "Fix invalid link",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/108",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Without this `make` fails with:\r\n\r\ndraft-ietf-jsonpath-base.xml(0): Error: IDREF attribute target references an unknown ID \"_json\", at None",
      "createdAt": "2021-07-06T10:46:46Z",
      "updatedAt": "2021-07-06T14:59:41Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "dd2a88eb04038b8d40c61534dc6dac6d4f07fd5b",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "fix-invalid-link",
      "headRefOid": "1f2e1e8fc5bdbffd95e1d957401cbd2b236d675b",
      "closedAt": "2021-07-06T14:59:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Where are you getting this?\r\nYou may want to do a `gem update` when you see an error like this.\r\n",
          "createdAt": "2021-07-06T13:30:53Z",
          "updatedAt": "2021-07-06T13:30:53Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> Where are you getting this?\r\n\r\nWhen I issue `make` locally.\r\n\r\n> You may want to do a `gem update` when you see an error like this.\r\n\r\nI did and the problem went away. Thanks!\r\n\r\n",
          "createdAt": "2021-07-06T14:59:41Z",
          "updatedAt": "2021-07-06T14:59:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAwMzQ0Mzk4",
      "title": "Support arbitrary predicate structure",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/111",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "glyn"
      ],
      "labels": [],
      "body": "Fixes https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/110",
      "createdAt": "2021-07-30T14:38:25Z",
      "updatedAt": "2021-08-07T00:54:37Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "8c99e5028c27ae49690182902125c2ca9b613867",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "pred",
      "headRefOid": "790faca5c4f0535fe1b007e7b738ef80f460df73",
      "closedAt": "2021-08-07T00:54:37Z",
      "mergedAt": "2021-08-07T00:54:37Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "218fbc5911b2443ecd8a4d13b8acaceeb1e72b01"
      },
      "comments": [
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the various comments. I've been busy with other things, but intend to come back before too long, absorb those comments, and push up some changes.",
          "createdAt": "2021-08-02T20:29:01Z",
          "updatedAt": "2021-08-02T20:29:01Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "On 2. Aug 2021, at 20:53, Greg Dennis ***@***.***> wrote:\n> \n> You replied.\n> \nYes.  How is that \"little response\u201d?\n\nI\u2019m still trying to parse what you mean by \"This was asked earlier and received little response.\u201d.\n\nWhat are you trying to say?\n\nGr\u00fc\u00dfe, Carsten\n\n",
          "createdAt": "2021-08-02T23:28:06Z",
          "updatedAt": "2021-08-02T23:28:06Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, so I pushed up some changes which attempt to address all the issues raised. Please see the individual commit logs for more detailed comments.",
          "createdAt": "2021-08-04T10:15:28Z",
          "updatedAt": "2021-08-04T10:15:28Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Maybe we want to add an [operator precedence table][1] into the text and try to make sure the grammar is somewhat congruence to that table.\r\n\r\n[1]: https://en.cppreference.com/w/c/language/operator_precedence",
          "createdAt": "2021-08-04T10:18:53Z",
          "updatedAt": "2021-08-04T10:20:59Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe we want to add an [operator precedence table](https://en.cppreference.com/w/c/language/operator_precedence) into the text and try to make sure the grammar is somewhat congruence to that table.\r\n\r\nGood idea, but I'd prefer to defer as I've got enough to deal with in this PR! It will also be even more valuable if we end up supporting arithmetic expressions...",
          "createdAt": "2021-08-04T10:24:37Z",
          "updatedAt": "2021-08-04T10:24:37Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Having an operator precedence table will help us understand what we are trying to do here.\r\nBut I believe in incremental improvement, so completing this PR and then re-approaching it from the angle of the precedence table works for me.\r\n",
          "createdAt": "2021-08-04T12:32:30Z",
          "updatedAt": "2021-08-04T12:32:30Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "@gregsdennis Please approve if your concerns are now addressed.",
          "createdAt": "2021-08-06T00:59:54Z",
          "updatedAt": "2021-08-06T00:59:54Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "I've started the next batch of predicate improvements in draft PR https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/115 which is based on this PR.",
          "createdAt": "2021-08-06T10:47:13Z",
          "updatedAt": "2021-08-06T10:47:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTg3MTIx",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T16:30:05Z",
          "updatedAt": "2021-07-31T16:30:05Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "this is very clean and seems to manage binding preference for `and` ... great.",
              "createdAt": "2021-07-31T16:30:05Z",
              "updatedAt": "2021-07-31T16:30:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTg3ODc2",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T16:42:08Z",
          "updatedAt": "2021-07-31T16:42:09Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "We could select\r\n```\r\n[?(@.audio && !@.video)]\r\n```\r\nusing implicit existence test. Requiring parentheses here, i.e. `!(@.video)` would be tedious.\r\n\r\nThis brings up another issue ... see below ...\r\n",
              "createdAt": "2021-07-31T16:42:09Z",
              "updatedAt": "2021-08-04T09:30:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTg4MzU4",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T16:50:14Z",
          "updatedAt": "2021-07-31T16:50:14Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "`rel-path-val` and `json-path` ...\r\n* are in fact valid ... hmm ... `defined-expr` or something ... indicating existence.\r\n* naming should be harmonized ... `rel-path-val` =>  `rel-path` or `rel-json-path`",
              "createdAt": "2021-07-31T16:50:14Z",
              "updatedAt": "2021-07-31T16:50:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTg4ODUw",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T16:59:58Z",
          "updatedAt": "2021-07-31T16:59:58Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "`basic-filter` breaks the naming rule (not communicated though) of having `xxx-expr` and `yyy-op` exclusively here.\r\n\r\n`basic-expr` or something would fit better, I think.\r\n",
              "createdAt": "2021-07-31T16:59:58Z",
              "updatedAt": "2021-07-31T16:59:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTg4OTMz",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T17:01:30Z",
          "updatedAt": "2021-07-31T17:01:58Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "significant improvement overall ... thanks",
              "createdAt": "2021-07-31T17:01:31Z",
              "updatedAt": "2021-07-31T17:01:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTkyNzU2",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T17:39:33Z",
          "updatedAt": "2021-07-31T17:39:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Good point. I'd like to avoid confusing possibilities such as:\r\n```\r\n[?(!@.foo == bar)]\r\n```\r\nbut I agree that it shouldn't be necessary to wrap existence terms in parentheses merely in order to negate them.",
              "createdAt": "2021-07-31T17:39:33Z",
              "updatedAt": "2021-07-31T17:39:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTkyODQ3",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T17:41:15Z",
          "updatedAt": "2021-07-31T17:41:15Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Thanks for explaining the naming rule, which I hadn't noticed. I'll do some renaming.",
              "createdAt": "2021-07-31T17:41:15Z",
              "updatedAt": "2021-07-31T17:41:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NTkyODcy",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T17:41:49Z",
          "updatedAt": "2021-07-31T17:41:50Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Let me mull that over and try to improve matters.",
              "createdAt": "2021-07-31T17:41:49Z",
              "updatedAt": "2021-07-31T17:41:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NjA1MTk4",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Agree with comments posted already, and added one of my own.",
          "createdAt": "2021-07-31T21:44:51Z",
          "updatedAt": "2021-07-31T21:45:54Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Eventually, we'll want other-type expressions within the `( )`, such as `4*(5+6)`.",
              "createdAt": "2021-07-31T21:44:51Z",
              "updatedAt": "2021-08-02T05:56:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NjQxNDEw",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-01T09:12:09Z",
          "updatedAt": "2021-08-01T09:12:09Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Hmm ... if we agree to existence tests and assume \r\n\r\n```\r\n{ \"zero\": 0, \"five\": 5 }\r\n``` \r\n\r\nthen unlike in C-like languages.\r\n\r\n`@.five` evaluates to `true`, but consistently `!@.five` to `false` and `!!@.five` to true ... and ...\r\n`@.zero` evaluates to `true`, `!@.zero` to `false` and `!!@.zero` to true.\r\n\r\nTesting for values needs always to be explicit, as in `@.five == 5`, `@.five > 0`, `@.five != 6` or `@.zero != 0`.\r\n",
              "createdAt": "2021-08-01T09:12:09Z",
              "updatedAt": "2021-08-01T09:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NjYwOTQy",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-01T13:07:21Z",
          "updatedAt": "2021-08-01T13:07:22Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "So then how would `!@.foo == false` be interpreted?",
              "createdAt": "2021-08-01T13:07:22Z",
              "updatedAt": "2021-08-01T13:07:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NjczNDQ1",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-01T15:23:10Z",
          "updatedAt": "2021-08-01T15:23:10Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "if `@.foo`exists then `!@.foo` results in `false` and `!@.foo == false` will give `true` ... not to be confused with  `!(@.foo == false)` which is `true` for all values of `foo` (including `undefined`) except of  `false` ...",
              "createdAt": "2021-08-01T15:23:10Z",
              "updatedAt": "2021-08-01T15:23:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5Njg5Mzc3",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-01T19:01:05Z",
          "updatedAt": "2021-08-01T19:01:05Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "So in summary, if `@.foo` holds a value of `false`, then `!@.foo == false` yields true, and `!(@.foo == false)` yields false.\n\nI think this is one of the \"confusing possibilities\" that @glyn mentioned.\n\nI think this subtlety could bear some documentation at the very least.\n\nStill, I'd probably use `@.foo != false` instead of the latter.\n\nA different option would be to forbid existence operations within comparative expressions.  Only let `&&` and `||` operate on them.  This makes `!@.foo == false` invalid syntax.",
              "createdAt": "2021-08-01T19:01:05Z",
              "updatedAt": "2021-08-01T19:05:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NzAwNzE3",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-01T21:51:46Z",
          "updatedAt": "2021-08-01T21:51:47Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Why are we moving away from the standard way of expressing grammars for languages with operator precedences?  Obviously, right recursion works, but we do have *(...) in ABNF and could use it.\r\n(Right recursion leads to a binary tree that leans to the right, so a + b + c parses as a + (b + c).\r\nNot a problem as long as operators are [associative](https://en.wikipedia.org/wiki/Operator_associativity).)\r\nSee the ECMAScript grammars for the usual way to do this.",
              "createdAt": "2021-08-01T21:51:46Z",
              "updatedAt": "2021-08-01T21:51:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NzE1NzUw",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-02T00:27:38Z",
          "updatedAt": "2021-08-02T00:27:38Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This was asked earlier and received little response.",
              "createdAt": "2021-08-02T00:27:38Z",
              "updatedAt": "2021-08-02T00:27:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwMDkxMjMz",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-02T11:18:03Z",
          "updatedAt": "2021-08-02T11:18:03Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "So we have the alternatives ...\r\n\r\n1. `@.foo` always indicates existence (`true / false`) if used standalone. Drawback: inconsistency with potential value.\r\n2.  `@.foo` results in `false` if it doesn't exist, in its value otherwise. Drawback: What's about falsy values `false, 0, null`?\r\n\r\nWe basically need to handle the Javascript value equivalence `undefined`, which is not a valid JSON value.\r\n\r\nBest I can see yet, is Greg's proposal slightly modified: \r\n\r\nFor comparisons like `@.foo > 5`, always take the node value, except it does not exist, than ... hmm ... take\r\n\r\n* `false` or\r\n* `null`\r\n\r\nand let the implementation do implicite type conversion.  We cannot forbid existence operations within comparative expressions, if we don't want do error handling (which is not syntactically based).\r\n\r\nGeneral drawback: We cannot tell, if  `!@.foo == true` is `true` because of its value `false` or inexistence. The same effect comes with  `@.foo != true`.\r\n\r\nGeneral result of this discussion: We cannot reliably test whether a node exists or not.\r\n \r\n",
              "createdAt": "2021-08-02T11:18:03Z",
              "updatedAt": "2021-08-02T11:18:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwMDk2NzI2",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-02T11:25:31Z",
          "updatedAt": "2021-08-02T11:25:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Where was what asked?",
              "createdAt": "2021-08-02T11:25:32Z",
              "updatedAt": "2021-08-02T11:25:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNTAwNjI2",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-02T18:53:18Z",
          "updatedAt": "2021-08-02T18:53:18Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@Glyn asked if there was a standard way for ANBF to support operator precedence.\r\n\r\nhttps://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/110#issuecomment-887390352\r\n\r\nYou replied.",
              "createdAt": "2021-08-02T18:53:18Z",
              "updatedAt": "2021-08-02T20:26:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNTY2MjUy",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-02T20:26:41Z",
          "updatedAt": "2021-08-02T20:26:41Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I don't intend to include that in this PR, thanks.",
              "createdAt": "2021-08-02T20:26:41Z",
              "updatedAt": "2021-08-02T20:26:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMDU0NDcy",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T09:17:53Z",
          "updatedAt": "2021-08-04T09:17:53Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "> Why are we moving away from the standard way of expressing grammars for languages with operator precedences? \r\n\r\nSimply ignorance on my part.\r\n> Obviously, right recursion works, but we do have *(...) in ABNF and could use it.\r\n> (Right recursion leads to a binary tree that leans to the right, so a + b + c parses as a + (b + c).\r\n> Not a problem as long as operators are [associative](https://en.wikipedia.org/wiki/Operator_associativity).)\r\n> See the ECMAScript grammars for the usual way to do this.\r\n\r\nI can't find an ABNF ECMAScript grammar. [This grammar](https://tc39.es/ecma262/#sec-multiplicative-operators) uses recursion, e.g.:\r\n```\r\n AdditiveExpression :\r\nAdditiveExpression + MultiplicativeExpression\r\nAdditiveExpression - MultiplicativeExpression\r\n```\r\n@cabo Please could you provide a more specific reference to an ECMAScript grammar which demonstrates the \"standard way\" you are thinking of?\r\n\r\n\r\n",
              "createdAt": "2021-08-04T09:17:53Z",
              "updatedAt": "2021-08-04T09:17:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMDgyOTU0",
          "commit": {
            "abbreviatedOid": "4534203"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T09:47:51Z",
          "updatedAt": "2021-08-04T09:47:51Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I'm going to push a change which renders `!@.foo == false` syntactically invalid. See what you make of it.",
              "createdAt": "2021-08-04T09:47:51Z",
              "updatedAt": "2021-08-04T09:47:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTAzNjg3",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:10:00Z",
          "updatedAt": "2021-08-04T10:10:00Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "In fact the changes I just pushed make existence and non-existence tests incapable of being used in comparisons, which I hope avoids some of the issues above.",
              "createdAt": "2021-08-04T10:10:00Z",
              "updatedAt": "2021-08-04T10:10:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTA0ODY2",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:11:27Z",
          "updatedAt": "2021-08-04T10:11:27Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I went for `existence-expr` which now includes optional negation and `rel-path` as it's shorter.",
              "createdAt": "2021-08-04T10:11:27Z",
              "updatedAt": "2021-08-04T10:11:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTA2MjA4",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:12:56Z",
          "updatedAt": "2021-08-04T10:12:56Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "I think this type conversion statement is no longer needed since `!` now applies only to existence terms, which give boolean values, and parenthesised boolean expressions which again give boolean values.",
              "createdAt": "2021-08-04T10:12:56Z",
              "updatedAt": "2021-08-04T10:12:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTA2NzU4",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:13:32Z",
          "updatedAt": "2021-08-04T10:13:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@cabo I tried using repetition instead of right recursion. Please see what you make of it.",
              "createdAt": "2021-08-04T10:13:32Z",
              "updatedAt": "2021-08-04T10:13:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTA3ODIy",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:14:45Z",
          "updatedAt": "2021-08-04T10:14:45Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Indeed, I must have misremembered the way TC39 writes their grammars, which apparently has morphed to a simple BNF (without repetition) plus weird two-level features (not quite Algol68 though :-).\r\n\r\nBecause different parser generators react in different ways to (immediate) recursion, I try to avoid that in favor of repetition.  I just looked at the Python grammar for a potential example, but that is a weird mix of the different styles.\r\n\r\n31c1a7f is exactly what I had in mind.  Regular and non-surprising.  Thank you.",
              "createdAt": "2021-08-04T10:14:45Z",
              "updatedAt": "2021-08-04T10:14:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTEwNzI0",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:18:04Z",
          "updatedAt": "2021-08-04T10:18:04Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Phew, thanks! :sweat_smile:",
              "createdAt": "2021-08-04T10:18:04Z",
              "updatedAt": "2021-08-04T10:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTExNjc0",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:19:08Z",
          "updatedAt": "2021-08-04T10:19:08Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I went for `basic-expr`.",
              "createdAt": "2021-08-04T10:19:08Z",
              "updatedAt": "2021-08-04T10:19:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMTE5MTA1",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T10:27:58Z",
          "updatedAt": "2021-08-04T10:27:59Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "@goessner I'd like to support `comparable comp-op path` as well since it seems arbitrary to require the path to be on the left hand side of the comparison operator. Something for a future PR, perhaps?",
              "createdAt": "2021-08-04T10:27:59Z",
              "updatedAt": "2021-08-04T10:27:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMjIwNjY2",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T12:29:47Z",
          "updatedAt": "2021-08-04T12:29:47Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I raised https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/112 to cover this.",
              "createdAt": "2021-08-04T12:29:47Z",
              "updatedAt": "2021-08-04T12:29:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyMjk2NTE5",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-04T13:39:58Z",
          "updatedAt": "2021-08-04T13:39:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzM4Nzgz",
          "commit": {
            "abbreviatedOid": "790faca"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T22:10:37Z",
          "updatedAt": "2021-08-06T22:10:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MzgzODM4",
      "title": "Filter predicate improvements",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/115",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Generalise comparisons\r\n* Make regex operator conform to Perl etc.\r\n* Add operator precedence table\r\n\r\nFixes https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/112\r\nFixes https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/113\r\nFixes https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/114",
      "createdAt": "2021-08-06T10:44:03Z",
      "updatedAt": "2021-08-10T11:00:20Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "218fbc5911b2443ecd8a4d13b8acaceeb1e72b01",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "predicate-improvements",
      "headRefOid": "48af814da70f7d251fdfb884856e843771fd3e71",
      "closedAt": "2021-08-10T09:13:15Z",
      "mergedAt": "2021-08-10T09:13:15Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "e143d9824131aa6bcd0201774ae35a872c240819"
      },
      "comments": [
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "\n>   * The behaviour of operators is consistent with the 'C'-family of programming languages.\n>   <!-- need to clarify -->\n\nI think having the precedence table now, above remark is obsolete.\n\n\n> +The following table lists filter expression operators in order of precedence from highest to lowest.\n> +\n> +| Precedence | Operator type | Syntax |\n> +|:--:|:--:|:--:|\n> +|  5  | Grouping | `(...)` |\n> +|  4  | Logical NOT | `!` |\n> +|  3  | Relations | `==`<br>`!=`<br>`<`<br>`>`<br>`<=`<br>`>=`<br>`=~`<br>` in ` |\n>\n\n",
          "createdAt": "2021-08-10T09:14:58Z",
          "updatedAt": "2021-08-10T09:14:58Z"
        },
        {
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @goessner. I raised https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/116 to remove that remark.",
          "createdAt": "2021-08-10T11:00:19Z",
          "updatedAt": "2021-08-10T11:00:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzM5NTU1",
          "commit": {
            "abbreviatedOid": "025c6ee"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T22:12:57Z",
          "updatedAt": "2021-08-06T22:12:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Are we only supporting a single selector here, or does the `*( ... )` mean multiple?",
              "createdAt": "2021-08-06T22:12:57Z",
              "updatedAt": "2021-08-06T22:12:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzQwNjE1",
          "commit": {
            "abbreviatedOid": "025c6ee"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T22:16:02Z",
          "updatedAt": "2021-08-06T22:16:02Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I'm curious, are we planning on supporting literal complex values (i.e. object / arrays) at some point later?  Maybe this needs more discussion.",
              "createdAt": "2021-08-06T22:16:02Z",
              "updatedAt": "2021-08-06T22:16:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzQxMTg4",
          "commit": {
            "abbreviatedOid": "025c6ee"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T22:17:37Z",
          "updatedAt": "2021-08-06T22:17:37Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Is it necessary to have each operator on its own line?  Seems like we could do with two or three per line.  Just a readability question.",
              "createdAt": "2021-08-06T22:17:37Z",
              "updatedAt": "2021-08-06T22:17:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzQxMzIx",
          "commit": {
            "abbreviatedOid": "025c6ee"
          },
          "author": "gregsdennis",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good.  Just some curiosity questions from me.",
          "createdAt": "2021-08-06T22:18:01Z",
          "updatedAt": "2021-08-06T22:18:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0Nzc1ODA4",
          "commit": {
            "abbreviatedOid": "025c6ee"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-07T00:57:50Z",
          "updatedAt": "2021-08-07T00:57:50Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "`*()` means zero or more repetitions of the contents of the brackets. See [section 3.6](https://www.rfc-editor.org/rfc/rfc5234.html#section-3.6) of RFC 5234.",
              "createdAt": "2021-08-07T00:57:50Z",
              "updatedAt": "2021-08-07T00:57:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0Nzc1OTcx",
          "commit": {
            "abbreviatedOid": "025c6ee"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-07T00:59:24Z",
          "updatedAt": "2021-08-07T00:59:24Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I agree it needs more discussion, but let's defer such discussion for now to keep this PR nice and small.",
              "createdAt": "2021-08-07T00:59:24Z",
              "updatedAt": "2021-08-07T00:59:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0Nzc2Njcy",
          "commit": {
            "abbreviatedOid": "025c6ee"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-07T01:06:22Z",
          "updatedAt": "2021-08-07T01:06:23Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Not really. I've pushed a change which groups similar operators together on single lines.",
              "createdAt": "2021-08-07T01:06:22Z",
              "updatedAt": "2021-08-07T01:06:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0Nzc4MDY4",
          "commit": {
            "abbreviatedOid": "ae712f4"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-07T01:19:52Z",
          "updatedAt": "2021-08-07T01:19:52Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Perhaps I realise why this had one operator per line. Putting multiple on one line, separated by space or `&nbsp;` results in operators being wrapped in double quotes in the rendered text version (although not the HTML), thus:  \r\n```\r\n            +============+===========+===================+\r\n              | Precedence |  Operator |       Syntax      |\r\n              |            |    type   |                   |\r\n              +============+===========+===================+\r\n              |     5      |  Grouping |       (...)       |\r\n              +------------+-----------+-------------------+\r\n              |     4      |  Logical  |         !         |\r\n              |            |    NOT    |                   |\r\n              +------------+-----------+-------------------+\r\n              |     3      | Relations |     \"==\" \"!=\"     |\r\n              |            |           | \"<\" \"<=\" \">\" \">=\" |\r\n              |            |           |        \"=~\"       |\r\n              |            |           |        \"in\"       |\r\n              +------------+-----------+-------------------+\r\n              |     2      |  Logical  |         &&        |\r\n              |            |    AND    |                   |\r\n              +------------+-----------+-------------------+\r\n              |     1      |  Logical  |         ||        |\r\n              |            |     OR    |                   |\r\n              +------------+-----------+-------------------+\r\n```\r\nThis is pretty ugly, so I'm going to revert to one operator per line until someone can suggest better markup.",
              "createdAt": "2021-08-07T01:19:52Z",
              "updatedAt": "2021-08-07T01:19:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0Nzc4NTcx",
          "commit": {
            "abbreviatedOid": "2e95829"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-07T01:24:16Z",
          "updatedAt": "2021-08-07T01:24:16Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Huh! The double quotes are there in the text version even when there is only one operator per line. Given I can't remove the ugliness, switching back to the multiple operators per line version.",
              "createdAt": "2021-08-07T01:24:16Z",
              "updatedAt": "2021-08-07T01:24:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0Nzc5NDAw",
          "commit": {
            "abbreviatedOid": "7b23a0a"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-07T01:33:51Z",
          "updatedAt": "2021-08-07T01:33:51Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "@cabo Do you know a way of avoiding these extraneous double quotes?",
              "createdAt": "2021-08-07T01:33:51Z",
              "updatedAt": "2021-08-07T01:33:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1MjUwNTcy",
          "commit": {
            "abbreviatedOid": "7b23a0a"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T10:57:13Z",
          "updatedAt": "2021-08-09T10:57:14Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "The extra quotes are added by xml2rfc, but I don't know why or how to avoid this. I [posted](https://mailarchive.ietf.org/arch/msg/xml2rfc/30tTnMMcJHCIH8t8-s_NVLZYrFg/) to the xml2rfc mailing list about this.",
              "createdAt": "2021-08-09T10:57:14Z",
              "updatedAt": "2021-08-09T10:57:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2MTk3MjMz",
          "commit": {
            "abbreviatedOid": "7b23a0a"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-10T09:10:01Z",
          "updatedAt": "2021-08-10T09:10:01Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "So it seems the extra quotes are caused by a [bug](https://trac.ietf.org/trac/xml2rfc/ticket/600) which will be fixed in the upcoming release of xml2rfc. I propose to leave them be for now and pick up the new release of xml2rfc in due course.",
              "createdAt": "2021-08-10T09:10:01Z",
              "updatedAt": "2021-08-10T09:10:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA3MjQ3NTE2",
      "title": "Delete old comment",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/116",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-10T10:59:42Z",
      "updatedAt": "2021-08-10T11:18:35Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "e143d9824131aa6bcd0201774ae35a872c240819",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "delete-old-comment",
      "headRefOid": "709fb1d14d7f6209dd70a65d78540eb06f993339",
      "closedAt": "2021-08-10T11:18:32Z",
      "mergedAt": "2021-08-10T11:18:32Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "79d7c588f6eb273654c336a3b75179be5e511c48"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2MzA3Mzg1",
          "commit": {
            "abbreviatedOid": "709fb1d"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-10T11:16:58Z",
          "updatedAt": "2021-08-10T11:16:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "PR_kwDOEIqrgc4spF3j",
      "title": "contain-expr reworked",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/125",
      "state": "MERGED",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-04T13:59:50Z",
      "updatedAt": "2021-10-25T18:14:36Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "79d7c588f6eb273654c336a3b75179be5e511c48",
      "headRepository": "goessner/draft-ietf-jsonpath-base",
      "headRefName": "main",
      "headRefOid": "bd791763f532cb1d2ef7b6e1ed0a5e1634d33357",
      "closedAt": "2021-10-25T18:14:36Z",
      "mergedAt": "2021-10-25T18:14:36Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "7a7decc3aeb2a5e4e9e9b9da64838a89a76af286"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4t6pra",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "My main issue with this PR is that the restrictions seem quite unintuitive.",
          "createdAt": "2021-10-04T14:10:09Z",
          "updatedAt": "2021-10-04T14:18:18Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Not sure why spaces need to be included in this token. Wouldn't it be better to require arbitrary whitespace either side of the token instead?",
              "createdAt": "2021-10-04T14:10:09Z",
              "updatedAt": "2021-10-04T14:18:18Z"
            },
            {
              "originalPosition": 22,
              "body": "Why this restriction? This behaviour would probably be surprising to most users.\r\n\r\nI think there was resistance to implementing deep equals, but I'm still not sure there's much of an issue in doing that.",
              "createdAt": "2021-10-04T14:13:25Z",
              "updatedAt": "2021-10-04T14:18:18Z"
            },
            {
              "originalPosition": 22,
              "body": "Let's avoid unnecessary acronyms:\r\n```suggestion\r\n* The value of the first operand (`containable`) of a `contain-expr` is compared to every single element of the RHS `container`. In case of a match a selection occurs. Containment tests \u2014 like comparisons \u2014 are restricted to primitive values. So even if a structured `containable` value is equal to a certain structured value in `container`, no selection is done.\r\n```",
              "createdAt": "2021-10-04T14:14:14Z",
              "updatedAt": "2021-10-04T14:18:18Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n* The value of the second operand (`container`) of a `contain-expr` needs to be resolved to an array. Otherwise nothing is selected.\r\n```",
              "createdAt": "2021-10-04T14:14:56Z",
              "updatedAt": "2021-10-04T14:18:18Z"
            },
            {
              "originalPosition": 5,
              "body": "Would `content` would be a better term than `containable`?",
              "createdAt": "2021-10-04T14:16:10Z",
              "updatedAt": "2021-10-04T14:18:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4t66rS",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:03:12Z",
          "updatedAt": "2021-10-04T15:03:12Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "In fact I was thinking about using whitespace `W` here. But there are some other locations in the spec where this should be done ... perhaps within a another special whitespace PR.\r\n",
              "createdAt": "2021-10-04T15:03:12Z",
              "updatedAt": "2021-10-04T15:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4t68iY",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:09:03Z",
          "updatedAt": "2021-10-04T15:09:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I consider `content` far too general. Perhaps `contain-val` or `contain-value` is a more specific and better term.",
              "createdAt": "2021-10-04T15:09:03Z",
              "updatedAt": "2021-10-04T15:09:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4t6-Nf",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:14:28Z",
          "updatedAt": "2021-10-04T15:14:29Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Motivation here was consistency with `comp-expr`, which is restricted to primitives. So loosening this restriction should also impact comparisons. Do we really want to open this Pandora's Box?\r\n\r\nI was referring https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/120 here.",
              "createdAt": "2021-10-04T15:14:28Z",
              "updatedAt": "2021-10-04T15:27:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4t7vuz",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T18:29:13Z",
          "updatedAt": "2021-10-04T18:29:13Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> Motivation here was consistency with comp-expr, which is restricted to primitives. So loosening this restriction should also impact comparisons. Do we really want to open this Pandora's Box?\r\n\r\nPerhaps; perhaps not. But I'd like to understand what issues there are, if any, specifying the behaviour of equality tests of non-primitives (essentially, deep equals). I think we agreed at the last meeting that _implementing_ deep equals is relatively straightforward.",
              "createdAt": "2021-10-04T18:29:13Z",
              "updatedAt": "2021-10-04T18:29:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4t7v0g",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T18:29:35Z",
          "updatedAt": "2021-10-04T18:29:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yes, a whitespace cleanup is probably overdue.",
              "createdAt": "2021-10-04T18:29:35Z",
              "updatedAt": "2021-10-04T18:29:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4t7wtL",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T18:33:35Z",
          "updatedAt": "2021-10-04T18:33:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was aiming for symmetry with `container`. If we want to be more specific, then how about something like the following?\r\n```suggestion\r\ncontain-expr = primitive-value in-op array-value\r\n```",
              "createdAt": "2021-10-04T18:33:35Z",
              "updatedAt": "2021-10-04T18:33:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4u_SEj",
          "commit": {
            "abbreviatedOid": "04d39e8"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T16:15:49Z",
          "updatedAt": "2021-10-25T16:15:50Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Blank space \u2794 #126 ",
              "createdAt": "2021-10-25T16:15:49Z",
              "updatedAt": "2021-10-25T16:15:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4u_TIA",
          "commit": {
            "abbreviatedOid": "bd79176"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T16:19:50Z",
          "updatedAt": "2021-10-25T16:19:50Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I think we should stay within comp-expr for now.\r\nMade #127 for this.",
              "createdAt": "2021-10-25T16:19:50Z",
              "updatedAt": "2021-10-25T16:19:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4u_TfS",
          "commit": {
            "abbreviatedOid": "bd79176"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T16:21:12Z",
          "updatedAt": "2021-10-25T16:21:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Let's stick with containable for now and refactor later.\r\n",
              "createdAt": "2021-10-25T16:21:13Z",
              "updatedAt": "2021-10-25T16:21:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4u_ZgX",
          "commit": {
            "abbreviatedOid": "bd79176"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Let's merge this so we have a better base for discussion.",
          "createdAt": "2021-10-25T16:44:35Z",
          "updatedAt": "2021-10-25T16:44:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOEIqrgc4t2NIc",
      "title": "Tim's comments on note and intro",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/128",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-29T12:12:22Z",
      "updatedAt": "2021-10-30T07:45:10Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "7a7decc3aeb2a5e4e9e9b9da64838a89a76af286",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "tim-note-intro",
      "headRefOid": "4ea50c7b2210c589433396e60ce13150661c6d59",
      "closedAt": "2021-10-30T07:45:09Z",
      "mergedAt": "2021-10-30T07:45:09Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "316cf6ec4c1ba819753d549844098b71392d3b4d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4vTIT-",
          "commit": {
            "abbreviatedOid": "4ea50c7"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-30T06:45:06Z",
          "updatedAt": "2021-10-30T06:45:07Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Not sure what this means. Is the intention to merge this PR or leave it open as a way of capturing the discussion at the IETF 112 meeting?",
              "createdAt": "2021-10-30T06:45:06Z",
              "updatedAt": "2021-10-30T06:45:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vTIbX",
          "commit": {
            "abbreviatedOid": "4ea50c7"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-30T06:55:01Z",
          "updatedAt": "2021-10-30T06:55:01Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "If you want to see the effect of this:\r\n\r\nhttps://ietf-wg-jsonpath.github.io/draft-ietf-jsonpath-base/tim-note-intro/draft-ietf-jsonpath-base.html\r\n\r\nThese are meant to be merged quickly, so we can have a version submitted on Nov 7 that addresses all of Tim's comments.  If there is anything controversial, we can discuss that at the IETF, but I'm sure we don't want to play the \"delay merging until doomsday\" game any longer.",
              "createdAt": "2021-10-30T06:55:01Z",
              "updatedAt": "2021-10-30T06:55:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vTImS",
          "commit": {
            "abbreviatedOid": "4ea50c7"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-30T07:06:14Z",
          "updatedAt": "2021-10-30T07:06:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 129,
      "id": "PR_kwDOEIqrgc4t8mqu",
      "title": "Move XPath comparison to appendix, replace by short history.",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/129",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-01T20:31:47Z",
      "updatedAt": "2021-11-02T08:49:15Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "316cf6ec4c1ba819753d549844098b71392d3b4d",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "xpath-inspired",
      "headRefOid": "b34dc8e5c6fca12529010133072638b2f54cc523",
      "closedAt": "2021-11-02T08:18:21Z",
      "mergedAt": "2021-11-02T08:18:21Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "f66ce6f385670b65b4e06c85fb1f9b72f114ae31"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Thanks for merging.  I had a small fix to the caption of table 1 which is now #130.",
          "createdAt": "2021-11-02T08:46:30Z",
          "updatedAt": "2021-11-02T08:49:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4vYmLs",
          "commit": {
            "abbreviatedOid": "b34dc8e"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great improvement!",
          "createdAt": "2021-11-02T07:58:58Z",
          "updatedAt": "2021-11-02T07:58:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEIqrgc4vYoEi",
          "commit": {
            "abbreviatedOid": "b34dc8e"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Additions / Replacements of high value ... thanks",
          "createdAt": "2021-11-02T08:07:54Z",
          "updatedAt": "2021-11-02T08:07:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDOEIqrgc4t98E2",
      "title": "Fix title of table 1",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/130",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-02T08:48:24Z",
      "updatedAt": "2021-11-03T02:20:20Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "f66ce6f385670b65b4e06c85fb1f9b72f114ae31",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "xpath-inspired",
      "headRefOid": "cec05a1ad0a31b993f9c013fe6653813477412a5",
      "closedAt": "2021-11-03T02:20:15Z",
      "mergedAt": "2021-11-03T02:20:15Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "504575560da180f3624d88147405fea58e53f533"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4vYzJH",
          "commit": {
            "abbreviatedOid": "cec05a1"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-02T08:54:19Z",
          "updatedAt": "2021-11-02T08:54:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEIqrgc4vctwN",
          "commit": {
            "abbreviatedOid": "cec05a1"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-03T02:20:02Z",
          "updatedAt": "2021-11-03T02:20:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "PR_kwDOEIqrgc4uCIqH",
      "title": "blank space added",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/131",
      "state": "MERGED",
      "author": "goessner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... and some minor edits ...",
      "createdAt": "2021-11-03T12:27:45Z",
      "updatedAt": "2021-11-04T14:35:08Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "504575560da180f3624d88147405fea58e53f533",
      "headRepository": "goessner/draft-ietf-jsonpath-base",
      "headRefName": "main",
      "headRefOid": "9da13ab4005aac6864ecbd8f1c38f5ff26a7aaa2",
      "closedAt": "2021-11-04T10:09:46Z",
      "mergedAt": "2021-11-04T10:09:46Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "22582930209e0b745dc606681f44c683dfc37d7c"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "body": "Indeed.  I'll do a small PR with my points.",
          "createdAt": "2021-11-04T10:10:02Z",
          "updatedAt": "2021-11-04T10:10:02Z"
        },
        {
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "body": "a little late to the party ... thanks",
          "createdAt": "2021-11-04T14:35:08Z",
          "updatedAt": "2021-11-04T14:35:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4veXTi",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-03T12:48:26Z",
          "updatedAt": "2021-11-03T12:48:26Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "definition of `exist-expr` might be not necessary with \r\n\r\n```\r\nbasic-expr   = [neg-op] path /        ; path existence or non-existence\r\n               [neg-op] paren-expr / \r\n               relation-expr\r\n```",
              "createdAt": "2021-11-03T12:48:26Z",
              "updatedAt": "2021-11-03T12:51:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vh-aP",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T08:03:37Z",
          "updatedAt": "2021-11-04T08:03:37Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I agree `exist-expr` isn't formally necessary, but it gives us a place to highlight the purpose of the syntax and to give it a meaningful name.",
              "createdAt": "2021-11-04T08:03:37Z",
              "updatedAt": "2021-11-04T08:03:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4viJad",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T08:57:10Z",
          "updatedAt": "2021-11-04T08:57:11Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "You can't select members, only member values.\r\n",
              "createdAt": "2021-11-04T08:57:10Z",
              "updatedAt": "2021-11-04T08:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4viJbg",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T08:57:15Z",
          "updatedAt": "2021-11-04T08:57:16Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "So no space between `[` and `?`?",
              "createdAt": "2021-11-04T08:57:15Z",
              "updatedAt": "2021-11-04T08:57:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4viJwK",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T08:58:44Z",
          "updatedAt": "2021-11-04T08:58:44Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Style comment: I have tried to indicate ABNF operator precedence using parentheses.  Maybe not needed here because of the grouping into lines.",
              "createdAt": "2021-11-04T08:58:44Z",
              "updatedAt": "2021-11-04T08:58:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4viP5a",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This PR could be merged to make progress. Further changes as indicated by @cabo are probably needed, either now or in a subsequent PR.",
          "createdAt": "2021-11-04T09:24:51Z",
          "updatedAt": "2021-11-04T09:24:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEIqrgc4vjapY",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:26:19Z",
          "updatedAt": "2021-11-04T14:26:19Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "that was what I was thinking ... agreed, so let it in.",
              "createdAt": "2021-11-04T14:26:19Z",
              "updatedAt": "2021-11-04T14:26:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vjcPa",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:31:00Z",
          "updatedAt": "2021-11-04T14:31:01Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I overlooked, that Glyn's original text was correct, as he was referring to that specific example. So possibly better\r\n```\r\nNext, `[*]` selects from any input node \u2014 an array here \u2014 all its elements.\r\n``` \r\n@cabo is right regarding members though.",
              "createdAt": "2021-11-04T14:31:00Z",
              "updatedAt": "2021-11-04T14:31:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vjc9J",
          "commit": {
            "abbreviatedOid": "9da13ab"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:33:03Z",
          "updatedAt": "2021-11-04T14:33:03Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "no ... might be an extension to the standard making no harm.",
              "createdAt": "2021-11-04T14:33:03Z",
              "updatedAt": "2021-11-04T14:33:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 132,
      "id": "PR_kwDOEIqrgc4uFo2n",
      "title": "Various nits on #129, #131",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/132",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Lots of niggly details re blank space.\r\nStyle consistency, some missing places (assuming we stick with the liberal approach).\r\nAllowing \"in\" before or after a newline or tab.\r\nAdding some legend to the only remaining table with XPath content in the main document.\r\n",
      "createdAt": "2021-11-04T11:20:25Z",
      "updatedAt": "2021-11-04T16:13:41Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "22582930209e0b745dc606681f44c683dfc37d7c",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "nits-131-129",
      "headRefOid": "026effbebea38fb652daf9171aae993a263dbe18",
      "closedAt": "2021-11-04T16:13:41Z",
      "mergedAt": "2021-11-04T16:13:41Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "e3d7d08d9a2bbaac26c711d79ead1f3373582b42"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4vjgC_",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:42:08Z",
          "updatedAt": "2021-11-04T14:42:08Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "yes, I was stumbeling over that also ...",
              "createdAt": "2021-11-04T14:42:08Z",
              "updatedAt": "2021-11-04T14:42:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vjh6Q",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:47:39Z",
          "updatedAt": "2021-11-04T14:47:40Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Do we really want to allow jsonpathes  scattered across several lines\r\n\r\n```\r\n$   .   a\r\n[ 'b' ] \r\n[ 123 ] \r\n\r\nHas there been users demand for this ?",
              "createdAt": "2021-11-04T14:47:39Z",
              "updatedAt": "2021-11-04T14:47:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vjigc",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:49:23Z",
          "updatedAt": "2021-11-04T14:49:24Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "definitely better now ...",
              "createdAt": "2021-11-04T14:49:23Z",
              "updatedAt": "2021-11-04T14:49:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vjitW",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:49:58Z",
          "updatedAt": "2021-11-04T14:49:58Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "yes ... needed once for now ...",
              "createdAt": "2021-11-04T14:49:58Z",
              "updatedAt": "2021-11-04T14:50:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vji-x",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:50:46Z",
          "updatedAt": "2021-11-04T14:50:46Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "You mean, allowing newlines in JSONPath?  Depends a bit on how long they are.  I seem to remember we wanted to be lenient here...\r\n",
              "createdAt": "2021-11-04T14:50:46Z",
              "updatedAt": "2021-11-04T14:50:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vjjMy",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:51:24Z",
          "updatedAt": "2021-11-04T14:51:25Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "hmm ... consistent with blank philosophy above though",
              "createdAt": "2021-11-04T14:51:25Z",
              "updatedAt": "2021-11-04T14:51:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vjlvb",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-04T14:58:36Z",
          "updatedAt": "2021-11-04T14:58:36Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "yes i can remember darkly too ... so your edits all in all make sense.",
              "createdAt": "2021-11-04T14:58:36Z",
              "updatedAt": "2021-11-04T14:58:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEIqrgc4vj7ZR",
          "commit": {
            "abbreviatedOid": "026effb"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-04T16:03:19Z",
          "updatedAt": "2021-11-04T16:03:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDOEIqrgc4uUudc",
      "title": "Break ABNF syntax",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/133",
      "state": "CLOSED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "scripts/gen.sh fails with:\r\n\r\n...\r\nstdin(0:12): error: state 19, token $end: syntax error, unexpected '='\r\nparsing failed: 1 errors encountered\r\n\r\nand returns a non-zero exit status code.",
      "createdAt": "2021-11-10T03:03:48Z",
      "updatedAt": "2021-11-10T03:09:21Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "e3d7d08d9a2bbaac26c711d79ead1f3373582b42",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "bad-abnf",
      "headRefOid": "66010cb3981530e932be03f0d3a9d991f0e10b41",
      "closedAt": "2021-11-10T03:09:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 134,
      "id": "PR_kwDOEIqrgc4uVtw3",
      "title": "Define partial determinism of ..",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/134",
      "state": "MERGED",
      "author": "glyn",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/issues/103",
      "createdAt": "2021-11-10T10:31:53Z",
      "updatedAt": "2021-11-10T10:45:17Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "e3d7d08d9a2bbaac26c711d79ead1f3373582b42",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "descendant-selector-partial-determinism",
      "headRefOid": "3cc1dafb70123290321ed6839bfc30ae59a0ed63",
      "closedAt": "2021-11-10T10:45:13Z",
      "mergedAt": "2021-11-10T10:45:12Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "641d013bae79bf50f4e478879c4b865891d0cd55"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4v089F",
          "commit": {
            "abbreviatedOid": "3cc1daf"
          },
          "author": "goessner",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-10T10:37:45Z",
          "updatedAt": "2021-11-10T10:37:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEIqrgc4v0-mG",
          "commit": {
            "abbreviatedOid": "3cc1daf"
          },
          "author": "cabo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-10T10:44:19Z",
          "updatedAt": "2021-11-10T10:44:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "PR_kwDOEIqrgc4uV_LE",
      "title": "Create TOOLS.md from issue 82",
      "url": "https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/135",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Close #82",
      "createdAt": "2021-11-10T12:02:21Z",
      "updatedAt": "2021-11-10T12:03:00Z",
      "baseRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "baseRefName": "main",
      "baseRefOid": "641d013bae79bf50f4e478879c4b865891d0cd55",
      "headRepository": "ietf-wg-jsonpath/draft-ietf-jsonpath-base",
      "headRefName": "tools-md",
      "headRefOid": "8df7a8017d7b303cfcc686f5f232d066e5ec5b47",
      "closedAt": "2021-11-10T12:02:57Z",
      "mergedAt": "2021-11-10T12:02:57Z",
      "mergedBy": "glyn",
      "mergeCommit": {
        "oid": "fe6e1462c1015ec52ea53dda756ddcdab8bb076c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEIqrgc4v1Qdi",
          "commit": {
            "abbreviatedOid": "8df7a80"
          },
          "author": "glyn",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-10T12:02:48Z",
          "updatedAt": "2021-11-10T12:02:48Z",
          "comments": []
        }
      ]
    }
  ]
}